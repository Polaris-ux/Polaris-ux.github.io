<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java基础复习"><meta name="keywords" content="Java"><meta name="author" content="Laity&amp;"><meta name="copyright" content="Laity&amp;"><title>Java基础复习 | Laity的日常博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.</span> <span class="toc-text">面向对象的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">权限修饰符的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Java中的基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#switch%E8%83%BD%E5%A4%9F%E4%BD%9C%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">switch能够作用的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">String、StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E5%8A%A0%E8%BD%BDclass%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">JVM加载class文件的原理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="toc-number">8.</span> <span class="toc-text">抽象类和接口有什么异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BC%9A%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%90%97"><span class="toc-number">9.</span> <span class="toc-text">Java会存在内存泄漏吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%AF%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%98%AF%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95-native-%EF%BC%8C%E6%98%AF%E5%90%A6%E5%8F%AF%E5%90%8C%E6%97%B6%E8%A2%ABsynchronized%E4%BF%AE%E9%A5%B0"><span class="toc-number">10.</span> <span class="toc-text">抽象方法是否可以是静态的？是否可以是本地方法(native)，是否可同时被synchronized修饰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">静态变量和实例变量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="toc-number">12.</span> <span class="toc-text">如何实现对象克隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89GC"><span class="toc-number">13.</span> <span class="toc-text">GC是什么？为什么要有GC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-s-new-String-%E2%80%9Cxyz%E2%80%9D-%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">String s&#x3D;new String(“xyz”);创建了几个字符串对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%85%B6%E5%AE%83%E7%B1%BB%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.</span> <span class="toc-text">匿名内部类是否可以继承其它类？是否可以实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E5%AE%83%E7%9A%84%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%90%97%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">一个内部类可以引用它的外部类的成员吗？有没有什么限制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84final%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">Java中的final关键字有哪些用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC"><span class="toc-number">18.</span> <span class="toc-text">递归实现字符串反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%92%8CJavaScript%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">19.</span> <span class="toc-text">Java和JavaScript的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80-assert-%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">什么时候使用断言(assert)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error%E5%92%8CException%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">Error和Exception有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BD%95%E5%BC%82%E5%90%8C"><span class="toc-number">22.</span> <span class="toc-text">运行时异常与受检异常有何异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">23.</span> <span class="toc-text">常见异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finalize"><span class="toc-number">24.</span> <span class="toc-text">finalize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E3%80%81Vector-%E3%80%81LinkedList%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">25.</span> <span class="toc-text">ArrayList、Vector 、LinkedList的存储性能和特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">26.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E7%B1%BB%E7%9A%84sleep-%E6%96%B9%E6%B3%95%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84wait-%E6%96%B9%E6%B3%95%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%AE%A9%E7%BA%BF%E7%A8%8B%E6%9A%82%E5%81%9C%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%AE%83%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84sleep-%E6%96%B9%E6%B3%95%E5%92%8Cyield-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">线程的sleep()方法和yield()方法有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84synchronized%E6%96%B9%E6%B3%95A%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E8%BF%9B%E5%85%A5%E6%AD%A4%E5%AF%B9%E8%B1%A1%E7%9A%84synchronized%E6%96%B9%E6%B3%95B"><span class="toc-number">29.</span> <span class="toc-text">当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">请说出与线程同步以及线程调度相关的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">31.</span> <span class="toc-text">什么是线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized%E5%92%8Cjava-util-concurrent-locks-Lock%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">32.</span> <span class="toc-text">synchronized和java.util.concurrent.locks.Lock的异同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">33.</span> <span class="toc-text">Java中如何实现序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B5%81"><span class="toc-number">34.</span> <span class="toc-text">Java中有几种类型的流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML%E6%96%87%E6%A1%A3%E5%AE%9A%E4%B9%89%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%A7%A3%E6%9E%90XML%E6%96%87%E6%A1%A3%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">35.</span> <span class="toc-text">XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Statement%E5%92%8CPrepareStatement%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">Statement和PrepareStatement有什么区别？哪个性能更好？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">37.</span> <span class="toc-text">数据库连接池有什么用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDAO%E6%A8%A1%E5%BC%8F"><span class="toc-number">38.</span> <span class="toc-text">什么是DAO模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88"><span class="toc-number">39.</span> <span class="toc-text">事务的ACID是指什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">40.</span> <span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86"><span class="toc-number">41.</span> <span class="toc-text">JDBC中如何进行事务处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E2%80%9C%E5%85%AD%E5%8E%9F%E5%88%99%E4%B8%80%E6%B3%95%E5%88%99%E2%80%9D"><span class="toc-number">42.</span> <span class="toc-text">面向对象的“六原则一法则”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">43.</span> <span class="toc-text">简述一下你了解的设计模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8java%E5%86%99%E4%B8%80%E4%B8%AA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">44.</span> <span class="toc-text">用java写一个冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%90%E8%BF%B0Servlet%E5%92%8CCGI"><span class="toc-number">45.</span> <span class="toc-text">阐述Servlet和CGI</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Servlet%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">46.</span> <span class="toc-text">Servlet接口中有哪些方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91-forward-%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91-redirect-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">47.</span> <span class="toc-text">转发(forward)和重定向(redirect)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSP%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF"><span class="toc-number">48.</span> <span class="toc-text">JSP有哪些内置对象？作用分别是</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM"><span class="toc-number">49.</span> <span class="toc-text">什么是ORM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%B1%82%E8%AE%BE%E8%AE%A1%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E9%97%AE%E9%A2%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BD%A0%E7%94%A8%E8%BF%87%E7%9A%84%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">50.</span> <span class="toc-text">持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9%E7%BB%A7%E6%89%BF%E6%98%A0%E5%B0%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">51.</span> <span class="toc-text">谈一下你对继承映射的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E4%B8%AD%E4%BD%BF%E7%94%A8-%E5%92%8C-%E4%B9%A6%E5%86%99%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">52.</span> <span class="toc-text">MyBatis中使用#和$书写占位符的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">53.</span> <span class="toc-text">MyBatis中命名空间(namespace)的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81SQL"><span class="toc-number">54.</span> <span class="toc-text">MyBatis中的动态SQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIOC%E5%92%8CDI-DI%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">55.</span> <span class="toc-text">什么是IOC和DI?DI是如何实现的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">56.</span> <span class="toc-text">Spring中Bean的作用域有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">57.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%8F%ABAOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">什么叫AOP(面向切面编程)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8"><span class="toc-number">59.</span> <span class="toc-text">如何理解横切关注</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3AOP%E4%B8%AD%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%82%B9-Joinpoint-%E3%80%81%E5%88%87%E7%82%B9-Pointcut-%E3%80%81%E5%A2%9E%E5%BC%BA-Advice-%E3%80%81%E5%BC%95%E4%BB%8B-Introduction-%E3%80%81%E7%BB%87%E5%85%A5-Weaving-%E3%80%81%E5%88%87%E9%9D%A2-Aspect-%E8%BF%99%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">60.</span> <span class="toc-text">如何理解AOP中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">61.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%B8%AD%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">62.</span> <span class="toc-text">Spring中自动装配的方式有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9D%A5%E9%85%8D%E7%BD%AEBean"><span class="toc-number">63.</span> <span class="toc-text">Spring中如何使用注解来配置Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">64.</span> <span class="toc-text">Spring支持的事务管理类型有哪些？你在项目中使用哪种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AESpring%E7%9A%84IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">65.</span> <span class="toc-text">如何在Web项目中配置Spring的IOC容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AESpringMVC"><span class="toc-number">66.</span> <span class="toc-text">如何在Web项目中配置SpringMVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">67.</span> <span class="toc-text">Spring MVC的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Spring-IOC%E5%AE%B9%E5%99%A8%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">68.</span> <span class="toc-text">如何在Spring IOC容器中配置数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E5%A2%9E%E5%BC%BA"><span class="toc-number">69.</span> <span class="toc-text">如何配置事务增强</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">70.</span> <span class="toc-text">Spring框架为企业级开发带来的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-IOC%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AEBean%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">71.</span> <span class="toc-text">Spring IOC容器配置Bean的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%90%E8%BF%B0Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">72.</span> <span class="toc-text">阐述Spring中Bean的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%97%B6%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E9%9B%86%E5%90%88%E5%B1%9E%E6%80%A7"><span class="toc-number">73.</span> <span class="toc-text">依赖注入时如何注入集合属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%89%E5%93%AA%E4%BA%9B%E9%99%90%E5%88%B6"><span class="toc-number">74.</span> <span class="toc-text">Spring的自动装配有哪些限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Web%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97Spring%E7%9A%84IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">75.</span> <span class="toc-text">在Web项目中如何获得Spring的IOC容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E5%9C%A8%E6%9E%B6%E6%9E%84%E4%B8%8A%E5%BA%94%E5%BD%93%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">76.</span> <span class="toc-text">大型网站在架构上应当考虑哪些问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87%E7%9A%84%E7%BD%91%E7%AB%99%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">77.</span> <span class="toc-text">你使用过的网站前端优化的技术有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">78.</span> <span class="toc-text">应用服务器优化技术有哪些</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFCSRF%E6%94%BB%E5%87%BB"><span class="toc-number">79.</span> <span class="toc-text">什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://th.bing.com/th/id/R.ddf36bf62e6f5fff5bf8c74284c0983a?rik=gL1kHAzol0ZsCg&amp;riu=http%3a%2f%2fimg.jj20.com%2fup%2fallimg%2ftx26%2f420812170231383.jpg&amp;ehk=dftFXuBhZYOq24%2foZJxW6BcDBdLJRArAKByCS%2f7z1KQ%3d&amp;risl=&amp;pid=ImgRaw"></div><div class="author-info__name text-center">Laity&amp;</div><div class="author-info__description text-center">出发，永远是最有意义的事，去做就是了</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">37</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">29</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://th.bing.com/th/id/R.db1eab53ff269e5709d90f8b197fafb7?rik=zABgriNA09F1vA&amp;riu=http%3a%2f%2fwww.shijuepi.com%2fuploads%2fallimg%2f201128%2f1-20112QP934.jpg&amp;ehk=Lr%2f%2fq1LA75MkgirCJbR87lb7M%2bZJlTMtjvLaj6Bg0lE%3d&amp;risl=&amp;pid=ImgRaw)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Laity的日常博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">Java基础复习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-11-27</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%8D%9A%E5%AE%A2/">博客</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%8D%9A%E5%AE%A2/Java%E5%90%8E%E7%AB%AF/">Java后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%8D%9A%E5%AE%A2/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/11/27/Java基础复习/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结构造类的过程，包括数据抽象和行为抽象。抽象只关注对象有哪些属性和行为，并不关注具体的细节。</p>
<p><strong>继承</strong>：继承是从已有的类得到继承信息构建新的类的过程。提供继承信息的称为父类（超类或基类）。得到继承信息的称为子类（派生类）。继承大大的提高了代码的可复用性，可以让变化中的软件系统有一定的延续性。Java中的类只能单继承，不支持多继承。</p>
<p><strong>封装</strong>：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。这样使用户使用我们所编写的程序时，只需要通过已定义的接口来访问所需要的操作，而不需要了解接口中的细节。充分的实现了高内聚。</p>
<p><strong>多态性</strong>：多态性是指允许对不同子类型的对象对同一消息做出不同的响应。即同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时多态和运行时多态。</p>
<p>方法重载实现的是编译时多态，方法重写实现的是运行时多态</p>
<h4 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a><strong>权限修饰符的区别</strong></h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211127142835338.png" class title="image-20211127142835338">



<h4 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h4><p>byte: 1个字节</p>
<p>short: 2个字节</p>
<p>int: 4个字节</p>
<p>long: 8个字节</p>
<p>float: 4个字节（单精度）</p>
<p>double: 8个字节（双精度）</p>
<p>char: 英文字母一个字节，中文2-4个字节</p>
<p>boolean</p>
<h4 id="switch能够作用的类型"><a href="#switch能够作用的类型" class="headerlink" title="switch能够作用的类型"></a>switch能够作用的类型</h4><p>从Java7开始，expr:byte\short\int\char\String</p>
<p>在Java7之前，expr只能为byte\short\int\char</p>
<p><strong>当一个对象被当作参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</strong></p>
<p>是值传递。Java语言的方法中只支持参数的值传递。当一个对象实例被传递到方法中时，参数的值就是该对象的引用。</p>
<h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><p>String是不可变字符串，而StringBuilder、StringBuffer是可变字符串。StringBuilder是Java 5引入的，因此它和StringBuffer的方法完全相同，区别在于StringBuffer的方法都被synchronized修饰是线程安全的，而StringBuilder则是线程不安全的，因此StringBuilder比StringBuffer的效率要高。</p>
<p> 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象</p>
<h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>重载和重写都是多态的体现。重载实现的是编译时的多态，发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或都不同）则视为重载。重写实现的是运行时多态，发生在父类与子类之间，重写要求子类重写的方法与父类被重写的方法有相同的返回值，权限访问符不能低于父类方法的权限访问符，不能比父类方法声明更多的异常。</p>
<p><strong>为什么不能根据返回类型来区分重载</strong></p>
<p>原因：调用方法时不能指定具体类型，编译器不知道需要调用哪个函数。</p>
<h4 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h4><p>JVM中的类的加载是由类加载器(ClassLoader)和它的子类实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件的类。</p>
<p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用到某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把.class文件中的数据读入到内存中，通常是创建一个byte[] 读入数据，然后产生与加载类对应的class对象。加载后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：如果类存在直接父类并且这个类还没有被初始化，那么就先初始化父类；如果类中存在初始化语句，就依次执行这些语句。</p>
<p>类的加载是由类加载器完成的，类加载器包括：根加载器(BootStrap)、扩展加载器(Extension)、类加载器(System)和用户自定义类加载器。从Java2开始，类加载过程中采取了父亲委托机制(PDM).PDM保证了Java平台的安全性，在该机制中，JVM自带的BootStrap是根加载器，其它的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器进行加载。JVM不会向Java程序提供对BootStrap的引用。</p>
<h4 id="抽象类和接口有什么异同"><a href="#抽象类和接口有什么异同" class="headerlink" title="抽象类和接口有什么异同"></a>抽象类和接口有什么异同</h4><p>异：</p>
<ul>
<li>抽象类中可以定义构造器，而接口不能定义接口</li>
<li>抽象类中可以定义成员变量，接口里只能定义常量</li>
<li>抽象类的成员的权限修饰符可以是private、protected、default、public，而接口中的成员都是public</li>
</ul>
<p>同：</p>
<ul>
<li>都不能实例化</li>
<li>继承了抽象类，或实现了接口都必须对它们里面的抽象方法进行重写</li>
</ul>
<h4 id="Java会存在内存泄漏吗"><a href="#Java会存在内存泄漏吗" class="headerlink" title="Java会存在内存泄漏吗"></a>Java会存在内存泄漏吗</h4><p>理论上Java因为有垃圾回收机制(GC)不会存在内存泄漏问题，然而在实际开发中，存在无用但可达的对象，这些对象，GC不会对其进行垃圾回收，因此也可能会导致内存泄漏。</p>
<h4 id="抽象方法是否可以是静态的？是否可以是本地方法-native-，是否可同时被synchronized修饰"><a href="#抽象方法是否可以是静态的？是否可以是本地方法-native-，是否可同时被synchronized修饰" class="headerlink" title="抽象方法是否可以是静态的？是否可以是本地方法(native)，是否可同时被synchronized修饰"></a>抽象方法是否可以是静态的？是否可以是本地方法(native)，是否可同时被synchronized修饰</h4><p>抽象方法需要子类重写，静态方法不能被重写；本地方法是由本地代码如(C语言)实现的方法，而抽象方法是，没有实现的；synchronized和方法的实现细节有关，抽象方法不涉及实现细节</p>
<h4 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别"></a>静态变量和实例变量的区别</h4><p>静态变量是由static修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中仅有一个拷贝即静态变量只会被加载一次。示例变量必须依存于某一实例，需要先创建对象才可以被访问到，而静态变量可以直接通过类访问。</p>
<h4 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h4><ul>
<li>实现Cloneable接口并重写Object类的clone()方法</li>
<li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">17020286042305L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, maxSpeed=&quot;</span> + maxSpeed +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, car=&quot;</span> + car +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现Cloneable接口实现浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;28394&quot;</span>, <span class="number">19</span>,<span class="keyword">new</span> Car(<span class="string">&quot;大众&quot;</span>,<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student clone = stu.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// true，因为Car对象未实现Cloneable接口</span></span><br><span class="line">            System.out.println(clone.getCar()==stu.getCar());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String uid, <span class="keyword">int</span> age,Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car=car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, car=&quot;</span> + car +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Student <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Serializable接口，实现深拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> (T)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCloneUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="keyword">new</span> Car(<span class="string">&quot;BMW&quot;</span>,<span class="number">120</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person clone = MyUtil.clone(p);</span><br><span class="line">            <span class="comment">// true</span></span><br><span class="line">            System.out.println(p.getCar()==clone.getCar());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种方案明显是优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露总是好过把问题留到运行时</p>
<h4 id="GC是什么？为什么要有GC"><a href="#GC是什么？为什么要有GC" class="headerlink" title="GC是什么？为什么要有GC"></a>GC是什么？为什么要有GC</h4><p>GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。Java的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p>
<p>垃圾回收可以有效的防止内存泄漏，合理并有效的使用有效的内存。垃圾回收器通常作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡或长时间未使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p>
<h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s=new String(“xyz”);创建了几个字符串对象"></a>String s=new String(“xyz”);创建了几个字符串对象</h4><p>两个，一个在字符串常量池，一个new 在堆中</p>
<h4 id="匿名内部类是否可以继承其它类？是否可以实现接口"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口"></a>匿名内部类是否可以继承其它类？是否可以实现接口</h4><p>可以继承其它类或实现其它接口，在Swing编程和Adroid开发中常用此方式来实现事件监听和回调</p>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interfance Product</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String  <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">(Product p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(p.getName()+<span class="string">&quot;--------&quot;</span>+p.getPrice());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [ ] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Anonymous as= <span class="keyword">new</span> Anonymous ();</span><br><span class="line">          as.test(<span class="keyword">new</span> Product( )<span class="comment">//此处实现接口并实现抽象方法</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">( )</span><span class="comment">//实现方法</span></span></span><br><span class="line"><span class="function">                 </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">8888</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                 <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">( )</span><span class="comment">//实现方法</span></span></span><br><span class="line"><span class="function">                  </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="string">&quot;I can do it &quot;</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="一个内部类可以引用它的外部类的成员吗？有没有什么限制？"><a href="#一个内部类可以引用它的外部类的成员吗？有没有什么限制？" class="headerlink" title="一个内部类可以引用它的外部类的成员吗？有没有什么限制？"></a>一个内部类可以引用它的外部类的成员吗？有没有什么限制？</h4><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员</p>
<h4 id="Java中的final关键字有哪些用法"><a href="#Java中的final关键字有哪些用法" class="headerlink" title="Java中的final关键字有哪些用法"></a>Java中的final关键字有哪些用法</h4><p>修饰类：表示该类不能被继承</p>
<p>修饰方法：表示方法不能被重写</p>
<p>修饰变量：表示变量只能被赋值一次，且不能修改</p>
<h4 id="递归实现字符串反转"><a href="#递归实现字符串反转" class="headerlink" title="递归实现字符串反转"></a>递归实现字符串反转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归反转字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseStr(str.substring(<span class="number">1</span>))+str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Java和JavaScript的比较"><a href="#Java和JavaScript的比较" class="headerlink" title="Java和JavaScript的比较"></a>Java和JavaScript的比较</h4><p><strong>解释和编译不同</strong>：Java的源代码在执行之前必须经过编译。JavaScript是一种解释型编程语言，其源代码不需要经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT：及时编译技术来提升JavaScript的运行效率）。</p>
<p><strong>基于对象和面向对象</strong>：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象和事件驱动的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用</p>
<p><strong>代码格式不一样</strong></p>
<p><strong>强类型变量和类型若变量：</strong>Java采用强类型变量检查，即所有变量在编译之前必须做声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</p>
<h4 id="什么时候使用断言-assert-？"><a href="#什么时候使用断言-assert-？" class="headerlink" title="什么时候使用断言(assert)？"></a>什么时候使用断言(assert)？</h4><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError.</p>
<p>要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或禁用断言。</p>
<h4 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别"></a>Error和Exception有什么区别</h4><p>Error是系统级的错误和程序不必处理的异常，是恢复很困难的一种严重问题；比如内存溢出，程序无法处理这种异常。Exception是需要程序捕获和处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<h4 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h4><p>异常是指程序运行过程中出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<p>使用建议：对可以恢复的情况使用受检异常，对程序错误使用运行时异常</p>
<h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><ul>
<li>ArithmeticException：算术异常</li>
<li>ClassCastException：类型转换异常</li>
<li>IllegalArgumentException：非法参数异常</li>
<li>IndexOutOfBoundsException：下标越界</li>
<li>NullPointerException：空指针异常</li>
<li>SecurityException：安全异常</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>Object类中定义的方法，Java允许使用finalize()方法在垃圾回收器将对象从内存中清理出去之前做必要的清理工作，这个方法是由垃圾回收器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或执行其它清理工作</p>
<h4 id="ArrayList、Vector-、LinkedList的存储性能和特性"><a href="#ArrayList、Vector-、LinkedList的存储性能和特性" class="headerlink" title="ArrayList、Vector 、LinkedList的存储性能和特性"></a>ArrayList、Vector 、LinkedList的存储性能和特性</h4><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入对象，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，所以Vector是线程安全的容器，但效率相对于ArrayList较低。LinkedList使用双向链表的方式实现存储(将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高)，按序号索引数据需要进行向前或向后遍历，但插入数据时只需要记录本项的前后项即可，插入速度较快。</p>
<p>Vector是遗留容器不推荐使用，ArrayList、LinkedList都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过Collections的synchronized方法将其转换为线程安全的容器后再进行操作(这是对装潢模式的使用，将已有对象传入另一个类的构造器中创建新的对象来增强)</p>
<h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程是操作系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调用和分派的基本单位，是比进程更小的能独立运行的的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时有通常拥有独立的一块内存单元，而线程只占用很少一部分内存(程序计数器、本地方法栈、Java虚拟机栈)，线程之间可以共享内存。使用多线程的编程通常能带来更好的性能和用户体验，但是多线程的程序对其它程序是不友好的，因为它可能会占用更多的CPU资源。当然也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。</p>
<h4 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</h4><p>sleep()方法是线程类(Thread)的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会(CPU)让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会回到就绪状态。</p>
<p>wait()方法是Object类的方法，调用wait()方法会导致当前线程放弃当前的锁(线程暂停执行)，进入对象的等待池(wait pool)，只有调用对象的notify()\notifyAll()方法时才能唤醒等待池中的线程，当线程重新获得锁时就会进入就绪状态。</p>
<h4 id="线程的sleep-方法和yield-方法有什么区别"><a href="#线程的sleep-方法和yield-方法有什么区别" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别"></a>线程的sleep()方法和yield()方法有什么区别</h4><ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</li>
<li>线程执行sleep()方法后转入阻塞状态；而线程执行yield()方法后进入就绪状态</li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常</li>
<li>sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性</li>
</ul>
<h4 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</h4><p>不能，其他线程只能访问该对象的非同步方法，同步方法则不能进入。因为synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被占用了，试图进入方法B的线程只能在等锁池中等待。</p>
<h4 id="请说出与线程同步以及线程调度相关的方法"><a href="#请说出与线程同步以及线程调度相关的方法" class="headerlink" title="请说出与线程同步以及线程调度相关的方法"></a>请说出与线程同步以及线程调度相关的方法</h4><p>wait()：使一个线程进入阻塞状态，并释放所持有的对象的锁</p>
<p>sleep()：是一个线程进入阻塞状态，是一个静态方法，调用此方法需要处理InterruptedException</p>
<p>notify()：唤醒一个处于等待状态的线程，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关。（是否随机取决于jvm，hospot中notify()是顺序唤醒的）</p>
<p>notifyAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让所有线程去竞争锁，获取到锁之后才能进入就绪状态。</p>
<h4 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h4><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因。</p>
<p>线程池：事先创建若干个可执行的线程放入一个池中，需要的时候从池中获取线程不用自己创建，使用完毕后不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p>
<p>Java 5+中的Excutor接口定义一个执行线程的工具。它的子类型即线程池接口是ExcutorService。要配置一个线程池是比较复杂的，因此在工具类Excutors里面提供了一些静态工厂方法，生成一些常用的线程池：</p>
<ul>
<li>newSingleThreadExcutor:创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。若这个线程异常结束，则会有新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程会补充一个新线程。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务的所需要的线程，那么会回收部分空闲(60秒不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池的大小做限制，线程池的大小完全依赖于操作系统（或JVM）所能创建的线程大小</li>
<li>newSchduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li>newSingleThreadExcutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h4 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h4><p>同：Lock是Java5以后引入的；Lock能够实现synchronized所实现的所有功能</p>
<p>异：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，Lock需要手动释放锁，并且最好在finally块中释放</p>
<h4 id="Java中如何实现序列化"><a href="#Java中如何实现序列化" class="headerlink" title="Java中如何实现序列化"></a>Java中如何实现序列化</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态），如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能实现对象的深度克隆、</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">    oos.writeObject(obj);</span><br><span class="line">    ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">    <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">    <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">    <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Java中有几种类型的流"><a href="#Java中有几种类型的流" class="headerlink" title="Java中有几种类型的流"></a>Java中有几种类型的流</h4><p>字节流：继承于InputStream、OutputStream</p>
<p>字符流：继承于Reader、Writer</p>
<p>使用到的设计模式：适配器模式和装饰者模式</p>
<p>面试题：实现文件拷贝</p>
<p>用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现文件拷贝</span></span><br><span class="line">    <span class="comment">// 传统io流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String source,String target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis=<span class="keyword">new</span> FileInputStream(source))&#123;</span><br><span class="line">            <span class="keyword">try</span>(FileOutputStream out=<span class="keyword">new</span> FileOutputStream(target))&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nio实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String source,String target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis=<span class="keyword">new</span> FileInputStream(source))&#123;</span><br><span class="line">            <span class="keyword">try</span>(FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(target))&#123;</span><br><span class="line">                FileChannel fisChannel = fis.getChannel();</span><br><span class="line">                FileChannel fosChannel = fos.getChannel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">2048</span>);</span><br><span class="line">                <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(fisChannel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    fosChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h4 id="XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式"><a href="#XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式" class="headerlink" title="XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式"></a>XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式</h4><p>类型：分为DTD和Schema两种形式，二者都是对XML语法的约束</p>
<p>本质区别：Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更加强大。</p>
<p>解析XML文档的方式：</p>
<ul>
<li><p>DOM(文档对象模型，Document Object Model)</p>
<p>处理大型文件时性能下降得非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM的解析方式必须在解析文件之前把整个微博大部分装入内存，适合对XML的随机访问（典型的空间换时间）</p>
</li>
<li><p>SAX(Simple API for XML)</p>
<p>事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束、或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问。</p>
</li>
<li><p>StAX(Streaming API for XML)</p>
<p>把重心放在流上，把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖(SAX就是这样)，但不同之处在于StAX允许应用程序代码把这些这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
</li>
</ul>
<h4 id="Statement和PrepareStatement有什么区别？哪个性能更好？"><a href="#Statement和PrepareStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PrepareStatement有什么区别？哪个性能更好？"></a>Statement和PrepareStatement有什么区别？哪个性能更好？</h4><p>与Statement相比：</p>
<ul>
<li>PreparedStatement接口代表预编译的语句，它的主要优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注入问题）</li>
<li>PreparedStatement中的SQL语句可以带参数，避免了用字符串连接拼接SQL语句的麻烦和不安全</li>
<li>当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用重新编译和生成执行计划）</li>
</ul>
<h4 id="数据库连接池有什么用"><a href="#数据库连接池有什么用" class="headerlink" title="数据库连接池有什么用"></a>数据库连接池有什么用</h4><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要四次挥手，造成的开销是不可忽略的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免了频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略(浪费了空间存储连接，但节省了创建和释放连接的时间)。</p>
<h4 id="什么是DAO模式"><a href="#什么是DAO模式" class="headerlink" title="什么是DAO模式"></a>什么是DAO模式</h4><p>DAO(Data Access Object)：顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共APP中。用程序语言来说，就算建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。</p>
<h4 id="事务的ACID是指什么"><a href="#事务的ACID是指什么" class="headerlink" title="事务的ACID是指什么?"></a>事务的ACID是指什么?</h4><p>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败</p>
<p>一致性(Consistent)：事务结束前后的系统状态是一致的</p>
<p>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态</p>
<p>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p>
<p>脏读：A事务读取B事务尚未提交的数据，并在此基础上进行操作，而B执行回滚，那么A读到的数据就是脏数据。</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220230331958.png" class title="image-20211220230331958">

<p>不可重复读：当事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220231038292.png" class title="image-20211220231038292">

<p>幻读：事务A重新执行一个一个查询，返回一系列符合查询条件，发现其中被插入了被提交的事务B的行</p>
<p>第一类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220232443615.png" class title="image-20211220232443615">

<p>第二类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220232623469.png" class title="image-20211220232623469">



<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220233011476.png" class title="image-20211220233011476"> 

<p>事务隔离级别和数据访问的并发性是相对的，事务隔离级别越高并发性越差。所以要根据具体的应用来确定合适的事务。</p>
<h4 id="JDBC中如何进行事务处理"><a href="#JDBC中如何进行事务处理" class="headerlink" title="JDBC中如何进行事务处理"></a>JDBC中如何进行事务处理</h4><p>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显示提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC3.0还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p>
<h4 id="面向对象的“六原则一法则”"><a href="#面向对象的“六原则一法则”" class="headerlink" title="面向对象的“六原则一法则”"></a>面向对象的“六原则一法则”</h4><p>单一职责原则：一个类只做它该做的事情。</p>
<p>接口隔离原则：接口要小而专，绝不能大而全。一个接口只应该描述一种能力，接口也应该是高内聚的，比如琴棋书画应该分别设计为4个接口，而不应该设计成为一个接口中的四个方法，因为如果设计成一个接口四个方法，那么这个接口很难用，毕竟琴棋书画都精通的人还是少数，会导致实现该接口的类尽管只会一种也必须实现其它方法</p>
<p>依赖倒转原则：面向接口编程，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型替代</p>
<p>里氏替换原则：任何时候都可以使用子类型替换掉父类型</p>
<p>开闭原则：开闭原则是面向对象编程的最基础、最核心的原则。软件实体应该对提供方扩展开放，对使用者的修改关闭。即当想要增加新功能时，尽量增加新的代码，而不是修改原来的代码。</p>
<p>合成聚合复用原则：优先使用合成或聚合关系复用代码。</p>
<p>迪米特法则：又叫最少知识原则，一个对象应该对其它对象的了解尽可能的少。简单来说只与直接朋友打交道。</p>
<h4 id="简述一下你了解的设计模式"><a href="#简述一下你了解的设计模式" class="headerlink" title="简述一下你了解的设计模式"></a>简述一下你了解的设计模式</h4><p>设计模式：就是一套被反复使用的代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被其他人了解，保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。</p>
<p>工厂模式：工厂类可以根据条件不同生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同方法，但是这些方法针对不同的数据进行了不同的操作（多态方法），当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p>
<p>代理模式：给一个对象提供一个代理对象，并用代理对象控制原对象的引用。</p>
<p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起使用的类能够一起工作。</p>
<p>模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态方法），从而实现不同的业务逻辑</p>
<h4 id="用java写一个冒泡排序"><a href="#用java写一个冒泡排序" class="headerlink" title="用java写一个冒泡排序"></a>用java写一个冒泡排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comp 比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, Comparator&lt;T&gt; comp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">Sorter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BubbleSort bubbleSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        Integer[] arr=<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> swapped=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;arr.length&amp;&amp;swapped ; i++) &#123;</span><br><span class="line">            swapped=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                    swapped=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> swapped=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;arr.length&amp;&amp;swapped ; i++) &#123;</span><br><span class="line">            swapped=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(comp.compare(arr[j],arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                    swapped=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="阐述Servlet和CGI"><a href="#阐述Servlet和CGI" class="headerlink" title="阐述Servlet和CGI"></a>阐述Servlet和CGI</h4><p>Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都会创建一个新的进程，服务完成后就销毁，所以效率比servlet慢。</p>
<p>CGI因为性能开销上的问题被诟病，但Fast CGI已经解决了这一问题</p>
<p>FastCGI的工作流程</p>
<p>  1.Web服务器启动时载入FastCGI进程管理，如IIS的ISAPI、Apache的Module…</p>
<ol>
<li>FastCGI进程管理器自身初始化，并启动多个CGI解释器进程<code>php-cgi</code>并等待Web服务器的连接。</li>
<li>当客户端请求到达Web服务器时，FastCGI进程管理器选择并连接一个CGI解释器，Web服务器将CGI环境变量和标准输入发送到FastCGI子进程PHP-CGI。</li>
<li>FastCGI子进程完成处理后将标准输出和错误信息，从同一连接返回给Web服务器。当FastCGI子进程关闭连接时请求便处理完毕。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在Web服务器中）的下一个连接。在CGI模式中，PHP-CGI在此便退出了。</li>
</ol>
<h4 id="Servlet接口中有哪些方法"><a href="#Servlet接口中有哪些方法" class="headerlink" title="Servlet接口中有哪些方法"></a>Servlet接口中有哪些方法</h4><ul>
<li>void init(ServletConfig config) throws ServletException</li>
<li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</li>
<li>void destory()</li>
<li>java.lang.String getServletInfo()</li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p>Servlet的生命周期：</p>
<ul>
<li>Web容器加载Servlet并将其实例化，Servlet的生命周期开始</li>
<li>容器运行其init()方法进行Servlet的初始化</li>
<li>请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost方法</li>
<li>当服务器关闭或项目被卸载时服务器会将Servlet的实例销毁，此时会调用Servlet的destory()方法。</li>
</ul>
<h4 id="转发-forward-和重定向-redirect-的区别"><a href="#转发-forward-和重定向-redirect-的区别" class="headerlink" title="转发(forward)和重定向(redirect)的区别"></a>转发(forward)和重定向(redirect)的区别</h4><p>转发是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪儿来的，所以它的地址中还是原来的地址。重定向就是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此浏览器的地址栏可以看到重新请求的后的URL，重定向无法访问到服务器保护起来的资源，但是可以从一个网站redirect到另一个网站。转发更加高效，所以在满足需要时尽量使用forward(通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得)。在有些情况需要访问一个其他服务器上的资源，则必须使用重定向(通过HttpServletResponse对象调用其sendRedirect()方法实现)；</p>
<h4 id="JSP有哪些内置对象？作用分别是"><a href="#JSP有哪些内置对象？作用分别是" class="headerlink" title="JSP有哪些内置对象？作用分别是"></a>JSP有哪些内置对象？作用分别是</h4><p>JSP有9个内置对象</p>
<ul>
<li><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</p>
</li>
<li><p>response：封装服务器对客户端的响应；</p>
</li>
<li><p>pageContext：通过该对象可以获取其他对象；</p>
</li>
<li><p>session：封装用户会话的对象；</p>
</li>
<li><p>application：封装服务器运行环境的对象；</p>
</li>
<li><p>out：输出服务器响应的输出流对象；</p>
</li>
<li><p>config：Web应用的配置对象；</p>
</li>
<li><p>page：JSP页面本身（相当于Java程序中的this）；</p>
</li>
<li><p>exception：封装页面抛出异常的对象。</p>
</li>
</ul>
<h4 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h4><p>对象关系映射(Object-Relational Mapping)：是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用xml或注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转化为Java对象，其本质上就是将数据从一种形式转换到另一种形式。</p>
<h4 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</h4><p>持久：就是将数据保存到可掉电式存储设备中以便以后使用，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。</p>
<p>持久层：系统中专注于数据持久化的相对独立的层面</p>
<p>持久层设计的目标：</p>
<ul>
<li>数据存储逻辑分离，提供抽象化的数据访问接口</li>
<li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现</li>
<li>资源管理和调度的分离，在数据访问层实现统一的资源调度(如缓存机制)</li>
<li>数据抽象，提供面向对象的数据操作</li>
</ul>
<p>持久化框架：</p>
<ul>
<li><p>Hibernate</p>
</li>
<li><p>MyBatis</p>
</li>
<li><p>Spring Data</p>
</li>
</ul>
<h4 id="谈一下你对继承映射的理解"><a href="#谈一下你对继承映射的理解" class="headerlink" title="谈一下你对继承映射的理解"></a>谈一下你对继承映射的理解</h4><p>继承关系的映射策略有三种：</p>
<ul>
<li>每个继承结构一张表，不管多少个子类都用一张表</li>
<li>每个子类一张表，公共信息放一张表，特有信息放单独的表</li>
<li>每个具体类一张表，有多少个子类就有多少张表</li>
</ul>
<p>第一种数据单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</p>
<h4 id="MyBatis中使用-和-书写占位符的区别："><a href="#MyBatis中使用-和-书写占位符的区别：" class="headerlink" title="MyBatis中使用#和$书写占位符的区别："></a>MyBatis中使用#和$书写占位符的区别：</h4><p>#会将传入的数据都当成一个字符串，会对传入的数据自动加上引号(即会进行预编译)；$将传入的参数直接显示在SQL中。使用$会有SQL注入的问题不安全，所以能用#就不要用$，但是在写order by子句时应该使用$而不是#</p>
<h4 id="MyBatis中命名空间-namespace-的作用"><a href="#MyBatis中命名空间-namespace-的作用" class="headerlink" title="MyBatis中命名空间(namespace)的作用"></a>MyBatis中命名空间(namespace)的作用</h4><p>在项目中，可能存在大量的SQL语句，这时候对每一个SQL语句起一个唯一的标识(ID)并不容易。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p>
<h4 id="MyBatis中的动态SQL"><a href="#MyBatis中的动态SQL" class="headerlink" title="MyBatis中的动态SQL"></a>MyBatis中的动态SQL</h4><p>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，此时就需要根据指定的条件动态生成SQL，MyBatis提供了动态SQL的功能来解决这个问题</p>
<p>MyBatis中用于实现动态SQL的元素主要有：</p>
<ul>
<li>if</li>
<li>choose / when / otherwise</li>
<li>trim</li>
<li>where</li>
<li>set</li>
<li>foreach</li>
</ul>
<h4 id="什么是IOC和DI-DI是如何实现的"><a href="#什么是IOC和DI-DI是如何实现的" class="headerlink" title="什么是IOC和DI?DI是如何实现的"></a>什么是IOC和DI?DI是如何实现的</h4><p>IOC(Inversion of Controll)称为控制反转：把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓“控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。</p>
<p>DI(Dependency Injection)依赖注入：依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某种依赖关系注入到组件之中。</p>
<p>依赖注入可以通过接口注入、setter()方法注入和构造器注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要提供无参的构造器或无参的静态工厂方法来创建对象。</p>
<h4 id="Spring中Bean的作用域有哪些"><a href="#Spring中Bean的作用域有哪些" class="headerlink" title="Spring中Bean的作用域有哪些"></a>Spring中Bean的作用域有哪些</h4><p>在Spring早期版本中，仅有两个作用域：singleton和prototype，singleton表示Bean以单例的方式存在；prototype表示每次从容器中调用Bean时，都会返回一个新的实例对象。</p>
<p>Spring2.x针对WebApplicationContext新增了3个作用域，分别是request（每次HTTP请求都会创建一个新的Bean）、session(同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean)和globalSession(同一个全局session共享一个Bean).</p>
<p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对线程非安全的对象进行了处理。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>简介：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其它线程所对应的副本，从线程的角度看，这个变量就像是线程的本地变量。</p>
<p>ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法：</p>
<ul>
<li>void set(T value)：设置当前线程的线程局部变量的值。</li>
<li>T get()：获得当前线程所对应的线程局部变量的值。</li>
<li>void remove()：删除当前线程中线程局部变量的值。</li>
</ul>
<p>在ThreadLocal中有一个Map，键为对象，值是其线程对应的变量的副本，从而实现为每个线程保留一个独立的变量副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread,T&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        map.put(Thread.currentThread(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(Thread.currentThread()))&#123;</span><br><span class="line">            map.remove(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ThreadLocal类造成OOM</p>
<p>首先ThreadLocal里面的ThreadLocalMap类里面的Entry类是继承了弱引用类WeakReference，所以在ThreadLocalMap类里面的key值是使用弱引用方式来链接ThreadLocal的</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20220106180749739.png" class title="image-20220106180749739">

<p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没用外部强引用引用它，那么系统gc时，这个ThreadLocal将会被回收掉，导致ThreadLocal中就会出现key为null的Entry，就无法访问这些key为null的Entry的value.如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链Thread Ref  Thread  ThreadLocalMap Entry value，永远无法回收，造成内存泄漏。</p>
<h4 id="什么叫AOP-面向切面编程-？"><a href="#什么叫AOP-面向切面编程-？" class="headerlink" title="什么叫AOP(面向切面编程)？"></a>什么叫AOP(面向切面编程)？</h4><p>AOP(Aspect-Oriented Programming)指一种程序设计范型，该范型以一种称为切面(aspect)的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。</p>
<h4 id="如何理解横切关注"><a href="#如何理解横切关注" class="headerlink" title="如何理解横切关注"></a>如何理解横切关注</h4><p>“横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p>
<h4 id="如何理解AOP中的连接点-Joinpoint-、切点-Pointcut-、增强-Advice-、引介-Introduction-、织入-Weaving-、切面-Aspect-这些概念"><a href="#如何理解AOP中的连接点-Joinpoint-、切点-Pointcut-、增强-Advice-、引介-Introduction-、织入-Weaving-、切面-Aspect-这些概念" class="headerlink" title="如何理解AOP中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念"></a>如何理解AOP中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念</h4><p>连接点–joinpoint：程序执行的某个特定位置(如某个方法调用前、调用后，方法抛出异常后)。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</p>
<p>切点–pointcut：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring的AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</p>
<p>增强–Advice：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等，很多资料上也称为”通知“，但增强是对Advice较为准确的翻译，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。</p>
<p>引介–Introduction：引介是一种特殊的增强，它为类添加一些属性和方法。这样即使一个业务类原本没有实现某个接口，通过引介功能可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个类的实现类。</p>
<p>织入–Weaving：织入是将增加添加到目标类具体连接点上的过程，AOP有三种织入方式：</p>
<ul>
<li>编译期织入：需要特殊的Java编译期(例如AspectJ的ajc)</li>
<li>装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强</li>
<li>运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。</li>
</ul>
<p>切面–Aspect：切面是由切点和增强(引介)组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">        MyProxy&lt;String&gt; stringMyProxy = <span class="keyword">new</span> MyProxy&lt;&gt;(list);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; newList = (List&lt;String&gt;)Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), stringMyProxy);</span><br><span class="line"></span><br><span class="line">        newList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxy</span><span class="params">(List&lt;T&gt; target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res=<span class="keyword">null</span>;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot;:&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">        res=method.invoke(target,args);</span><br><span class="line">        System.out.println(target.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Spring中自动装配的方式有哪些"><a href="#Spring中自动装配的方式有哪些" class="headerlink" title="Spring中自动装配的方式有哪些"></a>Spring中自动装配的方式有哪些</h4><ul>
<li>no：不进行自动装配，手动设置Bean的依赖关系</li>
<li>byName：根据Bean的名字进行自动装配</li>
<li>byType：根据bean的类型进行自动装配</li>
<li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误</li>
<li>autodetect：如果有默认构造器，则通过constructor进行自动装配，否则使用byType的方式进行自动装配。</li>
</ul>
<h4 id="Spring中如何使用注解来配置Bean"><a href="#Spring中如何使用注解来配置Bean" class="headerlink" title="Spring中如何使用注解来配置Bean"></a>Spring中如何使用注解来配置Bean</h4><p>需要在Spring的配置文件中增加以下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式"><a href="#Spring支持的事务管理类型有哪些？你在项目中使用哪种方式" class="headerlink" title="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式"></a>Spring支持的事务管理类型有哪些？你在项目中使用哪种方式</h4><p>Spring支持编程式事务管理和声明式事务管理。许多Spring用户选择声明式事务管理，因为这种方式和应用程序的关联少，因此更加符合轻量级容器的概念。声明式事务管理优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p>
<p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持(如WebLogic、WildFly等)。局部事务和底层采用的JDBC有关，例如使用JDBC进行持久化时，需要使用Connection对象来操作事务。</p>
<h4 id="如何在Web项目中配置Spring的IOC容器"><a href="#如何在Web项目中配置Spring的IOC容器" class="headerlink" title="如何在Web项目中配置Spring的IOC容器"></a>如何在Web项目中配置Spring的IOC容器</h4><p>在Web项目配置文件web.xml中做出如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="如何在Web项目中配置SpringMVC"><a href="#如何在Web项目中配置SpringMVC" class="headerlink" title="如何在Web项目中配置SpringMVC"></a>如何在Web项目中配置SpringMVC</h4><p>要在Web项目中使用SpringMVC需要在web.xml中配置前端控制器DispatcherServlet</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用*.html的好处：</p>
<ul>
<li>使用这种后缀映射，使外界不能够通过URL推断采用了何种服务端的服务</li>
<li>可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。</li>
</ul>
<h4 id="Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理"></a>Spring MVC的工作原理</h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211224210540626.png" class title="image-20211224210540626">

<p>解释：</p>
<ul>
<li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求</li>
<li>HanlderMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找handler</li>
<li>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器。</li>
<li>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等</li>
<li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</li>
<li>Handler让具体的Controller执行</li>
<li>Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView</li>
<li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet</li>
<li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名</li>
<li>视图解析器将解析的逻辑视图名给DispatcherServlet</li>
<li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图</li>
<li>最终将视图呈现给用户</li>
</ul>
<h4 id="如何在Spring-IOC容器中配置数据源"><a href="#如何在Spring-IOC容器中配置数据源" class="headerlink" title="如何在Spring IOC容器中配置数据源"></a>如何在Spring IOC容器中配置数据源</h4><p>DBCP配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>C3P0配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="如何配置事务增强"><a href="#如何配置事务增强" class="headerlink" title="如何配置事务增强"></a>如何配置事务增强</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the transactional advice --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- all methods starting with &#x27;get&#x27; are read-only --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">    of an operation defined by the FooService interface --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceOperation&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.FooService.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceOperation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- don&#x27;t forget the DataSource --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scott&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tiger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- similarly, don&#x27;t forget the PlatformTransactionManager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- other &lt;bean&gt;&lt;/bean&gt; definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Spring框架为企业级开发带来的好处"><a href="#Spring框架为企业级开发带来的好处" class="headerlink" title="Spring框架为企业级开发带来的好处"></a>Spring框架为企业级开发带来的好处</h4><ul>
<li>非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类</li>
<li>IOC容器：IOC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件，而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IOC容器，程序员也不需要自己编写工厂、单例。</li>
<li>AOP（面向切面编程）：将所有的横切关注功能封装到切面(aspect)中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。</li>
<li>MVC：Spring的MVC框架是非常优秀的，为Web表示层提供了更好的解决方案。</li>
<li>事务管理：Spring支持多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。</li>
<li>其他：Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部。</li>
</ul>
<h4 id="Spring-IOC容器配置Bean的方式"><a href="#Spring-IOC容器配置Bean的方式" class="headerlink" title="Spring IOC容器配置Bean的方式"></a>Spring IOC容器配置Bean的方式</h4><ul>
<li>基于XML文件进行配置</li>
<li>基于注解进行配置</li>
<li>基于Java程序进行配置</li>
</ul>
<h4 id="阐述Spring中Bean的生命周期"><a href="#阐述Spring中Bean的生命周期" class="headerlink" title="阐述Spring中Bean的生命周期"></a>阐述Spring中Bean的生命周期</h4><ul>
<li>Spring IOC容器找到关于Bean的定义并实例化Bean</li>
<li>Spring IOC容器对Bean进行依赖注入</li>
<li>如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法</li>
<li>若Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法</li>
<li>若Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。</li>
<li>若Bean实现了InitializingBean接口，则调用其afterPropertySet方法</li>
<li>如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用</li>
<li>当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用destory方法</li>
</ul>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211225174110619.png" class title="image-20211225174110619">

<h4 id="依赖注入时如何注入集合属性"><a href="#依赖注入时如何注入集合属性" class="headerlink" title="依赖注入时如何注入集合属性"></a>依赖注入时如何注入集合属性</h4><p>可以在定义Bean属性时，通过&lt;list&gt;/&lt;set&gt;/&lt;map&gt;/&lt;props&gt;分别为其注入列表、集合、映射和键值都是字符串的映射属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactoryPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.spring.beanlife.entity.MyBeanFactoryPostProcessor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="Spring的自动装配有哪些限制"><a href="#Spring的自动装配有哪些限制" class="headerlink" title="Spring的自动装配有哪些限制"></a>Spring的自动装配有哪些限制</h4><ul>
<li>使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系</li>
<li>基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入</li>
<li>优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配</li>
</ul>
<h4 id="在Web项目中如何获得Spring的IOC容器"><a href="#在Web项目中如何获得Spring的IOC容器" class="headerlink" title="在Web项目中如何获得Spring的IOC容器"></a>在Web项目中如何获得Spring的IOC容器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext ctx = </span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br></pre></td></tr></table></figure>



<h4 id="大型网站在架构上应当考虑哪些问题"><a href="#大型网站在架构上应当考虑哪些问题" class="headerlink" title="大型网站在架构上应当考虑哪些问题"></a>大型网站在架构上应当考虑哪些问题</h4><p><strong>分层：</strong>分层是处理任何复杂系统最常见的手段，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型(OSI/RM)和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层(提供数据存储和访问服务)、业务层(处理业务逻辑，系统中最核心的部分)和表示层(系统交互、视图展示)。需要指出的是：分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；层与层之间应该有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</p>
<p>**分割:**分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开形成高内聚低耦合的功能模块(单元)。在设计初期可以做一个粗粒度的分割，将网站分割成若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</p>
<p><strong>分布式：</strong>网站的静态资源(JavaScript、CSS、图片等)也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</p>
<p><strong>集群：</strong>集群使得有更多的服务器提供相同的服务，可以更好的提供并发支持</p>
<p><strong>缓存：</strong>所谓缓存就是用空间换时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的应用。</p>
<p><strong>异步：</strong>异步是实现软件实体之间解耦的又一重要手段。异步架构是典型的生产者消费者模式，二者没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度，同时还可以起到削峰的作用(应对瞬时高并发)。能推迟处理的都要推迟处理，是网站优化的第二定律</p>
<p><strong>冗余：</strong>各种服务器都要提供相应的冗余服务器以便在某台或者某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。</p>
<h4 id="你使用过的网站前端优化的技术有哪些"><a href="#你使用过的网站前端优化的技术有哪些" class="headerlink" title="你使用过的网站前端优化的技术有哪些"></a>你使用过的网站前端优化的技术有哪些</h4><ul>
<li>浏览器优化<ul>
<li>减少HTTP请求数量：合并CSS、合并JavaScript、合并图片(CSS Sprite)</li>
<li>使用浏览器缓存：通过设置HTTP响应头中的Cache-Controll和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源</li>
<li>启用压缩</li>
<li>CSS前置，JavaScript后置</li>
<li>减少Cookie传输</li>
</ul>
</li>
<li>CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提高响应速度，还可以减少应用服务器的压力。CDN缓存的通常是静态资源</li>
<li>反向代理：反向代理相当于服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</li>
</ul>
<h4 id="应用服务器优化技术有哪些"><a href="#应用服务器优化技术有哪些" class="headerlink" title="应用服务器优化技术有哪些"></a>应用服务器优化技术有哪些</h4><ol>
<li>分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，若缓存中没有需要的数据，再去访问数据库或文件系统，并将得到的数据写入缓存。对网站数据的访问也符合二八定律(Pareto分布，幂律分布)，即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然使用缓存需要解决以下几个问题：<ul>
<li>频繁修改的数据不适合做缓存</li>
<li>数据不一致与脏读(缓存的更新问题)</li>
<li>缓存雪崩(可以采用分布式缓存服务器集群加以解决)</li>
<li>缓存击穿(某个热点缓存失效)</li>
<li>缓存穿透（恶意请求不存在的数据）</li>
</ul>
</li>
<li>异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰的作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列。这样可以抵御大量的并发订单请求对系统的和数据库的冲击。目前绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。</li>
<li>使用集群</li>
<li>代码优化<ul>
<li>多线程</li>
<li>非阻塞I/O：使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式。</li>
<li>资源复用：资源复用主要有两种方式，一是单例，二是对象池</li>
</ul>
</li>
</ol>
<h4 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击</h4><p>XSS（Cross Site Script,跨站脚本攻击）：是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分为两种形式：反射性攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL）和持久性攻击（将恶意脚本提交到被攻击的网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行）。防范XSS主要有两方面：对危险字符进行转义和HttpOnly（防范XSS攻击者窃取Cookie数据）</p>
<p>CSRF攻击(Cross Site Request Forgery，跨站请求伪造)：是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份。防范CSRF的主要手段是识别请求者的身份</p>
<img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211226161400108.png" class title="image-20211226161400108"></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Laity&amp;</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://polaris-ux.github.io/2021/11/27/Java基础复习/">https://polaris-ux.github.io/2021/11/27/Java基础复习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/"><i class="fa fa-chevron-left">  </i><span>JVM学习</span></a></div><div class="next-post pull-right"><a href="/2021/11/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"><span>二叉搜索树转循环链表</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://polaris-ux.github.io/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/';
  this.page.identifier = '2021/11/27/Java基础复习/';
  this.page.title = 'Java基础复习';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'polaris-4' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://polaris-4.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://th.bing.com/th/id/R.db1eab53ff269e5709d90f8b197fafb7?rik=zABgriNA09F1vA&amp;riu=http%3a%2f%2fwww.shijuepi.com%2fuploads%2fallimg%2f201128%2f1-20112QP934.jpg&amp;ehk=Lr%2f%2fq1LA75MkgirCJbR87lb7M%2bZJlTMtjvLaj6Bg0lE%3d&amp;risl=&amp;pid=ImgRaw)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By Laity&</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>