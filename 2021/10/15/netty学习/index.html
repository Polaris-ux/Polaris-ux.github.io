<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="netty学习"><meta name="keywords" content=""><meta name="author" content="Laity&amp;"><meta name="copyright" content="Laity&amp;"><title>netty学习 | Laity的日常博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><meta name="generator" content="Hexo 5.4.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Netty%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Netty学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">IO模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-BIO"><span class="toc-number">1.0.1.</span> <span class="toc-text">Java BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-BIO%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">Java BIO基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-BIO%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">Java BIO工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">BIO实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-BIO%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">Java BIO问题分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO"><span class="toc-number">1.0.2.</span> <span class="toc-text">Java NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">Java NIO的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO-Buffer%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">NIO Buffer的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">Buffer的简单操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E4%B8%8EBIO%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">NIO与BIO的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E3%80%81Buffer%E3%80%81Selector%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">Channel、Buffer、Selector之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.0.2.6.</span> <span class="toc-text">Buffer:缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%EF%BC%9A%E9%80%9A%E9%81%93"><span class="toc-number">1.0.2.7.</span> <span class="toc-text">Channel：通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%EF%BC%9A%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.0.2.8.</span> <span class="toc-text">Selector：选择器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8FDemo"><span class="toc-number">1.0.2.9.</span> <span class="toc-text">小Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E4%B8%8E%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.2.10.</span> <span class="toc-text">NIO与零拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FNIO%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.2.11.</span> <span class="toc-text">原生NIO存在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-AIO"><span class="toc-number">1.0.3.</span> <span class="toc-text">Java AIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-number">1.1.</span> <span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">线程模型基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">单Reactor单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">单Reactor多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">主从Reactor多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty%E8%AF%A6%E7%BB%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">Netty详细模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskQueue"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">TaskQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.0.7.</span> <span class="toc-text">异步模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B-HTTP%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.0.8.</span> <span class="toc-text">快速入门示例-HTTP服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bootstrap%E3%80%81ServerBootstrap"><span class="toc-number">1.1.0.9.</span> <span class="toc-text">Bootstrap、ServerBootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline%E5%92%8CChannelPipeline"><span class="toc-number">1.1.0.10.</span> <span class="toc-text">Pipeline和ChannelPipeline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelHandlerContext"><span class="toc-number">1.1.0.11.</span> <span class="toc-text">ChannelHandlerContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ChannelOption"><span class="toc-number">1.1.0.12.</span> <span class="toc-text">ChannelOption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unpooled%E7%B1%BB"><span class="toc-number">1.1.0.13.</span> <span class="toc-text">Unpooled类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netty%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">1.1.0.14.</span> <span class="toc-text">netty实现多人聊天室</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.0.15.</span> <span class="toc-text">心跳检测机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-number">1.1.0.16.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netty%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.0.17.</span> <span class="toc-text">netty编码和解码的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#netty%E7%9A%84%E5%85%A5%E7%AB%99%E5%92%8C%E5%87%BA%E7%AB%99"><span class="toc-number">1.1.0.18.</span> <span class="toc-text">netty的入站和出站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Log4j%E6%95%B4%E5%90%88%E5%88%B0Netty"><span class="toc-number">1.1.0.19.</span> <span class="toc-text">Log4j整合到Netty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.0.20.</span> <span class="toc-text">TCP粘包和拆包的基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.0.21.</span> <span class="toc-text">协议设计与解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">Netty核心源码</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://th.bing.com/th/id/R.ddf36bf62e6f5fff5bf8c74284c0983a?rik=gL1kHAzol0ZsCg&amp;riu=http%3a%2f%2fimg.jj20.com%2fup%2fallimg%2ftx26%2f420812170231383.jpg&amp;ehk=dftFXuBhZYOq24%2foZJxW6BcDBdLJRArAKByCS%2f7z1KQ%3d&amp;risl=&amp;pid=ImgRaw"></div><div class="author-info__name text-center">Laity&amp;</div><div class="author-info__description text-center">出发，永远是最有意义的事，去做就是了</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">46</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">35</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://th.bing.com/th/id/R.db1eab53ff269e5709d90f8b197fafb7?rik=zABgriNA09F1vA&amp;riu=http%3a%2f%2fwww.shijuepi.com%2fuploads%2fallimg%2f201128%2f1-20112QP934.jpg&amp;ehk=Lr%2f%2fq1LA75MkgirCJbR87lb7M%2bZJlTMtjvLaj6Bg0lE%3d&amp;risl=&amp;pid=ImgRaw)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Laity的日常博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">netty学习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-10-15</time><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2021/10/15/netty学习/"></span></a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Netty学习"><a href="#Netty学习" class="headerlink" title="Netty学习"></a>Netty学习</h1><p><strong>Netty的介绍</strong>：</p>
<p>Netty是由JBoss提供的一个Java开源框架，现为Github上的独立项目</p>
<p>Netty是一个<strong>异步的、基于事件驱动的网络</strong>应用框架，用以快速开发高性能、高可靠性的网络IO程序</p>
<p>Netty主要针对在TCP协议下，面向Clients端的高并发应用或者Peer-to-Peer场景下的大量数据持续传输的应用</p>
<p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015152755908.png" class title="image-20211015152755908">



<p><strong>Netty的应用场景</strong></p>
<p>互联网行业：</p>
<p>在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。</p>
<p>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p>I/O模型的简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p>
<p>Java共支持三种网络编程模型：BIO、NIO、AIO</p>
<p><strong>Java BIO：</strong>同步并阻塞（传统阻塞型），服务器实现模式为一个连接为一个线程，及客户端有连接请求时服务器端就需要启动一个线程进行处理，若连接过多且大多线程不进行操作，会造成大量的不必要的开销</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015155749046.png" class title="image-20211015155749046">

<p>**Java NIO:**同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接发送的连接请求都会注册到多路复用器上，多路复用器轮询到有I/O请求就进行处理。</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015164215493.png" class title="image-20211015164215493">

<p><strong>Java AIO(NIO.2)：</strong>异步非阻塞，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的的应用。</p>
<p><strong>BIO、NIO、AIO适用场景分析</strong></p>
<ul>
<li>BIO方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序比较简单易懂</li>
<li>NIO方式适合<strong>连接数目多且连接比较短的架构</strong>，比如聊天服务器，弹幕系统，服务器间通讯等，编程比较复杂，JDK1.4开始支持</li>
<li>AIO方式适用于<strong>连接数目多且连接比较长（重操作）</strong>的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h3 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h3><h4 id="Java-BIO基本介绍"><a href="#Java-BIO基本介绍" class="headerlink" title="Java BIO基本介绍"></a>Java BIO基本介绍</h4><p>Java BIO就是传统的java.io编程，其相关的类和接口在java.io中</p>
<h4 id="Java-BIO工作机制"><a href="#Java-BIO工作机制" class="headerlink" title="Java BIO工作机制"></a>Java BIO工作机制</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015171510323.png" class title="image-20211015171510323">



<h4 id="BIO实例"><a href="#BIO实例" class="headerlink" title="BIO实例"></a>BIO实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-15 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个线程池</span></span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                Socket accept = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个线程，与客户端进行通信</span></span><br><span class="line">                executorService.execute(()-&gt;&#123;</span><br><span class="line">                    receiveMsg(accept);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            StringBuilder sbl=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span>((len=is.read(arr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                String s = <span class="keyword">new</span> String(arr, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                sbl.append(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用telnet进行发送消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet ip port+ctrl+]</span><br></pre></td></tr></table></figure>



<h4 id="Java-BIO问题分析"><a href="#Java-BIO问题分析" class="headerlink" title="Java BIO问题分析"></a>Java BIO问题分析</h4><ul>
<li>每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据write</li>
<li>当并发数较大时，需要<strong>创建大量线程来处理连接，</strong>系统资源占用较大</li>
<li>连接建立后，如果当前线程没有数据可读，则线程就阻塞在Read操作上，造成线程资源浪费</li>
</ul>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><h4 id="Java-NIO的基本介绍"><a href="#Java-NIO的基本介绍" class="headerlink" title="Java NIO的基本介绍"></a>Java NIO的基本介绍</h4><p>Java NIO全称 java non-blocking IO，是指JDK提供的新API。从JDK1.4开始，Java提供了一系列改进的输入/输出的新特性，被统称为NIO，是同步非阻塞的。</p>
<p>NIO相关类都被放在java.nio包及子包下，并且对原Java.io包中的很多类进行改写</p>
<p>NIO有三大核心部分：Channel(通道)，Buffer(缓冲区)、Selector（选择器）</p>
<p>NIO是面向缓冲区、面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p>
<h4 id="NIO-Buffer的使用"><a href="#NIO-Buffer的使用" class="headerlink" title="NIO Buffer的使用"></a>NIO Buffer的使用</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016112835315.png" class title="image-20211016112835315">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016113403199.png" class title="image-20211016113403199">



<h4 id="Buffer的简单操作"><a href="#Buffer的简单操作" class="headerlink" title="Buffer的简单操作"></a>Buffer的简单操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Buffer,容量为5</span></span><br><span class="line">        IntBuffer intBuffer=IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Buffer中存放数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Buffer转换，读写切换</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="NIO与BIO的比较"><a href="#NIO与BIO的比较" class="headerlink" title="NIO与BIO的比较"></a>NIO与BIO的比较</h4><p>BIO是以流的方式进行处理的，NIO是以块的方式进行处理数据，块I/O效率比流I/O方式快很多。</p>
<p>BIO是阻塞的，NIO是非阻塞的</p>
<p>BIO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，selector(选择器)用于监听多个通道的时间，使单个线程能够监听多个客户端通道。</p>
<h4 id="Channel、Buffer、Selector之间的关系"><a href="#Channel、Buffer、Selector之间的关系" class="headerlink" title="Channel、Buffer、Selector之间的关系"></a>Channel、Buffer、Selector之间的关系</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016114804608.png" class title="image-20211016114804608">

<ul>
<li>每个Channel都会对应一个Buffer</li>
<li>Selector对应一个线程，一个Selector可以对应多个Channel</li>
<li>Selector选择处理哪个Channel是由事件决定的，Even就是一个重要的概念。</li>
<li>Selector会根据不同的事件，在各个通道上切换</li>
<li>数据的读取写入是通过Buffer,BIO中要么是输入流，要么是输出流，不能双向，但是NIO的Buffer是可以读也可以写的，但是需要flip方法切换</li>
<li>Channel是双向的，可以返回底层操作系统的情况，比如Linux,底层的操作系统通道就是双向的</li>
</ul>
<h4 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer:缓冲区"></a>Buffer:缓冲区</h4><p>概念：本质上是一个可以读写数据的内存块，可以理解为一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够追踪和记录缓冲区的状态变化情况。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。</p>
<p><strong>api:</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016122029263.png" class title="image-20211016122029263">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016122204266.png" class title="image-20211016122204266">





<h4 id="Channel：通道"><a href="#Channel：通道" class="headerlink" title="Channel：通道"></a>Channel：通道</h4><p><strong>基本介绍：</strong></p>
<p>通道可以同时进行读写，而流只能读或者只能写</p>
<p>通道可以实现异步读写数据</p>
<p>通道可以从缓冲中读数据，也可以写数据到缓冲中</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016154019924.png" class title="image-20211016154019924">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016154339505.png" class title="image-20211016154339505">



<p><strong>案例一：</strong></p>
<p>将文字写入到buffer中，再从buffer中读取内容写入到Chanel中，最后将内容写入文件中</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016160655390.png" class title="image-20211016160655390">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 15:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个文件输出流</span></span><br><span class="line">            fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取FileChannel</span></span><br><span class="line">            FileChannel channel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个buffer</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将文字内容写入buffer中</span></span><br><span class="line">            byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换为读</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            channel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>案例二：</strong></p>
<p>通过buffer读取文件的内容，并打印到控制台上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FileChannel channel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向缓冲区中写入数据</span></span><br><span class="line">            channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从缓冲区中获取byte[]</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(byteBuffer.array(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>案例三：</strong></p>
<p>使用一个buffer实现文件的拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 文件输出流</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取读取的channel</span></span><br><span class="line">            FileChannel inputChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取写的channel</span></span><br><span class="line">            FileChannel outputChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重要的操作：清空buffer</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回一个值</span></span><br><span class="line">                <span class="keyword">int</span> read=inputChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                outputChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>案例四：</strong></p>
<p>使用FileChannel的transForm方法拷贝文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 利用fileChannel的transform方法拷贝文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel sourceChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel destChannel=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 文件输出流</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取读取的channel</span></span><br><span class="line">            sourceChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取写的channel</span></span><br><span class="line">            destChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            destChannel.transferFrom(sourceChannel,<span class="number">0</span>,sourceChannel.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(destChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    destChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sourceChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sourceChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>关于Buffer和Channel的注意事项和细节</p>
<p>Buffer支持类型的put和get,put放入的是数目数据类型，get就应该使用相应的数据类型来取出，否则可能会报<strong>BufferUnderflowException</strong></p>
<p>可以将一个普通Buffer转换为只读Buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferReadOnly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        IntBuffer allocate = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            allocate.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        allocate.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个只读buffer</span></span><br><span class="line">        IntBuffer rBuffer = allocate.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(rBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rBuffer.put(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>NIO还提供了MapperdByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由NIO完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> MappedByteBuffer可让文件直接在内存（堆外内存修改），操作系统不用再拷贝一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应的Channel</span></span><br><span class="line">            FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第一个参数：FileChannel.MapMode.READ_WRITE：读写模式</span></span><br><span class="line"><span class="comment">             * 第二个参数：起始位置</span></span><br><span class="line"><span class="comment">             * 第三个参数：可修改的byte大小（不能取5）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            map.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">            map.put(<span class="number">4</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            randomAccessFile.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>NIO支持通过多个Buffer完成读写操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel=<span class="keyword">null</span>;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用ServerSocketChannel和SocketChannel</span></span><br><span class="line">            serverChannel = ServerSocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口到socket并启动</span></span><br><span class="line">            serverChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建buffer数组</span></span><br><span class="line">            ByteBuffer[] buffers=<span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">            buffers[<span class="number">0</span>]=ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            buffers[<span class="number">1</span>]=ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待客户端连接</span></span><br><span class="line">            socketChannel = serverChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> messageLength=<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> byteRead=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(byteRead&lt;messageLength)&#123;</span><br><span class="line">                    <span class="keyword">long</span> read = socketChannel.read(buffers);</span><br><span class="line">                    byteRead+=read;</span><br><span class="line">                    Arrays.asList(buffers).stream().map(buffer-&gt;<span class="string">&quot;position:&quot;</span>+buffer.position()+<span class="string">&quot;,limit：&quot;</span>+buffer.limit())</span><br><span class="line">                            .forEach(System.out::println);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将所有的buffer,进行flip()</span></span><br><span class="line">                Arrays.asList(buffers).forEach(buffer-&gt;buffer.flip());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将数据读出</span></span><br><span class="line">                <span class="keyword">int</span> byteWrite=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(byteWrite&lt;messageLength)&#123;</span><br><span class="line">                    <span class="keyword">long</span> write = socketChannel.write(buffers);</span><br><span class="line">                    byteWrite+=write;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将所有的buffer进行clear</span></span><br><span class="line">                Arrays.asList(buffers).forEach(buffer-&gt;buffer.clear());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;byteWrite=&quot;</span>+byteWrite+<span class="string">&quot;,byteRead=&quot;</span>+byteRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(serverChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Selector：选择器"><a href="#Selector：选择器" class="headerlink" title="Selector：选择器"></a>Selector：选择器</h4><p><strong>基本介绍</strong></p>
<p>Java的NIO采用的是同步非阻塞的方式，可以用一个线程，处理多个客户端连接，就会使用到Selector(选择器)</p>
<p>Selector能够检测多个注册通道上是否有事件发生（注意：多个Channel以事件的方式可以注册到同一个Selector）,如果有事件发生，便获取事件然后针对每个事件进行响应的处理。这样就可以只用一个线程管理多个通道，也就是管理多个连接和请求。</p>
<p>只有在连接/通道真正有读写事件发生时，才会进行读写，这样就大大地减少了系统开销，并且不必为每个连接都创建一个线程。</p>
<p>避免多线程之间切换的开销</p>
<p><strong>Selector的方法</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017160455022.png" class title="image-20211017160455022">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017162622361.png" class title="image-20211017162622361">

<p>对上面流程图的说明：</p>
<ul>
<li>当客户端连接时，会通过ServerSocketChannel获取到SocketChannel</li>
<li>然后将该SocketChannel注册到Selector中register(Selector sel, int ops)，一个selector可以注册多个Channel</li>
<li>注册之后会返回一个SelectionKey，会和该Selector关联起来</li>
<li>Selector进行监听,使用select方法，返回有事件发生的通道个数</li>
<li>进一步得到各个SelectionKey(有事件发生)</li>
<li>通过selectionKey获取到对应的Channel</li>
<li>通过得到的Channel完成业务处理</li>
</ul>
<p><strong>示例：</strong></p>
<p>实现服务器端和客户端之间的数据简单通信（非阻塞）</p>
<p>NIOClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-17 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">            <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">                <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接需要时间，客户端不会堵塞，可以做其它工作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String str=<span class="string">&quot;hello,摸鱼King&quot;</span>;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            System.in.read();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIOServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-17 16:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个serverSocketChannel</span></span><br><span class="line">            serverSocketChannel =ServerSocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将serverSocketChannel设置为非阻塞的</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将serverSocketChannel在selector中注册</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待1秒，若没有需要处理的事件就继续</span></span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待1秒，未连接&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取需要处理的事件的selectionKeys</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">// 获取selectionKeys</span></span><br><span class="line">                    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                    System.out.println(serverSocketChannel.hashCode());</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">// 获取Channel</span></span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端连接成功，socketChannel=&quot;</span>+socketChannel.hashCode());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 设置为非阻塞</span></span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将socketChannel注册到selector，关注事件为OP_READ,同时给socketChannel关联一个buffer</span></span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">// 通过key获取socketChannel</span></span><br><span class="line">                        SocketChannel  channel = (SocketChannel)key.channel();</span><br><span class="line">                        <span class="comment">// 获取到该channel关联的buffer</span></span><br><span class="line">                        ByteBuffer buffer=(ByteBuffer)key.attachment();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        channel.read(buffer);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;from 客户端：&quot;</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 手动从集合中移除当前的selectionKey，防止重复操作</span></span><br><span class="line">                    keyIterator.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>SelectionKey</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224144733.png" class title="image-20211017224144733">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224251357.png" class title="image-20211017224251357">



<p><strong>ServerSocketChannel</strong></p>
<p>ServerSocketChannel在服务器端监听新的客户端socket连接</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224444616.png" class title="image-20211017224444616">



<p><strong>SocketChannel</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224728037.png" class title="image-20211017224728037">



<h4 id="小Demo"><a href="#小Demo" class="headerlink" title="小Demo"></a>小Demo</h4><p>实现一个非阻塞的多人聊天室</p>
<p>server端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_ADDRESS=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT=<span class="number">9000</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel=SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST_ADDRESS,PORT));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建selector</span></span><br><span class="line">            selector=Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册到selector中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 得到username</span></span><br><span class="line">            username=socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg=username+<span class="string">&quot;:&quot;</span>+msg;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 得到相关的通道</span></span><br><span class="line">                            SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="comment">// 将数据写入buffer</span></span><br><span class="line">                            sc.read(buffer);</span><br><span class="line">                            <span class="comment">// 读模式</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            chatClient.receiveMsg();</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">            String msg = scan.next();</span><br><span class="line">            chatClient.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_ADDRESS=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT=<span class="number">9000</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel=SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST_ADDRESS,PORT));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建selector</span></span><br><span class="line">            selector=Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册到selector中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 得到username</span></span><br><span class="line">            username=socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg=username+<span class="string">&quot;:&quot;</span>+msg;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 得到相关的通道</span></span><br><span class="line">                            SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="comment">// 将数据写入buffer</span></span><br><span class="line">                            sc.read(buffer);</span><br><span class="line">                            <span class="comment">// 读模式</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            chatClient.receiveMsg();</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">            String msg = scan.next();</span><br><span class="line">            chatClient.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h4><p><strong>零拷贝基本介绍：</strong></p>
<p>零拷贝（指没有CPU拷贝，DMA拷贝无法避免）是网络编程的关键，很多性能优化都离不开</p>
<p>在Java中常用的零拷贝有mmap(内存映射)和sendFile.</p>
<p><strong>mmap优化</strong></p>
<p>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211018120743818.png" class title="image-20211018120743818">

<p><strong>sendFile优化</strong></p>
<p>Linux2.1版本提供了sendFile函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211018121023667.png" class title="image-20211018121023667">

<p>linux在2.4版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer的操作，直接拷贝到协议栈，从而再减少一次数据拷贝。</p>
<p>但并不是真正意义上的零拷贝，因为其实从内核缓冲区拷贝到Socket buffer的cpu拷贝仍然存在，只是拷贝的信息很少，可以忽略。</p>
<p><strong>mmap和sendFile的区别</strong></p>
<ul>
<li>mmap适合小数据量读写，sendFile适合大文件传输</li>
<li>mmap需要4次上下文，3次数据拷贝；sendFile需要三次上下文，至少两次数据拷贝。</li>
<li>sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能</li>
</ul>
<p><strong>NIO与零拷贝案例</strong></p>
<p>上传一个文件</p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取socketChannel</span></span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\main\\java\\com\\mjy\\file\\a.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取fileChannel</span></span><br><span class="line">            channel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接到serverSocketChannel</span></span><br><span class="line">            <span class="keyword">if</span>(socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">                <span class="keyword">long</span> size = channel.size();</span><br><span class="line">                <span class="keyword">double</span> num = Math.ceil((<span class="keyword">double</span>)size / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">long</span> start=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                    <span class="comment">// 在linux下一个transferTo方法就可以完成传输</span></span><br><span class="line">                    <span class="comment">// 在windows下 一次调用transferTo只能发送8M,就需要分段传输文件，需要注意文件传输的起始位置</span></span><br><span class="line">                    <span class="comment">// transferTo 底层使用零拷贝</span></span><br><span class="line">                    <span class="keyword">long</span> readCount = channel.transferTo(start, <span class="number">1024</span> * <span class="number">1024</span>, socketChannel);</span><br><span class="line">                    total+=readCount;</span><br><span class="line">                    start=total;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">&quot;上传字节数：&quot;</span>+total+<span class="string">&quot;,耗时：&quot;</span>+(end-begin)+<span class="string">&quot;,文件总大小：&quot;</span>+size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel serverSocketChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel=<span class="keyword">null</span>;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\main\\java\\com\\mjy\\file\\video.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">            channel = fos.getChannel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">            <span class="keyword">int</span> read=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>((read=socketChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    total=total+read;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(total);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(serverSocketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="原生NIO存在的问题"><a href="#原生NIO存在的问题" class="headerlink" title="原生NIO存在的问题"></a>原生NIO存在的问题</h4><ul>
<li>NIO的类库和API繁杂，使用比较麻烦</li>
<li>需要具备其它的额外技能：要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉。</li>
<li>开发工作量和难度都比较大</li>
<li>JDK NIO存在一些Bug，例如：Epoll Bug，它会导致Selector空轮询，最终导致CPU100%。直到JDK1.7版本该问题仍然存在。</li>
</ul>
<h3 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h3><p><strong>基本介绍</strong></p>
<p>JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程中，常用到两种模式，Reactor和Proactor。Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。</p>
<p>AIO即NIO2.0，叫做异步不阻塞的I/O.AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠的网络I/O程序</p>
<h4 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h4><p><strong>现存的线程模型：</strong></p>
<ul>
<li>传统阻塞I/O服务模型</li>
<li>Reactor模式<ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
</li>
<li>Netty线程模式（Netty主要基于主从Reactor对线程模型做了一定的改进，其中主从多线程模型有多个Reactor</li>
</ul>
<p><strong>Reactor模式</strong></p>
<p>又称为：反应器模式、分发者模式、通知者模式</p>
<p><strong>针对传统阻塞I/O服务模型的缺点，解决方案：</strong></p>
<p>基于I/O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无须阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p>
<p>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</p>
<p><strong>架构图</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019164310180.png" class title="image-20211019164310180">

<p><strong>说明：</strong></p>
<ul>
<li>Reactor模式，通过一个或多个输入同时传递给服务器处理器的模式（基于事件驱动）</li>
<li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此也称为Dispatcher模式</li>
<li>Reactor模式使用IO复用监听事件，收到事件后，分发给各个线程（进程）</li>
</ul>
<h4 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a><strong>单Reactor单线程</strong></h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019165718634.png" class title="image-20211019165718634">

<p>优点：</p>
<ul>
<li>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能问题，只有一个线程，无法完全发挥多核CPU的性能。Handler在处理某个连接上的业务时，整个进程无法处理其它连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题，线程意外终止，或者进入死循环，会导致整个通信模块不可用，不能接收和处理外部消息，造成节点故障。</li>
</ul>
<p><strong>使用场景：</strong>客户端的数量有限，业务处理非常快速。</p>
<h4 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019171713292.png" class title="image-20211019171713292">



<p><strong>说明：</strong></p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件之后，通过dispatcher进行分发</li>
<li>若是建立连接请求，则Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由Reactor分发到对应的handler进行处理</li>
<li>handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的woker线程池的某个线程处理业务</li>
<li>woker线程池会分配独立线程完成真正的业务，并将结果返回给handler</li>
<li>handler收到响应后，通过send将结果返回给client </li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以充分利用多核cpu的处理能力</li>
</ul>
<p><strong>缺点：</strong></p>
<p>多线程数据共享和访问比较复杂，reactor处理所有事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</p>
<h4 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019174355071.png" class title="image-20211019174355071">

<p><strong>说明：</strong></p>
<ul>
<li>Reactorz主线程MainReactor对象通过selector监听连接事件，收到事件后，通过Acceptor处理连接事件</li>
<li>当Acceptor处理连接事件后，MainReactor会将连接分发给subReactor</li>
<li>subReactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li>
<li>当有新事件发生时，subReactor就会调用对应的handler进行处理</li>
<li>handler通过read读取数据，分发给后面的woker线程池的某个线程进行业务处理</li>
<li>woker线程池的某个线程处理完毕后，将结果返回给handler</li>
<li>handler收到响应的结果后，再通过send将结果返回给client</li>
<li>Reactor主线程可以对应多个subReactor</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>Reactor主线程只需要把新连接传给子线程，之后就不会再有数据交互</li>
</ul>
<p><strong>缺点：</strong></p>
<p>编程复杂度较高</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019180929888.png" class title="image-20211019180929888">



<h4 id="Netty详细模型"><a href="#Netty详细模型" class="headerlink" title="Netty详细模型"></a>Netty详细模型</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211021141306537.png" class title="image-20211021141306537">



<p><strong>简单示例-TCP服务</strong>：</p>
<p>导入依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.1</span><span class="number">.63</span>.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 添加自定义的handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端准备好了.....&quot;</span>);</span><br><span class="line">            <span class="comment">// 启动客户端</span></span><br><span class="line">            ChannelFuture connect = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭通道事件</span></span><br><span class="line">            connect.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NettyClientHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 15:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 客户端handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法,向服务端发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client ctx：&quot;</span>+ctx);</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,服务端&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时读取服务端发送的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf=(ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">// 创建两个线程组bossGroup和workerGroup</span></span><br><span class="line">        <span class="comment">// bossGroup负责处理连接请求，workerGroup处理客户端的业务请求</span></span><br><span class="line">        <span class="comment">// bossGroup下的NioEventLoop的数量默认为电脑核数*2，可以自己设定</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的启动对象,配置参数</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 设置NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端准备好了.....&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">// 启动服务器并绑定端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>NettyServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义handler 需要继承netty规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ：上下文对象，含有管道pipline,通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg：就是客户端发送的数据，默认为Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx：&quot;</span>+ctx);</span><br><span class="line">        <span class="comment">// 将msg转换成一个ByteBuf</span></span><br><span class="line">        <span class="comment">// ByteBuf是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        ByteBuf buf=(ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息是：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端的地址为：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将数据写入到缓存，并刷新（刷新到管道中）</span></span><br><span class="line">        <span class="comment">// 一般需要对发送的消息进行编码</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端！&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="TaskQueue"><a href="#TaskQueue" class="headerlink" title="TaskQueue"></a>TaskQueue</h4><p><strong>任务队列中的Task有三种典型使用场景</strong></p>
<ul>
<li><p>用户程序自定义的普通任务</p>
<p>示例：</p>
<p>NettyServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若我们有一个非常耗时的业务，就需要异步执行，将该操作提交到该Channel对应的NioEventLoop的TaskQueue中去</span></span><br><span class="line">        <span class="comment">// 若不异步执行，会发生阻塞</span></span><br><span class="line">        <span class="comment">// 解决办法1：用户自定义的普通任务</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;异步处理的业务&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>注：当需要处理异步任务时，可以将需要处理的任务放到Channel中的eventLoop中的TaskQueue中，可以添加多个异步任务，但因为使用的是同一个线程添加异步任务，所以执行的异步任务在TaskQueue中执行是同步的。</p>
</li>
<li><p>用户自定义的定时任务</p>
<p>示例：</p>
<p>NettyServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户自定义定时服务</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;异步处理的业务1&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li>
<li><p>非当前Reactor线程调用Channel的各种方法</p>
<p>例如：在推送系统的业务线程里面，根据用户的标识找到对应的Channel引用，然后调用Write类方法向该用户推送消息，就会进入到这种场景。最终的Write会提交到任务队列终被异步消费</p>
<p>示例：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 设置NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 可以使用一个集合管理SocketChannel,再推送消息的时，将推送业务加入到channel的eventLoop中的taskQueue或ScheduledTaskQueue</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022181516402.png" class title="image-20211022181516402">

<h4 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h4><p><strong>基本介绍</strong></p>
<p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>Netty中的I/O操作是异步的，包括Bind、write、connect等操作会简单的返回一个ChannelFuture</p>
<p>调用者并不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果</p>
<p>Netty的异步模型是建立在future和callback的之上的。callback就是回调。重点说Future，它的核心思想：假设一个方法fun,计算过程可能很耗时，等待fun返回结果显然不合适。那么可以在调用fun的时候，立马返回一个future，或许可以通过Future去监控方法fun的处理过程</p>
<p><strong>Future说明</strong></p>
<ul>
<li>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成，比如检索计算等</li>
<li>ChannelFuture是一个接口，我们可以添加监听器，当监听的事件发生时，就会通知到监听器</li>
</ul>
<p><strong>Future-Listener机制</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022232452807.png" class title="image-20211022232452807">



<p>例子：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">           <span class="comment">// 启动服务器并绑定端口</span></span><br><span class="line">           ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 添加监听器</span></span><br><span class="line">           channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(channelFuture.isSuccess())&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务器绑定 6668成功&quot;</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务器绑定 6668失败&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>

<p>异步好处：</p>
<p>相比传统阻塞I/O,执行I/O操作后线程会被阻塞，直到操作完成；异步处理的好处是不会造成阻塞，线程在I/O操作期间可以执行别的程序，在高并发清醒下会更稳定和更高的吞吐量。</p>
<h4 id="快速入门示例-HTTP服务"><a href="#快速入门示例-HTTP服务" class="headerlink" title="快速入门示例-HTTP服务"></a>快速入门示例-HTTP服务</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022233711808.png" class title="image-20211022233711808">

<p>客户端：浏览器，不用写</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-22 23:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup=<span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 配置启动类对象</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestHttpServerInitializer());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            ChannelFuture cf = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>handler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-22 23:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SimpleChannelInboundHandler是ChannelInboundHandler的子类</span></span><br><span class="line"><span class="comment">// HttpObject:客户端与服务端通信的数据被封装为HttpObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断msg是否是HttpRequest</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型：&quot;</span>+msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器会接收到两次请求，需要过滤掉http://localhost:9000/favicon.ico</span></span><br><span class="line">            HttpRequest request =(HttpRequest)msg;</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(request.uri());</span><br><span class="line">            System.out.println(uri);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器接受到/favicon.ico的请求，不响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复信息给浏览器</span></span><br><span class="line">            ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造一个http的响应，即httpResponse</span></span><br><span class="line">            DefaultHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,byteBuf.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息给客户端</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelPipeline;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author</span><br><span class="line"> * @description</span><br><span class="line"> * @create 2021-10-22 23:44</span><br><span class="line"> */</span><br><span class="line">public class TestHttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        // 向管道中加入handler</span><br><span class="line">        // 得到管道</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        // 加入一个netty提供的httpServerCodec codec -&gt; coder decoder</span><br><span class="line">        // HttpServerCodec：netty提供的编-解码器</span><br><span class="line">        pipeline.addLast(&quot;MyHttpServerCodec&quot;,new HttpServerCodec());</span><br><span class="line"></span><br><span class="line">        // 增加一个自定义handler</span><br><span class="line">        pipeline.addLast(&quot;myHttpServerHandler&quot;,new TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024134309376.png" class title="image-20211024134309376">



<h4 id="Pipeline和ChannelPipeline"><a href="#Pipeline和ChannelPipeline" class="headerlink" title="Pipeline和ChannelPipeline"></a>Pipeline和ChannelPipeline</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024140557169.png" class title="image-20211024140557169">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024141225689.png" class title="image-20211024141225689"> 



<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024143115758.png" class title="image-20211024143115758">

<h4 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024143326063.png" class title="image-20211024143326063">



<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024144323040.png" class title="image-20211024144323040">



<h4 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024144752282.png" class title="image-20211024144752282">

<p><strong>基本使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBuf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">// 创建 对象：该对象包含一个数组arr，是一个byte[10]</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// netty的buffer中，不需要使用flip进行反转</span></span><br><span class="line">        <span class="comment">// 原因：netty的buffer底层维护了readerIndex和writerIndex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBuf1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;my dear friends&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buf.hasArray())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] array = buf.array();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(array,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从哪个下标开始读</span></span><br><span class="line">            System.out.println(buf.readerIndex());</span><br><span class="line">            <span class="comment">// 从哪个下标开始写</span></span><br><span class="line">            System.out.println(buf.writerIndex());</span><br><span class="line">            <span class="comment">// 可以读取的元素的长度</span></span><br><span class="line">            System.out.println(buf.readableBytes());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="netty实现多人聊天室"><a href="#netty实现多人聊天室" class="headerlink" title="netty实现多人聊天室"></a>netty实现多人聊天室</h4><p>功能：能够实现多人聊天、上下线提示以及加入群聊提示和离开群聊提示</p>
<p><strong>服务器端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 15:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverStrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverStrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 向pipeline中添加解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 向pipeline中添加编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;serverHandler&quot;</span>,<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverStrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer(<span class="number">9000</span>);</span><br><span class="line">        groupChatServer.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>服务器端的handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mjy.netty.groupchat.entity.User;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE：全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup=<span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;User,Channel&gt; channelMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// handlerAdded表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入QQ号：&quot;</span>);</span><br><span class="line">        String id=scan.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入姓名：&quot;</span>);</span><br><span class="line">        String name=scan.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入昵称：&quot;</span>);</span><br><span class="line">        String nickname=scan.next();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setNickname(nickname);</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelMap.put(user,channel);</span><br><span class="line">        <span class="comment">// 将该客户加入聊天的信息推送给其它在线的客户</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;【客户端】&quot;</span>+channel.remoteAddress()+<span class="string">&quot;加入聊天~&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示断开连接，将客户离开的信息推送给当前在线的客户</span></span><br><span class="line">    <span class="comment">// 执行该方法，会自动将channel从channelGroup中移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;离开\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel处于活动状态，提示上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;：&quot;</span>+sdf.format(<span class="keyword">new</span> Date())+<span class="string">&quot;上线~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel处于非活动状态，提示下线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;：&quot;</span>+sdf.format(<span class="keyword">new</span> Date())+<span class="string">&quot;下线~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;发送消息：&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所发消息发送给其它客户</span></span><br><span class="line">        channelGroup.forEach(ch-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel!=ch)&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span>+channel.remoteAddress()+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host=host;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;clientHandler&quot;</span>,<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            ChannelFuture channelFutrue = bootstrap.connect(host, port).sync();</span><br><span class="line">            Channel channel = channelFutrue.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------&quot;</span>+channel.localAddress()+<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">                String message = scanner.next();</span><br><span class="line">                channel.writeAndFlush(message);</span><br><span class="line">            &#125;</span><br><span class="line">            scanner.close();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFutrue.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        groupChatClient.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>通过添加IdleStateHandler实现每隔一段时间（若服务器无相应操作）发送心跳检测包检测当前连接是否断开</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">// IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            long readerIdleTime：表示多长时间没读，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个对空闲处理的handler</span></span><br><span class="line">                            <span class="comment">// 当IdleStateEvent触发后，就会传递给管道的下一个handler去处理，通过调用下一个handler的userEventTiggered方法</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HeartServerHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handler：处理空闲检测</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *处理空闲检测</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt：事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line">            String tips=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">switch</span>(event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;---超时---：&quot;</span>+tips);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211025112119832.png" class title="image-20211025112119832">

<p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 基于http协议，使用http的编码和解码</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// http数据在传输过程中是分段的，HttpObjectAggregator可以将多个段聚合</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            对应webSocket，它的数据是以帧进行传递的</span></span><br><span class="line"><span class="comment">                            浏览器请求时：ws://localhost:9000/hello 表示请求的url</span></span><br><span class="line"><span class="comment">                            WebSocketServerProtocolHandler 核心功能是将http请求升级为ws请求，保持长连接</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务逻辑，自定义handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> TextWebSocketFrameHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>实现业务的自定义handler</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息：&quot;</span>+msg.text());</span><br><span class="line">        <span class="comment">// 服务器回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;当前时间：&quot;</span>+ LocalDateTime.now()+msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户端连接后触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// LongText：是唯一的，shortText不是唯一的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用：&quot;</span>+ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用：&quot;</span>+ctx.channel().id().asShortText());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户段断开连接后触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved被调用：&quot;</span>+ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved被调用：&quot;</span>+ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>聊天框：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> socket;</span><br><span class="line">    <span class="comment">// 判断当前浏览器是否支持webSocket</span></span><br><span class="line">    <span class="keyword">if</span>(window.WebSocket)&#123;</span><br><span class="line">        socket=<span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9000/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于channelReado,ev收到服务器端回送的消息</span></span><br><span class="line">        socket.onmessage=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=content.value+ev.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于连接开启</span></span><br><span class="line">        socket.onopen=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=<span class="string">&quot;连接开启~&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于连接关闭</span></span><br><span class="line">        socket.onclose=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=content.value+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;连接关闭了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;当前浏览器不支持webSocket&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">send</span><span class="params">(message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!window.socket)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(socket.readyState==WebSocket.OPEN)&#123;</span><br><span class="line">            <span class="comment">// 通过socket发送消息</span></span><br><span class="line">            socket.send(message);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;连接没有开启&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">clearContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        document.getElementById(<span class="string">&quot;responseText&quot;</span>).value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;form onsubmit=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">    &lt;textarea name=<span class="string">&quot;message&quot;</span> style=<span class="string">&quot;width:300px;height:100px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;发送消息&quot;</span> onclick=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><br><span class="line">    &lt;textarea id=<span class="string">&quot;responseText&quot;</span> style=<span class="string">&quot;width:300px;height:100px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;清空内容&quot;</span> onclick=<span class="string">&quot;clearContent()&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h4 id="netty编码和解码的基本介绍"><a href="#netty编码和解码的基本介绍" class="headerlink" title="netty编码和解码的基本介绍"></a>netty编码和解码的基本介绍</h4><p>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时便需要解码</p>
<p>codec（编码器）的组成：decoder(解码器)和encoder(编码器)</p>
<p>netty本身自带的ObjectDecoder和ObjectEncoder可以用来实现对象的编码和解码，底层使用的仍是Java序列化操作，而Java序列化操作技术本身效率并不高，存在以下问题：</p>
<ul>
<li>无法跨语言</li>
<li>序列化后体积太大，是二进制编码的5倍多</li>
<li>序列化效率太低</li>
</ul>
<p><strong>解决方案：Google的protobuf</strong></p>
<p>protobuf是Google发布的开源项目，全称Google Protocol Buffers，是一种轻便高效的结构化数据存出格式，开源用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC[远程过程调用 remote proceduce call] 数据交换格式。</p>
<p>Protobuf是以message的方式来管理数据的</p>
<p>支持跨平台、跨语言</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211025234656688.png" class title="image-20211025234656688">

<p>使用示例：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for=SPEED; <span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.mjy.netty.codec1&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">&quot;MyDataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protobuf 可以使用message 管理其他的message</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span></span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span></span>&#123;</span><br><span class="line">    StudentType=<span class="number">0</span>; <span class="comment">// 在proto3要求enum编号从0开始</span></span><br><span class="line">    WorkerType=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用data_type来标识传的是哪一个枚举类型</span></span><br><span class="line">  DataType data_type=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示每次枚举类型最多只能出现其中的一个，节省空间</span></span><br><span class="line">  <span class="keyword">oneof</span> dataBody&#123;</span><br><span class="line">    Student student=<span class="number">2</span>;</span><br><span class="line">    Worker worker=<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用protoc.exe进行编译生成Java文件</p>
<h4 id="netty的入站和出站"><a href="#netty的入站和出站" class="headerlink" title="netty的入站和出站"></a>netty的入站和出站</h4><p>示例：</p>
<p><strong>Netty的handler的调用机制</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211027105623769.png" class title="image-20211027105623769">

<p><strong>服务器端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> InAndOutChannelInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取pipeline</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入入站的自定义解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入出站的自定义编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> InAndOutServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端发送过来的Long类型的数据：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>编码器和解码器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *decode 会根据接收的数据，被调用多次，直到确定没有新的元素被添加到List，或是ByteBuf没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out不为空，就会将该list的内容传递给下一个channelinboundhandler处理，该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List集合，将解码后的数据传递给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否可读的有8个字节，若有8个字节，读取为long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes()&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyLongToByteEncoder被调用：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码信息：&quot;</span>+msg);</span><br><span class="line">        <span class="comment">// 将long类型编码成为ByteBuf</span></span><br><span class="line">        <span class="comment">// 要注意传入的数据类型，若不是我们定义的类型，那么这个方法不会执行</span></span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端与服务器端代码类似，略</p>
<p><strong>结论：</strong></p>
<ul>
<li>不论解码器handler还是编码器handler接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</li>
<li>在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够，否则接收到的信息可能会与期望的结果不一样</li>
</ul>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029145159607.png" class title="image-20211029145159607">

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029145240654.png" class title="image-20211029145240654">



<p><strong>LengthFieldBasedFrameDecoder解码器</strong></p>
<p>几个重要的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 长度字段偏移量</span><br><span class="line">private final int lengthFieldOffset;</span><br><span class="line">// 长度字段长度</span><br><span class="line">private final int lengthFieldLength;</span><br><span class="line">// 长度字段为基准，还有几个字节是内容</span><br><span class="line">private final int lengthFieldEndOffset;</span><br><span class="line">// 从头剥离几个字节</span><br><span class="line">private final int lengthAdjustment;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLengthFieldDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">                <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        embeddedChannel.writeInbound(buffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ByteBuf buffer, String content)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes();</span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        <span class="comment">// 若还加入其它信息，需要设置lengthFieldEndOffset参数</span></span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Log4j整合到Netty"><a href="#Log4j整合到Netty" class="headerlink" title="Log4j整合到Netty"></a>Log4j整合到Netty</h4><p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%P] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure>

<p><strong>输出格式的参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%m   输出代码中指定的消息</span><br><span class="line">%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </span><br><span class="line">%r   输出自应用启动到输出该log信息耗费的毫秒数 </span><br><span class="line">%c   输出所属的类目，通常就是所在类的全名 </span><br><span class="line">%t   输出产生该日志事件的线程名 </span><br><span class="line">%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” </span><br><span class="line">%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：<span class="number">2002</span>年<span class="number">10</span>月<span class="number">18</span>日  <span class="number">22</span> ： <span class="number">10</span> ： <span class="number">28</span> ， <span class="number">921</span>  </span><br><span class="line">%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: <span class="number">10</span> ) </span><br></pre></td></tr></table></figure>



<h4 id="TCP粘包和拆包的基本介绍"><a href="#TCP粘包和拆包的基本介绍" class="headerlink" title="TCP粘包和拆包的基本介绍"></a>TCP粘包和拆包的基本介绍</h4><p>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务端）都要有一一成对的socket，因此发送端为了将多个发给接收端的包，更有效的发送给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量较少的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就很难分辨出完整的数据包了，因为面向流的通信是无消息保护边界的。</p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029155828671.png" class title="image-20211029155828671">

<p><strong>粘包和拆包-滑动窗口</strong></p>
<p>TCP以一个端为单位，每发送一个段就需要进行一次确认应答（ack处理），但如果这么做，缺点是包的往返时间越长性能就越差。</p>
<p>为了解决此问题，引入了窗口的概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值。</p>
<p><strong>窗口实际上就起到了一个缓冲区的作用，同时也能起到流量控制的作用</strong></p>
<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211030172645841.png" class title="image-20211030172645841">

<ul>
<li>窗口内的数据，不需要应答就能发送</li>
<li>若窗口这个段的数据的ack回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收。</li>
</ul>
<p><strong>TCP粘包和拆包实例演示</strong></p>
<p>MyClient.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyInitializer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyClientHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello server_&quot;</span> + i, CharsetUtil.UTF_8);</span><br><span class="line">            ctx.writeAndFlush(byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(arr);</span><br><span class="line">        String s = <span class="keyword">new</span> String(arr, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到来自服务端的消息：&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的数据量为：&quot;</span>+(++<span class="keyword">this</span>.count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>MyServer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyServerHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(arr);</span><br><span class="line">        String s = <span class="keyword">new</span> String(arr, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端接收到了客户端的信息：&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息量：&quot;</span>+(++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器回送数据给客户端</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">&quot; &quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyServerInitializer.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211030111255728.png" class title="image-20211030111255728">

<p>服务器接收数据时，不一定每一次的接收都相同。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li><p>使用自定义协议包+编解码</p>
<p>自定义协议包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MessageProtocol &#123;</span><br><span class="line">    private int len;</span><br><span class="line">    private byte[] content;</span><br><span class="line"></span><br><span class="line">    public int getLen() &#123;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLen(int len) &#123;</span><br><span class="line">        this.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(byte[] content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder被调用&quot;</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(len);</span><br><span class="line">        messageProtocol.setContent(bytes);</span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>解决粘包和拆包的关键在于每次读取数据长度的问题，解决了数据长度的问题就不会出现服务器多读和少读的问题，就不会出现粘包和拆包的问题。</p>
</li>
</ul>
<h4 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h4><p><strong>实现Redis RESP协议</strong></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] LINE=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">13</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(msg.toString());</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">                                    ByteBuf buffer1 = Unpooled.buffer();</span><br><span class="line"></span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;auth&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$9&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;mjy600811&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    ctx.writeAndFlush(buffer);</span><br><span class="line"></span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$8&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;zhangsan&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    ctx.writeAndFlush(buffer1);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;116.62.122.89&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>http协议</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 添加http协议编码器和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(msg.uri());</span><br><span class="line"></span><br><span class="line">                                    DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line">                                    response.content().writeBytes(<span class="string">&quot;&lt;h1&gt;hello,world&lt;h1/&gt;&quot;</span>.getBytes());</span><br><span class="line">                                    ctx.writeAndFlush(response);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义协议要素</strong></p>
<ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，登录、注册、单聊、群聊…跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<p>代码：</p>
<p>Message.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequenceId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestMessage=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestResponse=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Class&lt;?&gt; getMessageClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSequenceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sequenceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequenceId</span><span class="params">(<span class="keyword">int</span> sequenceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequenceId = sequenceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageType</span><span class="params">(<span class="keyword">int</span> messageType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageType = messageType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LoginRequestMessage.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginRequestMessage</span><span class="params">(String username, String password, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginRequestMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoginRequestMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getMessageClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNickname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickname</span><span class="params">(String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MessageCodec.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 写入4个字节魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 一个字节的版本</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个字节的序列化方式 0 jdk 1 json</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 1字节的指定类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 4个字节请求序列</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 对齐填充，为了让字节数为2的整数倍</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">int</span> length=bytes.length;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        out.writeInt(length);</span><br><span class="line"></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="comment">// 版本</span></span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="comment">// sequenceType</span></span><br><span class="line">        <span class="keyword">byte</span> sequenceType = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// messageType</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sequenceId</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充</span></span><br><span class="line">        in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容长度</span></span><br><span class="line">        <span class="keyword">int</span> len = in.readInt();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(bytes,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        Message msg = (Message)ois.readObject();</span><br><span class="line"></span><br><span class="line">        out.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMessageCodec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">                <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG),</span><br><span class="line"><span class="comment">//                new LengthFieldBasedFrameDecoder(1024,12,4,0,0),</span></span><br><span class="line">                <span class="keyword">new</span> MessageCodec()</span><br><span class="line">        );</span><br><span class="line">        LoginRequestMessage loginRequestMessage = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;12345&quot;</span>, <span class="string">&quot;法外狂徒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        embeddedChannel.writeOutbound(loginRequestMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试解码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">            <span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>,loginRequestMessage,buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 还需要考虑粘包问题</span></span><br><span class="line">            ByteBuf s1 = buffer.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">            ByteBuf s2 = buffer.slice(<span class="number">100</span>, buffer.readableBytes() - <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在读取完内容之后，会执行release方法，释放内存，但因为slice方式是零拷贝，所以s1和s2使用的是同一块内存</span></span><br><span class="line">            <span class="comment">// 执行release会将所有内存释放，继续writeInbound(s2)会报错</span></span><br><span class="line">            <span class="comment">// 需要执行s1.retain()阻止release方法清除内存</span></span><br><span class="line">            s1.retain();</span><br><span class="line">            embeddedChannel.writeInbound(s1);</span><br><span class="line">            embeddedChannel.writeInbound(s2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        embeddedChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Netty核心源码"><a href="#Netty核心源码" class="headerlink" title="Netty核心源码"></a>Netty核心源码</h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Laity&amp;</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://polaris-ux.github.io/2021/10/15/netty学习/">https://polaris-ux.github.io/2021/10/15/netty学习/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/10/17/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB/"><i class="fa fa-chevron-left">  </i><span>网络的空闲时刻</span></a></div><div class="next-post pull-right"><a href="/2021/10/08/Invalid-bound-statement-not-found-com-project-seckill-mapper-UserMapper-getById/"><span>Invalid bound statement (not found): com.project.seckill.mapper.UserMapper.getById</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://polaris-ux.github.io/2021/10/15/netty%E5%AD%A6%E4%B9%A0/';
  this.page.identifier = '2021/10/15/netty学习/';
  this.page.title = 'netty学习';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'polaris-4' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://polaris-4.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://th.bing.com/th/id/R.db1eab53ff269e5709d90f8b197fafb7?rik=zABgriNA09F1vA&amp;riu=http%3a%2f%2fwww.shijuepi.com%2fuploads%2fallimg%2f201128%2f1-20112QP934.jpg&amp;ehk=Lr%2f%2fq1LA75MkgirCJbR87lb7M%2bZJlTMtjvLaj6Bg0lE%3d&amp;risl=&amp;pid=ImgRaw)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By Laity&</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" data-click="false"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>