<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>亚信一面</title>
      <link href="/2022/04/19/%E4%BA%9A%E4%BF%A1%E4%B8%80%E9%9D%A2/"/>
      <url>/2022/04/19/%E4%BA%9A%E4%BF%A1%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>美团测开二面</title>
      <link href="/2022/04/12/%E7%BE%8E%E5%9B%A2%E6%B5%8B%E5%BC%80%E4%BA%8C%E9%9D%A2/"/>
      <url>/2022/04/12/%E7%BE%8E%E5%9B%A2%E6%B5%8B%E5%BC%80%E4%BA%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="美团测开二面"><a href="#美团测开二面" class="headerlink" title="美团测开二面"></a>美团测开二面</h3><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>因为在介绍的时候提到了我们学院的培训，然后就问了对这个问了比较久</p><h4 id="测开和开发的区别？"><a href="#测开和开发的区别？" class="headerlink" title="测开和开发的区别？"></a>测开和开发的区别？</h4><h4 id="对测开的认识和理解？为什么不投开发"><a href="#对测开的认识和理解？为什么不投开发" class="headerlink" title="对测开的认识和理解？为什么不投开发"></a>对测开的认识和理解？为什么不投开发</h4><p>这问题老尴尬了，因为是开发挂了，才被测开捞起来的，但还是得说得委婉点</p><h4 id="给了一个增删库存的业务场景，问我应该怎么做-不限于测开，前端后端都可以说"><a href="#给了一个增删库存的业务场景，问我应该怎么做-不限于测开，前端后端都可以说" class="headerlink" title="给了一个增删库存的业务场景，问我应该怎么做(不限于测开，前端后端都可以说)"></a>给了一个增删库存的业务场景，问我应该怎么做(不限于测开，前端后端都可以说)</h4><p>回答的后端事务啥的，balabala</p><h4 id="针对上面的的场景设计测试案例"><a href="#针对上面的的场景设计测试案例" class="headerlink" title="针对上面的的场景设计测试案例"></a>针对上面的的场景设计测试案例</h4><h4 id="然后做了两道算法题"><a href="#然后做了两道算法题" class="headerlink" title="然后做了两道算法题"></a>然后做了两道算法题</h4><p>1、青蛙跳台阶</p><p>2、将字符串转化为整型(很简单的问题，结果考虑边界没考虑好，没做出来，中途校园网还断了，不得不夸一下我校的校园网，下次面试一定开热点)</p><h4 id="了解测开的一些知识嘛？了解哪些测试方法？有了解相关的一些测试工具嘛？"><a href="#了解测开的一些知识嘛？了解哪些测试方法？有了解相关的一些测试工具嘛？" class="headerlink" title="了解测开的一些知识嘛？了解哪些测试方法？有了解相关的一些测试工具嘛？"></a>了解测开的一些知识嘛？了解哪些测试方法？有了解相关的一些测试工具嘛？</h4><h4 id="对美团的认识"><a href="#对美团的认识" class="headerlink" title="对美团的认识"></a>对美团的认识</h4><h4 id="问了一下用过滴滴嘛？然后让我根据滴滴的页面设计测试案例"><a href="#问了一下用过滴滴嘛？然后让我根据滴滴的页面设计测试案例" class="headerlink" title="问了一下用过滴滴嘛？然后让我根据滴滴的页面设计测试案例"></a>问了一下用过滴滴嘛？然后让我根据滴滴的页面设计测试案例</h4><h4 id="反问："><a href="#反问：" class="headerlink" title="反问："></a>反问：</h4><p>表现怎么样？面试官还是说了我的测试知识需要更深一步的学习(委婉说我一面到二面之间的时间没去好好学习测开知识)，没办法，我其实还是想走开发</p><p>实习生需要提前学习什么知识嘛？答：能够提前学习一些知识肯定更好，没有提前学习也没关系，实习期间会有一对一的导师带</p><p>部门的详情</p><p>总结：测开面试官小姐姐都很好，校园网断了还打电话来询问为啥离线了，我问的问题也都很认真的回答。虽然不是很了解美团，但就面试官来说好感度直接拉满好吧。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团测开一面</title>
      <link href="/2022/04/12/%E7%BE%8E%E5%9B%A2%E6%B5%8B%E5%BC%80%E4%B8%80%E9%9D%A2/"/>
      <url>/2022/04/12/%E7%BE%8E%E5%9B%A2%E6%B5%8B%E5%BC%80%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="美团测开一面"><a href="#美团测开一面" class="headerlink" title="美团测开一面"></a>美团测开一面</h2><h4 id="首先进行自我介绍"><a href="#首先进行自我介绍" class="headerlink" title="首先进行自我介绍"></a>首先进行自我介绍</h4><h4 id="问了下自己的聊天项目"><a href="#问了下自己的聊天项目" class="headerlink" title="问了下自己的聊天项目"></a>问了下自己的聊天项目</h4><h4 id="根据聊天项目的登录-注册功能设计测试案例"><a href="#根据聊天项目的登录-注册功能设计测试案例" class="headerlink" title="根据聊天项目的登录/注册功能设计测试案例"></a>根据聊天项目的登录/注册功能设计测试案例</h4><p>第二次面试，没啥经验，答得比较简单，没有考虑异常操作的情况(比如多次登录、网络故障等问题)</p><h4 id="问了下HTTP的三次握手"><a href="#问了下HTTP的三次握手" class="headerlink" title="问了下HTTP的三次握手"></a>问了下HTTP的三次握手</h4><p>老八股了</p><h4 id="还问了下MySQL但没有问具体的问题"><a href="#还问了下MySQL但没有问具体的问题" class="headerlink" title="还问了下MySQL但没有问具体的问题"></a>还问了下MySQL但没有问具体的问题</h4><h4 id="然后就出了一道sql题"><a href="#然后就出了一道sql题" class="headerlink" title="然后就出了一道sql题"></a>然后就出了一道sql题</h4><p>sql题很简单，就一个having</p><h4 id="然后问了where和having的区别"><a href="#然后问了where和having的区别" class="headerlink" title="然后问了where和having的区别"></a>然后问了where和having的区别</h4><p>where是一个约束声明，使用where来约束来自数据库的数据，且where中不能使用聚合函数</p><p>having是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在having中可以使用聚合函数。</p><h4 id="对测开这个岗位的理解"><a href="#对测开这个岗位的理解" class="headerlink" title="对测开这个岗位的理解"></a>对测开这个岗位的理解</h4><h4 id="了解过一些测开的知识嘛？"><a href="#了解过一些测开的知识嘛？" class="headerlink" title="了解过一些测开的知识嘛？"></a>了解过一些测开的知识嘛？</h4><p>回答了黑盒、白盒，以及测试的流程：单元测试、集成测试、系统测试、验收测试</p><h4 id="了解测试的工具嘛？"><a href="#了解测试的工具嘛？" class="headerlink" title="了解测试的工具嘛？"></a>了解测试的工具嘛？</h4><p>说了Jmeter，细问具体可以干啥，寄</p><h4 id="出了道算法题，就统计指定字符串的个数以及出现位置"><a href="#出了道算法题，就统计指定字符串的个数以及出现位置" class="headerlink" title="出了道算法题，就统计指定字符串的个数以及出现位置"></a>出了道算法题，就统计指定字符串的个数以及出现位置</h4><p>很简单，但是因为面试官出的题规定了输入，然后我又理解错误，导致我将参数固定了。。。（感谢面试官小姐姐包容我）</p><h4 id="根据我的项目，出了个根据聊天页面设计测试案例"><a href="#根据我的项目，出了个根据聊天页面设计测试案例" class="headerlink" title="根据我的项目，出了个根据聊天页面设计测试案例"></a>根据我的项目，出了个根据聊天页面设计测试案例</h4><p>还是没考虑到异常情况。</p><h4 id="还聊了一些其它的，记不住"><a href="#还聊了一些其它的，记不住" class="headerlink" title="还聊了一些其它的，记不住"></a>还聊了一些其它的，记不住</h4><h4 id="最后考了个智力题"><a href="#最后考了个智力题" class="headerlink" title="最后考了个智力题"></a>最后考了个智力题</h4><p>8个苹果，有一个苹果重，其它几个苹果相同重，有一个秤，可以称两次如何获取重的那个苹果。</p><h4 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h4><p>问了一下有哪些不足？小姐姐跟我说还是要多考虑一些异常情况</p><p>美团的面试官感觉都挺好的，不会的就会问其它的，不会故意为难你，问问题的话也会耐心解答，总之感谢美团给我面试机会(第一个笔试和面试都是美图的)</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC包下的同步工具类</title>
      <link href="/2022/03/25/JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/03/25/JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>概念：是一个同步辅助器，允许一个或多个线程一直等待，直到一组在其它线程执行的操作全部完成。</p><p>构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的构造方法，会传入一个count值，用于计数</p><p>常用的方法有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程调用await方法时，就会阻塞当前线程。每当有线程调用一次countDown方法时，计数就会减1.当count的值等于0的时候，被阻塞的线程才会继续运行。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker(<span class="string">&quot;张三&quot;</span>, <span class="number">2000</span>, countDownLatch);</span><br><span class="line">        Worker worker1 = <span class="keyword">new</span> Worker(<span class="string">&quot;李四&quot;</span>, <span class="number">3000</span>, countDownLatch);</span><br><span class="line">        worker1.start();</span><br><span class="line">        worker.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;bug全部解决，任务总耗时：&quot;</span>+(System.currentTimeMillis()-start));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> workTime;</span><br><span class="line">        CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name,<span class="keyword">int</span> workTime,CountDownLatch countDownLatch)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=name;</span><br><span class="line">            <span class="keyword">this</span>.workTime=workTime;</span><br><span class="line">            <span class="keyword">this</span>.countDownLatch=countDownLatch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(name+<span class="string">&quot;开始修复bug，当前时间：&quot;</span>+sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">            doWork();</span><br><span class="line"></span><br><span class="line">            System.out.println(name+<span class="string">&quot;结束修复bug，当前时间：&quot;</span>+sdf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(workTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/03/25/JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20220325225710726.png" class title="image-20220325225710726"><p>可以看到只有当两个线程都完成了才会结束程序     </p><h4 id="CyslicBarrier"><a href="#CyslicBarrier" class="headerlink" title="CyslicBarrier"></a>CyslicBarrier</h4><p>概念：一组线程会互相等待，直到所有线程都到达一个同步点。（功能与CountDownLatch类似，但CyclicBarrier能够重复使用）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个构造的参数，指的是需要几个线程一起到达，才可以使所有线程取消等待。第二个构造，额外指定了一个参数，用于在所有线程到达屏障时，优先执行barrierAction</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CyclicBarrierTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">                System.out.println(&quot;裁判员---&gt;吹哨&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Runner runner1 = new Runner(&quot;张三&quot;, cyclicBarrier);</span><br><span class="line">        Runner runner2 = new Runner(&quot;李四&quot;, cyclicBarrier);</span><br><span class="line">        Runner runner3 = new Runner(&quot;王五&quot;, cyclicBarrier);</span><br><span class="line">        ExecutorService pools = Executors.newFixedThreadPool(3);</span><br><span class="line">        pools.execute(runner1);</span><br><span class="line">        pools.execute(runner2);</span><br><span class="line">        pools.execute(runner3);</span><br><span class="line"></span><br><span class="line">        pools.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Runner implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private CyclicBarrier cb;</span><br><span class="line"></span><br><span class="line">    public Runner(String name,CyclicBarrier cb)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.cb=cb;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(name+&quot;:准备Ok&quot;);</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(name+&quot;:开跑&quot;);</span><br><span class="line">        &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/03/25/JUC%E5%8C%85%E4%B8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20220325232243118.png" class title="image-20220325232243118"><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore信号量，用来控制同一时间，资源可被访问的线程数量，一般用于流量控制。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 指定最多只能有5个线程同时执行</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> no=i;</span><br><span class="line">            executorService.execute(() -&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取许可</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(no+<span class="string">&quot;号车通行&quot;</span>);</span><br><span class="line">                    <span class="comment">// 模拟车辆同行耗时</span></span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">                    <span class="comment">// 释放许可</span></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可重入锁和AQS</title>
      <link href="/2022/03/25/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8CAQS/"/>
      <url>/2022/03/25/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8CAQS/</url>
      
        <content type="html"><![CDATA[<h4 id="AQS：AbstractQueuedSynchronized"><a href="#AQS：AbstractQueuedSynchronized" class="headerlink" title="AQS：AbstractQueuedSynchronized"></a>AQS：AbstractQueuedSynchronized</h4><p>队列同步器，ReentrantLock就是基于AQS实现的</p><p>AQS底层由一个state标志位和一个同步队列构成(同步队列是一个双向链表)，其实还维护了多个条件变量的等待队列。</p><img src="/2022/03/25/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%92%8CAQS/image-20220325124217958.png" class title="image-20220325124217958"><p>当获取锁的线程需要等待某个条件时，会进入condition的等待队列中，等待队列可以有多个，因为一个ReentrantLock能够绑定多个Condition，即每一个Condition都会维护一个等待队列。</p><p>ReentrantLock内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比在同步队列中的等待线程更早获得锁。</p><p>ReentrantLock里面有一个内部类Sync，Sync继承于AQS，添加锁和释放锁的大部分操作都是在Sync中实现的。它有两个子类，公平锁FairSync和非公平锁NonfairSync。ReentrantLock默认是非公平锁的，可以通过构造器进行设置是否为公平锁。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS学习</title>
      <link href="/2022/03/24/CAS%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/03/24/CAS%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS?"></a>什么是CAS?</h4><p>CAS(比较并交换)，是乐观锁的一种实现方式，是一种轻量级锁，JUC包下很多工具类的实现就是基于CAS操作的。比如juc包下的原子类的实现就是基于Unsafe类的CAS操作。</p><h4 id="CAS是如何保证线程安全的"><a href="#CAS是如何保证线程安全的" class="headerlink" title="CAS是如何保证线程安全的"></a>CAS是如何保证线程安全的</h4><p>调用Unsafe的CAS操作时，会有三个参数</p><ul><li>想要修改变量的内存地址</li><li>期望的值</li><li>以及想要修改的值</li></ul><p>在进行CAS操作时，会先将期望的值与内存地址对应的值进行比较，若相等则意味着没有其它线程对其进行修改，那么就可以进行修改；否则，会进行重试直到修改成功。简单来说就是在进行修改操作之前会先查询修改变量的值，在修改之前会将当前变量的值和获取的之前的值进行比较，若相等则代表着没有其它线程对其进行修改，那么可以进行修改。</p><h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>例子：线程1读取了数据A，线程2读取了数据A，线程2通过CAS进行比较，发现值是A，所以将数据A修改成数据B，线程3读取了数据B，然后通过CAS进行比较，发现值是数据B，就将数据B修改为数据A，此时线程1通过CAS进行比较，发现值仍是A，于是进行修改。</p><p>问题：数据A被修改为了B，然后又被修改为了A，此时线程A认为数据A是未被其它线程修改的</p><p>解决方法：</p><ul><li>添加一个版本号，在CAS时不仅对比数据也需要对比版本号</li><li>添加一个时间戳(其实和版本号的方法类似)</li></ul><h5 id="循环时间开销过大的问题"><a href="#循环时间开销过大的问题" class="headerlink" title="循环时间开销过大的问题"></a>循环时间开销过大的问题</h5><p>CAS操作不成功的话，会一直进行重试，即一直自旋的一个状态，相当于一个死循环的状态，这样的话CPU的压力会很大。</p><p>这个解决方法的话，我个人理解的话就是可以对它进行一个重试次数的限制，当超过次数限制后就直接返回失败。(Synchronized锁优化的自旋锁就是这样做的)</p><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>CAS操作单个共享变量的时候可以保证原子操作，但对多个变量操作的时候就不行了，JDK5之后AtomicReference可以用来保证对象之间的原子性，就可以将多个对象放入CAS中进行操作了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全的List</title>
      <link href="/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List/"/>
      <url>/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List/</url>
      
        <content type="html"><![CDATA[<img src="/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List/image-20220324105150030.png" class title="image-20220324105150030"><h4 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h4><p>都继承于Collection接口</p><ul><li>List中允许有重复元素的存在，而Set中不允许有重复元素存在</li><li>List是有序集合，Set是无序集合</li><li>List能够顺序访问，而Set不能够顺序访问</li></ul><h4 id="List接口的常见实现类"><a href="#List接口的常见实现类" class="headerlink" title="List接口的常见实现类"></a>List接口的常见实现类</h4><p><strong>ArrayList</strong>:底层是一个动态数组，线程不安全的，允许对元素进行快速访问，从ArrayList的中间位置进行插入或删除元素时，需要对数组进行复制、移动、代价比较高。适合遍历和随机查找，不适合插入和删除。扩容时会扩容为原来的1.5倍</p><p><strong>Vector</strong>：底层也是一个动态数组，线程安全的，某一时刻只有一个线程能够写Vector，避免多线程同时写时引起的不一致性，但实现同步需要很高的花费。底层实现的话就是直接对方法加锁。效率很低，一般不会使用。扩容时扩容为原来的两倍。</p><p><strong>LinkedList</strong>：底层是一个双向链表，适合数据的动态插入和删除，随机访问和遍历速度较慢。还提供了List接口中没有定义的方法，专门用于操作表头和表位的操作，可以当作堆栈、队列和双向队列使用。</p><p><strong>CopyOnWriteArrayList</strong>：线程安全的，底层仍是一个动态数组，是线程安全的，实现了读读不互斥，读写也不互斥，实现思想是写操作写最新的数组，读操作读旧的数组。</p><img src="/2022/03/24/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List/image-20220324112214119.png" class title="image-20220324112214119"><p>可以看到copyOnWriteArrayList类下面的array数组通过transient和volatile进行修饰。</p><p>transient：让某些被修饰的成员变量不被序列化，即该变量不会被持久化到磁盘中。</p><p>volatile：可见性、防止指令重排</p><p>copyOnWriteArrayList的add方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">// 创建一个新数组进行操作，在此期间，读操作可以读之前的数组，实现了读写不互斥</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到在添加元素时，会通过lock进行加锁且添加元素是创建了一个新的数组用于写操作，写完之后将新数组的地址赋给原来的数组。因为array数组用volatile修饰，因此一旦修改后就对所有线程是可见的。</p><p>remove方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到copyOnWriteArrayList的插入和删除都是加锁并通过一个新的数组来完成的</p><p>结论：CopyOnWriteArrayList是线程安全的，底层数组通过transient、volatile修饰，插入和删除操作都通过lock进行加锁和创建一个新的数组来进行操作，从而实现了读写不互斥、读读不互斥。</p><p>缺点：每次插入删除操作时都需要创建一个新的数组进行操作，比较浪费空间；可以会有短暂的数据不一致，不适合要求对实时性要求比较高的场景。</p><p><strong>Collections.synchronizedList</strong>：线程安全的，实现的话是对所有操作方法都加锁，效率低。</p><h4 id="Set接口的常见实现类"><a href="#Set接口的常见实现类" class="headerlink" title="Set接口的常见实现类"></a>Set接口的常见实现类</h4><p><strong>HashSet</strong>：当向hashset结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hash值，再通过取模操作获取对象在数组中的位置，并通过hash值和equals方法来判断是否重复。不能保证元素的排列顺序，顺序可能会发生变化；集合元素可以是null，但只能有一个。(跟HashMap实现差不多)</p><p><strong>LinkedHashSet</strong>：LinkedHashSet集合在HashSet的基础上通过链表来维护元素的插入插入顺。LinkedHashSet能够以元素添加的顺序访问集合中的元素，在迭代访问元素时效率比HashSet好，但在插入和删除时效率不如HashSet</p><p><strong>TreeSet</strong>：TreeSet实现了SortedSet接口，底层的数据结构是红黑树，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式：自然排序、定制排序</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团后端一面</title>
      <link href="/2022/03/23/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/"/>
      <url>/2022/03/23/%E7%BE%8E%E5%9B%A2%E5%90%8E%E7%AB%AF%E4%B8%80%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="美团一面面经-凉"><a href="#美团一面面经-凉" class="headerlink" title="美团一面面经(凉)"></a>美团一面面经(凉)</h4><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>介绍的时候磕磕巴巴，需要提前准备好介绍词</p><p>算法题：easy级别的，也是猪脑过载10分钟才做出来</p><h4 id="了解集合吗？List和Set的区别，ArrayList是线程安全的吗？"><a href="#了解集合吗？List和Set的区别，ArrayList是线程安全的吗？" class="headerlink" title="了解集合吗？List和Set的区别，ArrayList是线程安全的吗？"></a>了解集合吗？List和Set的区别，ArrayList是线程安全的吗？</h4><p>猪脑过载(开始回答是，面试官提出疑问)(太紧张了)</p><h4 id="ArrayList和LinkedList说一下"><a href="#ArrayList和LinkedList说一下" class="headerlink" title="ArrayList和LinkedList说一下"></a>ArrayList和LinkedList说一下</h4><p>答的底层实现，以及增删、改查的效率</p><h4 id="List有哪些是线程安全的"><a href="#List有哪些是线程安全的" class="headerlink" title="List有哪些是线程安全的"></a>List有哪些是线程安全的</h4><p>不知道，需要进行学习了解</p><h4 id="了解map吗？说一下HashMap的put"><a href="#了解map吗？说一下HashMap的put" class="headerlink" title="了解map吗？说一下HashMap的put"></a>了解map吗？说一下HashMap的put</h4><p>八股，说了1.7、1.8HashMap的具体实现</p><h4 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h4><p>回答不是，HashMap的put可能会出现插入消失、get可能会获取空值，说CurrentHashMap是线程安全的</p><h4 id="说一下CurrentHashMap"><a href="#说一下CurrentHashMap" class="headerlink" title="说一下CurrentHashMap"></a>说一下CurrentHashMap</h4><p>八股，具体说了一下1.7、1.8的实现(个人认为掌握得不好，遗漏了很多细节，例如：并发扩容，还需加强)</p><h4 id="知道volatile吗？说下它的作用"><a href="#知道volatile吗？说下它的作用" class="headerlink" title="知道volatile吗？说下它的作用"></a>知道volatile吗？说下它的作用</h4><h4 id="了解having-before吗？"><a href="#了解having-before吗？" class="headerlink" title="了解having-before吗？"></a>了解having-before吗？</h4><h4 id="用的是mysql？说一下了解的存储引擎"><a href="#用的是mysql？说一下了解的存储引擎" class="headerlink" title="用的是mysql？说一下了解的存储引擎"></a>用的是mysql？说一下了解的存储引擎</h4><p>回答只了解Innodb、MyISAM，然后对InnoDB展开描述</p><h4 id="提到了B-树，问B-树是啥"><a href="#提到了B-树，问B-树是啥" class="headerlink" title="提到了B+树，问B+树是啥"></a>提到了B+树，问B+树是啥</h4><p>又说错了，开始说了二叉平衡树，面试官进行提醒，然后才说是基于B树，顺序指针进行实现的</p><h4 id="为什么要用B-树？B-树的优点是什么"><a href="#为什么要用B-树？B-树的优点是什么" class="headerlink" title="为什么要用B+树？B+树的优点是什么"></a>为什么要用B+树？B+树的优点是什么</h4><p>说了非叶子节点不存储数据，叶子节点才存储数据，因此能够存储更多的数据</p><p>更低的树高、更好的磁盘IO、可预测读</p><h4 id="了解过数据库优化吗？现在有一条慢SQL，对它如何进行分析"><a href="#了解过数据库优化吗？现在有一条慢SQL，对它如何进行分析" class="headerlink" title="了解过数据库优化吗？现在有一条慢SQL，对它如何进行分析"></a>了解过数据库优化吗？现在有一条慢SQL，对它如何进行分析</h4><p>回答得不好，回答通过explain进行分析该SQL是否使用索引或因为某些原因索引失效</p><h4 id="继续追问，如果当前使用的索引不是所设置的索引如何查找原因"><a href="#继续追问，如果当前使用的索引不是所设置的索引如何查找原因" class="headerlink" title="继续追问，如果当前使用的索引不是所设置的索引如何查找原因"></a>继续追问，如果当前使用的索引不是所设置的索引如何查找原因</h4><p>不会了</p><h4 id="了解MVCC吗？说一下MVCC"><a href="#了解MVCC吗？说一下MVCC" class="headerlink" title="了解MVCC吗？说一下MVCC"></a>了解MVCC吗？说一下MVCC</h4><p>没答好，对这个不太熟悉</p><h4 id="追问可提交读和可重复读的MVCC模型的区别"><a href="#追问可提交读和可重复读的MVCC模型的区别" class="headerlink" title="追问可提交读和可重复读的MVCC模型的区别"></a>追问可提交读和可重复读的MVCC模型的区别</h4><p>不会</p><h4 id="了解锁机制吗？Java中有哪些锁？"><a href="#了解锁机制吗？Java中有哪些锁？" class="headerlink" title="了解锁机制吗？Java中有哪些锁？"></a>了解锁机制吗？Java中有哪些锁？</h4><p>Synchronized、ReetrantLock</p><h4 id="说一下它们之间的区别"><a href="#说一下它们之间的区别" class="headerlink" title="说一下它们之间的区别"></a>说一下它们之间的区别</h4><p>八股</p><h4 id="具体说一下ReetrantLock"><a href="#具体说一下ReetrantLock" class="headerlink" title="具体说一下ReetrantLock"></a>具体说一下ReetrantLock</h4><p>简单说了下，不太熟</p><h4 id="了解Java中原子类吗？说一下它的底层"><a href="#了解Java中原子类吗？说一下它的底层" class="headerlink" title="了解Java中原子类吗？说一下它的底层"></a>了解Java中原子类吗？说一下它的底层</h4><p>没使用过，不会</p><h4 id="了解JVM嘛？说一下JVM的内存模型"><a href="#了解JVM嘛？说一下JVM的内存模型" class="headerlink" title="了解JVM嘛？说一下JVM的内存模型"></a>了解JVM嘛？说一下JVM的内存模型</h4><p>八股</p><h4 id="有哪些垃圾回收算法"><a href="#有哪些垃圾回收算法" class="headerlink" title="有哪些垃圾回收算法"></a>有哪些垃圾回收算法</h4><p>标记清理、标记整理、复制算法、分代垃圾回收</p><h4 id="常用的垃圾回收器"><a href="#常用的垃圾回收器" class="headerlink" title="常用的垃圾回收器"></a>常用的垃圾回收器</h4><h4 id="项目中用到了mybatis，说一下mybatis的两级缓存"><a href="#项目中用到了mybatis，说一下mybatis的两级缓存" class="headerlink" title="项目中用到了mybatis，说一下mybatis的两级缓存"></a>项目中用到了mybatis，说一下mybatis的两级缓存</h4><p>只会用</p><h4 id="用SpringBoot搭建的项目？说一下SpringBoot和Spring的区别"><a href="#用SpringBoot搭建的项目？说一下SpringBoot和Spring的区别" class="headerlink" title="用SpringBoot搭建的项目？说一下SpringBoot和Spring的区别"></a>用SpringBoot搭建的项目？说一下SpringBoot和Spring的区别</h4><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>猪脑过载，说是应用层协议</p><h4 id="了解tcp半连接队列吗？"><a href="#了解tcp半连接队列吗？" class="headerlink" title="了解tcp半连接队列吗？"></a>了解tcp半连接队列吗？</h4><p>不会</p><h4 id="tcp三次握手时，客户端的time-wait的目的"><a href="#tcp三次握手时，客户端的time-wait的目的" class="headerlink" title="tcp三次握手时，客户端的time_wait的目的"></a>tcp三次握手时，客户端的time_wait的目的</h4><h4 id="说一下https的实现"><a href="#说一下https的实现" class="headerlink" title="说一下https的实现"></a>说一下https的实现</h4><h4 id="说一下UDP如何实现可靠传输"><a href="#说一下UDP如何实现可靠传输" class="headerlink" title="说一下UDP如何实现可靠传输"></a>说一下UDP如何实现可靠传输</h4><p>不会</p><h4 id="说一下了解的应用层协议"><a href="#说一下了解的应用层协议" class="headerlink" title="说一下了解的应用层协议"></a>说一下了解的应用层协议</h4><p>不了解</p><h4 id="说一下DNS解析过程"><a href="#说一下DNS解析过程" class="headerlink" title="说一下DNS解析过程"></a>说一下DNS解析过程</h4><h4 id="总共有多少个根域名服务器地址"><a href="#总共有多少个根域名服务器地址" class="headerlink" title="总共有多少个根域名服务器地址"></a>总共有多少个根域名服务器地址</h4><p>不知道</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate的使用</title>
      <link href="/2022/03/21/RestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/03/21/RestTemplate%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是RestTemplate"><a href="#什么是RestTemplate" class="headerlink" title="什么是RestTemplate?"></a>什么是RestTemplate?</h4><p>同步客户端执行HTTP请求，在底层HTTP客户端库（如JDK，Apache HttpComponents等）上公开一个简单的模板方法API。而RestTemplate通过HTTP方法为常见方案提供模板。我的理解就是对HttpClient操作的一些封装。</p><h4 id="构造函数说明"><a href="#构造函数说明" class="headerlink" title="构造函数说明"></a>构造函数说明</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#使用默认设置创建RestTemplate的新实例</span><br><span class="line">RestTemplate()</span><br><span class="line">#基于给定的ClientHttpRequestFactory创建RestTemplate的新实例</span><br><span class="line">RestTemplate(ClientHttpRequestFactory requestFactory)</span><br><span class="line">#使用要使用的HttpMessageConverter给定列表创建RestTemplate的新实例</span><br><span class="line">RestTemplate(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span><br></pre></td></tr></table></figure><h4 id="比较常用的两个方法"><a href="#比较常用的两个方法" class="headerlink" title="比较常用的两个方法"></a>比较常用的两个方法</h4><p>**getForObject()/postForObject()**：通过指定的URL来执行GET/POST请求，返回一个JSON字符串</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForObject</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br></pre></td></tr></table></figure><p>**getForEntity()/postForEntity()**：通过指定的URL来执行GET/Post请求，返回一个ResponseEntity对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">getForEntity</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Map&lt;String,?&gt; uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForEntity</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">postForEntity</span><span class="params">(URI url, Class&lt;T&gt; responseType)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> RestTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
            <tag> 远程调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地缓存</title>
      <link href="/2022/03/19/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2022/03/19/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是本地缓存？"><a href="#什么是本地缓存？" class="headerlink" title="什么是本地缓存？"></a>什么是本地缓存？</h4><p>本地缓存又称为服务器缓存，即存储于服务器的缓存，与客户端的反向代理缓存不同，本地缓存主要用来存储一些常用的数据，由于每个请求进入服务端获取数据都要进行一系列的计算和访问数据库，使用本地缓存后请求到达服务端后会先去本地缓存中查找数据，若本地缓存中有需要的数据就直接返回，否则才会访问数据库去查询数据；通过缓存能够有效的缓解底层数据库以及服务器的压力，但也存在一定的弊端，那就是实时性和数据一致性。对于对实时性要求比较高的场景缓存不太适用；缓存一致性问题的话是所有缓存都有的问题，可以采取一些策略进行改善，但不是绝对的一致，需要进行取舍。</p><h4 id="Ehcache的特点"><a href="#Ehcache的特点" class="headerlink" title="Ehcache的特点"></a>Ehcache的特点</h4><p>Ehcache是一个用Java实现的简单、高速、线程安全的缓存管理类库。它本身的jar包很小、依赖少(唯一的依赖就是SLF4J)，配置简单，API也易于使用，调用起来非常方便。被广泛应用于Hibernate、Spring、Cocoon等开源框架中。</p><p><strong>Ehcache的特点：</strong></p><ul><li><p>快速：Ehcache的线程机制是为大型高并发系统设计的，这一点使得其在性能上具备一定的优势。</p></li><li><p>简单易用：使用Ehcache只需要在配置文件中进行简单的配置即可</p><img src="/2022/03/19/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/image-20220319113120270.png" class title="image-20220319113120270"><p>在Spring中整合Ehcache，配置更少</p><img src="/2022/03/19/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/image-20220319113238596.png" class title="image-20220319113238596"></li><li><p>提供多种缓存策略：支持LRU(最近最少使用)、LFU(最少被使用)和FIFO(先进先出)三种缓存策略，可以根据需求自主选择不同的缓存策略。</p></li><li><p>支持两级数据缓存：数据可以同时缓存在内存和磁盘中，这样一方面扩充了缓存容量，可以以GB为单位缓存数据。另一方面也能够支持数据持久化，在虚拟机重启时从磁盘读取缓存数据到内存，解决虚拟机重启/停机后缓存数据丢失的问题</p></li><li><p>支持分布式缓存</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义starter</title>
      <link href="/2022/03/17/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
      <url>/2022/03/17/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
      
        <content type="html"><![CDATA[<h3 id="自定义一个starter"><a href="#自定义一个starter" class="headerlink" title="自定义一个starter"></a>自定义一个starter</h3><h4 id="先创建一个普通的maven项目（略）"><a href="#先创建一个普通的maven项目（略）" class="headerlink" title="先创建一个普通的maven项目（略）"></a>先创建一个普通的maven项目（略）</h4><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><p>首先要导入SpringBoot的依赖,使其支持包扫描和自动装配</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自动装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写一个Properties来实现属性到实体类的属性的映射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 指定键值对映射到Java实体类属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-17 12:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> String person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPerson</span><span class="params">(String person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 配置类交给IOC容器管理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableConfigurationProperties</span>：告诉SpringBoot,让使用<span class="doctag">@ConfigurationProperties</span>注解的类生效</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@ConditionalOnProperty</span>：注解控制<span class="doctag">@Configuration</span>是否生效，即我们可以在yml配置文件中控制该配置是否生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-17 12:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;hello&quot;,value=&quot;enabled&quot;,matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService(helloProperties.getText(),helloProperties.getPerson());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实际的功能实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 具体功能实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-17 12:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> String toWho;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloService</span><span class="params">(String msg,String toWho)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg=msg;</span><br><span class="line">        <span class="keyword">this</span>.toWho=toWho;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg+<span class="string">&quot;,&quot;</span>+toWho;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SpringBoot在启动时，默认加载并配置classpath下的META-INF/spring.factories中指定的配置类。即我们需要配置类的类路径，然后交给SpringBoot来自动加载并自动装配。在Resources下建立META-INF文件夹，文件夹创建spring.factories文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###自动配置自定义starter</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.mjy.hello.HelloConfig</span><br></pre></td></tr></table></figure><img src="/2022/03/17/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/image-20220317145613107.png" class title="image-20220317145613107"><p>编写完毕后，使用maven的命令进行打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><p>打包后，hello-spring-boot-starter生成的包会被放在maven的本地仓库中。</p><img src="/2022/03/17/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/image-20220317150949843.png" class title="image-20220317150949843"><p>打包完毕后我们就可以直接引用自定义的一个starter了</p><h4 id="引用自定义的starter"><a href="#引用自定义的starter" class="headerlink" title="引用自定义的starter"></a>引用自定义的starter</h4><p>新建一个SpringBoot项目(略)</p><p>引入我们自定义的starter</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mjy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">test-starter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">hello.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">hello.person</span>=<span class="string">tom</span></span><br><span class="line"><span class="meta">hello.text</span>=<span class="string">hey,my best friends,how are you</span></span><br></pre></td></tr></table></figure><p>编写Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mjy.hello.HelloService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-03-17 14:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.say();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><img src="/2022/03/17/SpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter/image-20220317151648994.png" class title="image-20220317151648994">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务之间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTful API)。每个服务都围绕着具体业务进行构建，并且能够被独立的部署到生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言对其进行构建。</p><h3 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h3><p>当多个微服务模块中引用了相同的代码，我们可以将这部分代码提取出来放到一个模块中，来达到减少代码量以及一处编写处处运行的目的。</p><p>例如：</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220319001821473.png" class title="image-20220319001821473"><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220319001838152.png" class title="image-20220319001838152"><p>以上两个模块都使用到了同意返回结果集CommonResult，因此我们可以对其进行抽取封装到一个新的模块</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220319002021677.png" class title="image-20220319002021677"><p>然后在需要用到的模块进行调用，或者使用<code>mvn clean install</code>进行打包到本地厂库，然后再进行引用。</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220319002618892.png" class title="image-20220319002618892"><h3 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h3><h4 id="EureKa服务注册与发现"><a href="#EureKa服务注册与发现" class="headerlink" title="EureKa服务注册与发现"></a>EureKa服务注册与发现</h4><h5 id="Euraka基础知识"><a href="#Euraka基础知识" class="headerlink" title="Euraka基础知识"></a>Euraka基础知识</h5><p><strong>服务治理：</strong>Spring Cloud 封装了Netflix公司开发的Eureka模块来实现服务治理。在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><p><strong>服务注册与发现：</strong>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务的信息比如服务地址通信地址等以别名的方式注册到注册中心。另一方消费者以别名去注册中心获取到实际的服务通讯地址。</p><p><strong>两个组件：</strong></p><ul><li><p>Eureka Server：提供服务注册服务</p><p>各个微服务节点通过配置启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息。</p></li><li><p>EurekaClient：通过注册中心进行访问</p><p>一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳(默认周期为30秒)。如果EurekaServer在多个心跳周期未接收到某个节点的心跳，EurekaServer将会从服务注册表中将该节点移除。</p></li></ul><h4 id="构建单机版的Eureka服务注册"><a href="#构建单机版的Eureka服务注册" class="headerlink" title="构建单机版的Eureka服务注册"></a>构建单机版的Eureka服务注册</h4><p><strong>Eureka Server</strong>:注册中心</p><p>首先创建一个cloud-eureka-server项目（略）</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mjy.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意：当Eureka作为一个单独模块的时候，使用spring-cloud-netflix-eureka-server</span></span><br><span class="line"><span class="comment">            当Eureka依赖父模块的时候的时候，使用spring-cloud-netflix-eureka-server</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#euraka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个Eureka Server编写完成</p><p>编写一个EurekaClient</p><p>还是首先创建一个新项目</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写application.yml文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-order-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：一定要注意配置文件的编写，很容易出错</p><p>至此一个EurekaClient编写完成。</p><h4 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h4><p>目的：实现服务高可用和故障容错</p><p>原理：互相注册</p><p>创建一个新的项目cloud-eureka-server7002，建立过程同上</p><p>修改hosts文件进行映射</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320155115957.png" class title="image-20220320155115957"><p>然后修改两个eurekaServer 服务的配置</p><p>cloud-eureka-server7001</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#euraka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka/</span></span><br></pre></td></tr></table></figure><p>cloud-eureka-server7002</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#euraka服务端的实例名称</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false表示不向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>然后修改客户端的yml配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer中，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。但节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><p>Eureka集群搭建完毕</p><h4 id="创建多个Client并进行服务调用"><a href="#创建多个Client并进行服务调用" class="headerlink" title="创建多个Client并进行服务调用"></a>创建多个Client并进行服务调用</h4><p>首先创建一个</p><p>cloud-provider-payment8002的项目，创建方式与上面相同，且内容一致，只需要改变端口号即可</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8002</span></span><br></pre></td></tr></table></figure><p>然后在cloud-consumer-order中进行服务调用，因为我们之前使用的是单机版所以将服务的调用地址固了，但现在我们有多个相同的服务根据端口号不同来区分就不能使用固定的调用地址了，需要通过它们共同的服务名进行调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerOrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为注册中心提供服务的有多个，所以需要根据服务名来进行服务调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PAYMENT_URL=<span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/add&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">addPayment</span><span class="params">(Payment payment)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注：restTemplate.postForObject发送的数据是json数据，被调用服务若是对象，需要加上@RequestBody</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(PAYMENT_URL+<span class="string">&quot;/payment/add&quot;</span>,payment,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/getInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(PAYMENT_URL+<span class="string">&quot;/payment/getInfo/&quot;</span>+id,CommonResult.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这里还有一个问题，因为我们使用了相同的服务名来进行服务调用而同一个服务名下可能有多个节点提供相同的服务，但我们的restTemplate是不知道调用哪一个服务的，因此需要配置一个负载均衡的功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入一个RestTemplate</span></span><br><span class="line"><span class="comment">     * 简化了发起 HTTP 请求以及处理响应的过程，并且支持 REST风格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 赋予RestTemplate负载均衡的能力，否则在存在多个服务时不知道调用哪一个</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此我们注册了多个Client，并可以通过轮询的方式来调用相同的服务。</p><h4 id="Actuator微服务信息完善"><a href="#Actuator微服务信息完善" class="headerlink" title="Actuator微服务信息完善"></a>Actuator微服务信息完善</h4><p><strong>主机名称：服务名称修改</strong></p><p>在不设置之前，会有主机名显示</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320164858589.png" class title="image-20220320164858589"><p>进行设置后可以不显示主机名</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">  <span class="comment">#设置显示的名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8002</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer中，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。但节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><p>设置后的显示</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320165224912.png" class title="image-20220320165224912"><p><strong>访问信息有IP提示</strong></p><p>未设置是没有IP提示的</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320165506207.png" class title="image-20220320165506207"><p>设置一个prefer-id-address</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#设置服务名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="comment">#访问路径可以提示ip地址</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer中，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。但节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320165753467.png" class title="image-20220320165753467"><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>描述：对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息</p><p>首先要注入一个discoveryClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(PaymentController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/discovery&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">discovery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; allKnownRegions = discoveryClient.getServices();</span><br><span class="line">        <span class="keyword">for</span>(String client:allKnownRegions)&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;****:client:&quot;</span>+client);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取类的具体信息</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(ServiceInstance instanceInfo:instances)&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;****:&quot;</span>+instanceInfo.getServiceId()+<span class="string">&quot;\t&quot;</span>+instanceInfo.getHost()+<span class="string">&quot;\t&quot;</span>+instanceInfo.getUri());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discoveryClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在启动类上加上@EnableDiscoveryClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320173045650.png" class title="image-20220320173045650"><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320173105963.png" class title="image-20220320173105963"><h4 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h4><p>体现</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320173603239.png" class title="image-20220320173603239"><p>原因：某一时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存。属于CAP(一致性、可用性、分区容忍性)中的AP(可用性、分区容忍性)</p><p>自我保护机制：</p><p>默认情况下EurekaClient定时向EurekaServer端发送心跳包。如果Eureka在Server端一定时间内(默认90秒)没有收到EurekaClient发送的心跳包，便会从服务注册表中剔除该服务，但是在短时间内(90秒)内丢失了大量的服务实例心跳，这时候EurekaServer会开启自我保护机制，不会剔除该服务。（该现象可能出现在如果网络不通但是EurekaClient未出现宕机，此时如果换做别的注册中心如果一定时间内没有收到心跳会将剔除该服务，这样就出现了严重失误，因为客户端还能正常发送心跳，只是因为网络延迟问题出现了假死状态）。</p><p><strong>禁止自我保护机制</strong></p><p>修改服务端的yml配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#设置是否开启自我保护机制</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">#eureka server清理无效节点的时间间隔</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>然后修改client的yml配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#设置服务名称</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">payment8001</span></span><br><span class="line">    <span class="comment">#访问路径可以提示ip地址</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认为30秒)</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认为90秒)</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#表示是否将自己注册进EurekaServer中，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#是否从EurekaServer抓取已有的注册信息，默认为true。但节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><h4 id="安装Zookeeper-CP"><a href="#安装Zookeeper-CP" class="headerlink" title="安装Zookeeper(CP)"></a>安装Zookeeper(CP)</h4><p>略</p><h4 id="运行zookeeper"><a href="#运行zookeeper" class="headerlink" title="运行zookeeper"></a>运行zookeeper</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行zookeeper服务端</span></span><br><span class="line">bin/zkServer.sh</span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line">bin/zkCli.sh</span><br></pre></td></tr></table></figure><p>创建一个cloud-provider-payment8004项目</p><p>导入依赖</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.mjy.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;optional&gt;true&lt;/optional&gt;</span></span><br><span class="line">            <span class="string">&lt;scope&gt;true&lt;/scope&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;druid&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;mysql&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/cloud_learn?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf-8&amp;useUnicode=true</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">mjy600811</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.131</span><span class="number">.128</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><p>编写的业务代码与之前类似</p><p>编写controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 该注解用于向使用consul或者zookeeper作为注册中心时注册服务</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentApplication8004</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(PaymentApplication8004.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但以上的步骤运行起来会有问题，即导入的依赖中带有zookeeper的版本与我们虚拟机上安装的zookeeper存在版本冲突。</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320212847367.png" class title="image-20220320212847367"><p>可以看到我们导入的依赖的zookeeper版本为3.5.3，而虚拟机安装的zookeeper的版本为3.4.10</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320213319798.png" class title="image-20220320213319798"><p>解决办法：</p><p>将依赖中的zookeeper依赖去除掉，引用我们自己安装的对应版本号的zookeeper</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--去掉依赖中自带的zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入自己对应的zookeeper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次运行，成功注册</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320214002213.png" class title="image-20220320214002213"><p>zookeeper创建的节点是临时节点，当客户端在对应的心跳周期内未发送心跳包，zookeeper会直接将该节点删除，当该节点恢复时会重新创建一个新的临时节点。</p><p>创建一个cloud-consumer-zk80项目(创建过程略)</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mjy.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--去掉依赖中自带的zookeeper--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入自己对应的zookeeper--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consumer-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.131</span><span class="number">.128</span><span class="string">:2181</span></span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkOrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZkOrderApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写config，向IOC容器中注入一个RestTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Controller代码，通过RestTemplate对cloud-provider-payment8004的服务进行调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/zkorder&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkOrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL=<span class="string">&quot;http://cloud-payment-service/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/zk&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;payment/zk&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320221126642.png" class title="image-20220320221126642"><p>可以看到我们定义的cloud-consumer-zk80服务已经在zookeeper中注册。</p><p>然后进行服务的调用</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220320221248902.png" class title="image-20220320221248902"><p>调用成功，可以看到我们请求的服务是在80端口，而调用的服务是8004端口。</p><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><h4 id="Consul简介-CP"><a href="#Consul简介-CP" class="headerlink" title="Consul简介(CP)"></a>Consul简介(CP)</h4><p>Consul是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用Go语言开发。提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之Consul提供了一种完整的服务网格解决方案。</p><p>特点：</p><ul><li>基于raft协议，比较简洁</li><li>支持健康检查，同时支持HTTP和DNS协议</li><li>支持跨数据中心的WAN集群，提供图形界面</li><li>跨平台</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://www.consul.io/downloads">Downloads | Consul by HashiCorp</a></p><p>下载后解压安装包，在解压的目录下使用consul –version,出现以下内容即代表安装成功</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321164147181.png" class title="image-20220321164147181"><p>启动命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>web地址<code>localhost:8500</code></p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321164435633.png" class title="image-20220321164435633"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>新建一个cloud-providerconsul-payment8006工程</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mjy.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8006</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-payment-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulPaymentApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsulPaymentApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/payment&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulPaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentZk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springcloud with zookeeper：&quot;</span>+serverPort+<span class="string">&quot;\t&quot;</span>+ UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个cloud-consuler-consul80</p><p>导入依赖（与上面相同）</p><p>编写application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">consul-order-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><p>编写启动类(略)</p><p>编写配置类，注入RestTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写一个controller对上面定义的服务进行调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsulOrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INVOKE_URL=<span class="string">&quot;http://consul-payment-service&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/consul&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(INVOKE_URL+<span class="string">&quot;/payment/consul&quot;</span>,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务，可以看到我们的服务启动成功</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321172054874.png" class title="image-20220321172054874"><p>服务调用成功</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321172112721.png" class title="image-20220321172112721"><h3 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。Ribbon是Netflix发布的开源 项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。即在配置文件中列出Load Balancer后面的所有机器，Ribbon会自动帮助你基于某种规则(如简单轮询，随机连接等)去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法。</p><p>引入的Eureka依赖中已经引入了Ribbon因此不需要再额外引入依赖</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321180402840.png" class title="image-20220321180402840"><p>Ribbon支持的负载均衡算法</p><p>com.nextflix.loadbalancer.RoundRobinRule：轮询</p><p>com.netflix.loadbalancer.RandomRule：随机</p><p>com.netflix.loadbalancer.RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务</p><p>weightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择</p><p>bestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务。</p><p>availabilityFilteringRule：会先过滤掉故障实例，再选择并发量最小的实例</p><p>ZoneAvoidanceRule：默认规则，复合判断server所在区域的性能和server的可用性选择服务器</p><p>自定义负载均衡</p><p>首先cloud-consumer-order80项目的cloud目录下创建一个myrule包</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321202427299.png" class title="image-20220321202427299"><p>不创建在cloud包下的原因是自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，就达不到特殊化定制的目的了。</p><p>定义配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">mySelfRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自己指定的负载均衡算法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类上加上@RibbonClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RibbonClient(value=&quot;CLOUD-PAYMENT-SERVICE&quot;,configuration = RuleConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此自定义的负载均衡算法完成。</p><p>测试：调用的服务是随机的，测试成功。</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220321203739337.png" class title="image-20220321203739337"><h4 id="自己实现一个负载均衡算法"><a href="#自己实现一个负载均衡算法" class="headerlink" title="自己实现一个负载均衡算法"></a>自己实现一个负载均衡算法</h4><p>LoadBalancer.java</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public interface LoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    ServiceInstance instances(List&lt;ServiceInstance&gt; serviceInstances);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyLB.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLB</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nextServerIndex=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">instances</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstances)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(serviceInstances.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;======》:当前服务不可用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=getAndIncrement(serviceInstances.size());</span><br><span class="line">        <span class="keyword">return</span> serviceInstances.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">int</span> next;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            current=<span class="keyword">this</span>.nextServerIndex.get();</span><br><span class="line">            next=(current+<span class="number">1</span>)%total;</span><br><span class="line">            <span class="comment">// 自旋锁，保证线程安全</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.nextServerIndex.compareAndSet(current,next));</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在客户端进行调用，记得将Config中的@LoadBalance注解掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/lb&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getLB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;ServiceInstance&gt; instances = <span class="keyword">this</span>.discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(instances==<span class="keyword">null</span>||instances.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ServiceInstance instances1 = loadBalancer.instances(instances);</span><br><span class="line">    URI uri = instances1.getUri();</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(uri+<span class="string">&quot;/payment/lb&quot;</span>,String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220402000246583.png" class title="image-20220402000246583"><h3 id="OpenFeign服务调用"><a href="#OpenFeign服务调用" class="headerlink" title="OpenFeign服务调用"></a>OpenFeign服务调用</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>OpenFeign是一个声明式的web服务客户端，让编写web 服务客户端变的非常容易，只需要创建一个接口并在接口上添加注解即可，openFeign的前身是Feign，但Feign目前已经停止更新了；openFeign是Spring Cloud在Feign的基础上支持了Spring MVC的注解，并通过动态代理的方式产生实现类来做负载均衡并进行调用其它服务。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>相当于在client端创建一个接口，接口中的方法与需要远程调用的服务端所提供的服务接口一一对应。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>首先创建一个cloud-consumer-feign-order80模块(略)</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mjy.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写application.yml配置文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端口号</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="string">http://eureka7001.com:7001/eureka/,http://eureka7002:7002/eureka</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 激活Feign</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个业务逻辑接口，用来调用payment的服务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// value对应的是在注册中心的服务名，一定要写对，Feign还可以定义一个回调(在调用失败时使用)</span></span><br><span class="line"><span class="meta">@FeignClient(value=&quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Controller层进行调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFeignController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.getPaymentById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220413111310666.png" class title="image-20220413111310666"><h4 id="openFeign超时控制"><a href="#openFeign超时控制" class="headerlink" title="openFeign超时控制"></a>openFeign超时控制</h4><p>Feign默认调用服务超过1s客户端会直接报错，但对于一些处理时间比较长的业务，需要客户端与服务端进行协商调用。</p><p>测试（出错的情况）：</p><p>在服务端编写一个接口，让接口的处理时间为3秒</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/feign/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">feignTimeout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serverPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的在Feign定义的调用服务接口中添加该方法并在Controller层对其进行调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(value=&quot;CLOUD-PAYMENT-SERVICE&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/getInfo/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonResult <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/feign/timeout&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">feignTimeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/payment/feign/timeout&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">feignTimeout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> paymentService.feignTimeout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220413113650391.png" class title="image-20220413113650391"><p>设置ribbon的超时时间</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#ribbon的超时时间</span></span><br><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment">#建立连接所用的时间，适用于网络正常的情况下，两端连接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment">#指的是建立连接后从服务器读取到可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConnectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220413115126382.png" class title="image-20220413115126382"><h4 id="OpenFeign日志打印功能"><a href="#OpenFeign日志打印功能" class="headerlink" title="OpenFeign日志打印功能"></a>OpenFeign日志打印功能</h4><p>Feign提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解Feign中Http请求的细节。即对Feign接口的调用情况进行监控和输出。</p><p><strong>日志级别</strong>：</p><ul><li>NONE：默认的，不显示任何日志</li><li>BASIC：仅记录请求方法、URL、响应状态码及执行时间</li><li>HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息</li><li>FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据</li></ul><p><strong>配置日志</strong></p><p>先创建一个Config类，然后再向容器内注入一个Logger.Level</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Logger;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">getLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在application.yml配置文件中进行配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment">#feign日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">com.mjy.cloud.service.PaymentService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><h3 id="Hystrix断路器"><a href="#Hystrix断路器" class="headerlink" title="Hystrix断路器"></a>Hystrix断路器</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p><p><strong>服务降级</strong>：在高并发情况下，防止用户一直等待，使用服务降级方式进行处理(返回友好的提示给客户端，fallback回调方法)。当服务不可用的时候(正在等待的时候、网络延迟、响应时间过长)，客户端会处于一直等待的状态。显然一直等待是不合理的，所以我们应该给客户端返回一个友好的提示，使用fallback(回调方法)进行服务降级处理。</p><p>目的：提高用户体验，防止服务雪崩效应。比如：连接超时、网络延迟、服务器响应时间过长</p><p><strong>服务熔断</strong>：在高并发的情况下，如果达到一定的极限(可以自己设置阈值)，如果流量超出了设置的阈值，然后拒绝访问，保护当前服务。当服务器达到最大的承受能力之后，直接拒绝访问服务，然后调用降级方法，返回友好提示。</p><p>目的：防止服务宕机，会进行熔断处理</p><p><strong>服务限流</strong>：限制服务器能够处理的请求数量</p><p>目的：保护服务，避免服务宕机</p><h4 id="官方学习地址"><a href="#官方学习地址" class="headerlink" title="官方学习地址"></a>官方学习地址</h4><p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>创建一个cloud-provider-hystrix-payment8001模块。</p><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mjy.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署工具--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-hystrix-payment</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure><p>编写启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplication8001.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ackage com.mjy.cloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 13:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;id: &quot;</span>+id+<span class="string">&quot; 调用paymentOk成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeOut=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(timeOut);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;id: &quot;</span>+id+<span class="string">&quot; 执行时间(s):&quot;</span>+timeOut+<span class="string">&quot; 调用paymentTimeOut成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.cloud.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mjy.cloud.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 13:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hystrix&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String res = paymentService.paymentOk(id);</span><br><span class="line">        log.info(<span class="string">&quot;****res:&quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;</span><br><span class="line">        String res = paymentService.paymentTimeOut(id);</span><br><span class="line">        log.info(<span class="string">&quot;****res:&quot;</span>+res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再编写一个openFeign类似的order进行调用测试(略)。</p><h4 id="Hystrix服务降级"><a href="#Hystrix服务降级" class="headerlink" title="Hystrix服务降级"></a>Hystrix服务降级</h4><p>主要是使用@HystrixCommand这个注解进行服务降级后的反馈</p><p><strong>示例</strong>：</p><p><strong>服务端降级</strong></p><p>首先在Service层的方法上添加上@HystrixCommand注解，然后再编写反馈方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.cloud.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 13:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;id: &quot;</span>+id+<span class="string">&quot; 调用paymentOk成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过三秒就算超时，需要进行服务降级</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeoutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;3000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeOut</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> timeOut=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(timeOut);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;id: &quot;</span>+id+<span class="string">&quot; 执行时间(s):&quot;</span>+timeOut+<span class="string">&quot; 调用paymentTimeOut成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeoutHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\tid: &quot;</span>+<span class="string">&quot;服务繁忙或错误，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类上加上@EnableCircuitBreaker注解进行激活hystrix</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 12:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixApplication8001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixApplication8001.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220418183413282.png" class title="image-20220418183413282"><p><strong>客户端降级</strong></p><p>注：热部署方式对Java代码的改动明显，但对@HystrixCommand内属性的修改建议重启微服务</p><p>首先需要配置application.yml</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后在主启动类上加上@EnableHystrix注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.hystrix.EnableHystrix;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 17:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixOrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HystrixOrderApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在对应的方法上使用@HystrixCommand</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mjy.cloud.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 17:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentOk(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeoutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;2000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentTimeout(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeoutHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\tid: &quot;</span>+<span class="string">&quot;服务繁忙或错误，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><img src="/2022/03/16/%E5%BE%AE%E6%9C%8D%E5%8A%A1/image-20220418190340869.png" class title="image-20220418190340869"><p><strong>存在的问题</strong></p><ul><li><p>反馈代码跟业务代码写在一起，代码膨胀</p><p>解决方案：配置一个全局的fallback，一般的方法使用同一个fallback，个别核心重要的可以单独定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mjy.cloud.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-04-18 17:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = &quot;defaultFallback&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;2000&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentOk(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;paymentTimeoutHandler&quot;,commandProperties = &#123;</span></span><br><span class="line"><span class="meta">            @HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value=&quot;2000&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentTimeout(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeoutHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;\tid: &quot;</span>+<span class="string">&quot;服务繁忙或错误，/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultFallback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;同一反馈方法；服务器繁忙或请求超时，请稍后再试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每一个方法都需要一个反馈代码对应，耦合度太高</p><p>解决办法，创建一个反馈方法的类实现调用的service接口，来为每一个service定义的方法定义一个反馈方法。</p><p>示例：</p><p>首先编写一个实现远程调用接口的一个实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderFallback</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeout</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;---OrderFallback：paymentTimeOut 服务调用出错/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;---OrderFallback：paymentOk 服务调用出错/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Feign调用其它服务的接口的@FeignClient上配置fallback参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@FeignClient(value=&quot;CLOUD-PROVIDER-HYSTRIX-PAYMENT&quot;,fallback = OrderFallback.class)</span><br><span class="line">public interface OrderService &#123;</span><br><span class="line">    @GetMapping(&quot;/hystrix/payment/timeout/&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentTimeout(@PathVariable(&quot;id&quot;)Integer id);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/hystrix/payment/ok/&#123;id&#125;&quot;)</span><br><span class="line">    public String paymentOk(@PathVariable(&quot;id&quot;)Integer id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改controller，这里将之前配置的@HystrixCommand先去掉了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/consumer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/ok/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentOk</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentOk(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/payment/timeout/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">paymentTimeout</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.paymentTimeout(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：使用该方法时，需要在application.yml中配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h4><p><strong>熔断机制概述</strong>：熔断机制是应对雪崩效应的一种微服务链路保护机制，当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值时(默认是5秒内20次调用失败)就会启动熔断机制，熔断机制的注解是@HystrixCommand</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized原理</title>
      <link href="/2022/03/05/synchronized%E5%8E%9F%E7%90%86/"/>
      <url>/2022/03/05/synchronized%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h3><ul><li>修饰实例方法：作用于当前实例加锁，进入同步代码块需要获取当前实例的锁</li><li>修饰静态方法：作用于当前类对象加锁，进入同步代码块之前需要获得当前类对象的锁</li><li>修饰代码块：指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁</li></ul><h3 id="synchronized底层语义原理"><a href="#synchronized底层语义原理" class="headerlink" title="synchronized底层语义原理"></a>synchronized底层语义原理</h3><p>Java虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现，无论是显式同步(有明确的monitorenter和monitorexit指令，即同步代码块)还是隐式同步都是如此。在Java中同步用得最多的地方可能是被synchronized修饰的同步方法。同步方法并不是由monitorenter和monitorexit指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的ACC_SYNCHRONIZED标志来隐式实现的。</p><h3 id="对象头与Monitor"><a href="#对象头与Monitor" class="headerlink" title="对象头与Monitor"></a>对象头与Monitor</h3><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充</p><img src="/2022/03/05/synchronized%E5%8E%9F%E7%90%86/image-20220305233921529.png" class title="image-20220305233921529"><p>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节存储。</p><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在，仅仅是为了字节对齐</p><p>Java对象头是实现synchronized的锁对象的基础。一般而言，synchronized使用的锁对象是存在Java对象头中的，JVM中采用两个字节来存储对象头（若对象是数组则会分配三个字节，多出来的一个字节记录的是数组长度），其主要结构是由Mark Word和Class Metadata Address组成，其结构说明如下表：</p><table><thead><tr><th>虚拟机位数</th><th>头对象结构</th><th>说明</th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例</td></tr></tbody></table><p>其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构</p><table><thead><tr><th>锁状态</th><th>25bit</th><th>4bit</th><th>1bit是否是偏向锁</th><th>2bit锁标志位</th></tr></thead><tbody><tr><td>无锁状态</td><td>对象HashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr></tbody></table><p>由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word被设计成为一个非固定数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了以上列出的Mark Word默认存储结构外，还有如下可能变化的结构：</p><img src="/2022/03/05/synchronized%E5%8E%9F%E7%90%86/image-20220306001247464.png" class title="image-20220306001247464"><p>其中偏向锁和轻量级锁是JDK1.6对synchronized锁进行优化后新增加的。synchronized的对象锁，锁标记为10，其中指针指向的是monitor对象(也称为管程或监视器锁)的起始地址。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机中，monitor是由ObjectMonitor实现的，其主要数据结构如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList集合，当线程获取到对象的Monitor后进入_owner区域并把monitor对象中的owner变量设置为当前线程同时monitor的count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count减1，同时该线程进入WaitSet中等待唤醒。若当前线程执行完毕也将释放monitor锁并复位变量的值，以便其它线程进入获取monitor锁</p><img src="/2022/03/05/synchronized%E5%8E%9F%E7%90%86/image-20220306111538998.png" class title="image-20220306111538998"><p>由此可见，monitor对象存在于每个Java对象的对象头(存储的指针的指向)，synchronized锁便是通过这样获取的，这也解释了为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p><h3 id="synchronized代码块底层原理"><a href="#synchronized代码块底层原理" class="headerlink" title="synchronized代码块底层原理"></a>synchronized代码块底层原理</h3><p>定义一个同步代码块</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynCode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用javap -c进行反编译</p><img src="/2022/03/05/synchronized%E5%8E%9F%E7%90%86/image-20220306114145469.png" class title="image-20220306114145469"><p>从字节码中可知同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，线程将尝试获取对象锁所对应的monitor的持有权，当对象锁的monitor的进入计数器为0，那线程就能够成功获取monitor，并将计数器的值设置为1，获取锁成功。若当前线程已经拥有了对象锁的monitor的持有权，那么该线程就可以重入这个monitor，重入时计数器的值也会加1。倘若其它线程已获取到对象锁的monitor的所有权，那当前线程进入阻塞状态等待获取锁，直到执行线程执行完毕，即monitorexit指令被执行，执行完毕的线程将释放monitor并设置计数器的值为0，其它线程将有机会获得锁。编译器会确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都有其对应的的monitorexit指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时monitorentor和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可以处理所有的异常，它的目的就是用来执行monitorexit指令，从字节码中也可以看出多了一个monitorexit，它就是异常结束时被执行释放monitor的指令。</p><h3 id="synchronized方法底层原理"><a href="#synchronized方法底层原理" class="headerlink" title="synchronized方法底层原理"></a>synchronized方法底层原理</h3><p>方法级的同步是隐式，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志区分一个方法是否是同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有monitor，然后再执行方法，最后方法完成释放monitor。在方法执行期间，执行线程持有了monitor，其它任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理异常，那这个同步方法所持有的monitor将在异常抛到同步方法外时自动释放。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">           i++;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javap -verbose反编译后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classfile /D:/JavaLearn/project/java-preview/code-preview/src/main/java/com/mjy/juc/syn/SynCode.class</span><br><span class="line">  Last modified 2022-3-6; size 298 bytes</span><br><span class="line">  MD5 checksum 2f74f430eaf49dbbb2f7a123134a332a</span><br><span class="line">  Compiled from &quot;SynCode.java&quot;</span><br><span class="line">public class com.mjy.juc.syn.SynCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#14         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#15         // com/mjy/juc/syn/SynCode.i:I</span><br><span class="line">   #3 = Class              #16            // com/mjy/juc/syn/SynCode</span><br><span class="line">   #4 = Class              #17            // java/lang/Object</span><br><span class="line">   #5 = Utf8               i</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               add</span><br><span class="line">  #12 = Utf8               SourceFile</span><br><span class="line">  #13 = Utf8               SynCode.java</span><br><span class="line">  #14 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #15 = NameAndType        #5:#6          // i:I</span><br><span class="line">  #16 = Utf8               com/mjy/juc/syn/SynCode</span><br><span class="line">  #17 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.mjy.juc.syn.SynCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_0</span><br><span class="line">         6: putfield      #2                  // Field i:I</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 4</span><br><span class="line"></span><br><span class="line">  public synchronized void add();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: getfield      #2                  // Field i:I</span><br><span class="line">         5: iconst_1</span><br><span class="line">         6: iadd</span><br><span class="line">         7: putfield      #2                  // Field i:I</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">        line 12: 10</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;SynCode.java&quot;</span><br></pre></td></tr></table></figure><p>从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，代替它们的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该标识来确认一个方法是否是同步方法，从而执行相应的同步调用。</p><p>synchronized重量级锁早期版本效率低下的原因：监视器锁(monitor)是依赖于底层的操作系统的Mutex Lock实现的，而操作系统实现进程间的切换时需要从用户态切换到内核态，这个状态之间的切换需要相对比较长的时间。</p><p>但Java6之后官方从JVM层面对synchronized进行了优化，使得现在的synchronized的效率也很不错。</p><h3 id="Java虚拟机对synchronized的锁优化"><a href="#Java虚拟机对synchronized的锁优化" class="headerlink" title="Java虚拟机对synchronized的锁优化"></a>Java虚拟机对synchronized的锁优化</h3><p>锁的状态：无锁状态、偏向锁、轻量级锁和重量级锁</p><p>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再由轻量级锁升级为重量级锁。</p><p>锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。但Java中锁的降级是存在的</p><p>例：读写锁降级，线程在持有写锁的情况下，请求读锁，然后释放写锁可以达到锁降级的目的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是Java6之后加入的新锁，它是一种针对加锁操作的优化手段。在大多数情况下，锁不仅不存在锁竞争，而且总是总是由一个线程多次获得，因此为了减少同一线程获取锁(会涉及一些CAS操作耗时)的代价而引入了偏向锁。</p><p>偏向锁的核心思想：一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，就可以获取锁。</p><p>对于没有锁竞争的场合，偏向锁有很好的优化效果，因为可能多次获取该锁的是同一个线程。但是再锁竞争激烈的情况下，偏向锁就失效了，因为这种场合下极有可能每次获得锁的线程都不同，因此不适合使用偏向锁。需要将偏向锁升级为轻量级锁。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是JDK1.6加入的优化手段，此时Mark Word的结构也变为轻量级锁结构，轻量级锁能够提升程序性能的依据是“对绝大部分锁，在整个同步周期不存在竞争”。轻量级锁所适应的情况是线程交替执行同步块的场景，若有两个及以上的线程同时竞争锁，则需要升级为重量级锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>轻量级锁获取锁失败后，为了避免线程进入阻塞状态，还会进行一项称为自旋锁的优化操作，因为线程进入阻塞状态后，进行线程间切换需要从用户态切换到内核态，这个状态间的切换需要相对比较长的一段时间，开销较大。因此自旋锁会尝试使线程进入忙循环获取锁，若在这段时间内获取到了锁，则可以进入同步代码块，若未能获得锁，则只能升级为重量级锁。</p><p>自旋锁只适合线程持有锁时间较短的场景，自旋锁虽然能够减少线程进行阻塞的开销，但是忙循环会占用CPU，若忙循环太久也会影响性能。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>Java虚拟机在JIT(某段代码即将第一次被执行时进行编译，又称为即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码实现读写分离</title>
      <link href="/2022/01/20/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2022/01/20/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p>首先定义一个数据源注解，它有两个值，一个对应（写库），一个对应读库（从库）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20 16:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DataSource &#123;</span><br><span class="line">    String DATA_SOURCE_READ=<span class="string">&quot;dataSourceRead&quot;</span>;</span><br><span class="line">    String DATA_SOURCE_WRITE=<span class="string">&quot;dataSourceWrite&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;dataSourceWrite&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在需要拦截的地方加上注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DataSource(name=DataSource.DATA_SOURCE_READ)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.getUserNum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DataSource(name=DataSource.DATA_SOURCE_WRITE)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中加上aop切面配置</p><p>spring-service.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:p=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--扫描service的包--&gt;</span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.mjy.spring.service&quot;</span>&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSourceExchange&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.spring.ds.DataSourceExchange&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">&quot;dataSourceExchange&quot;</span>&gt;</span><br><span class="line">            &lt;aop:around method=<span class="string">&quot;execute&quot;</span> pointcut=<span class="string">&quot;within(com.mjy.spring.service.impl.*)&quot;</span>&gt;&lt;/aop:around&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>然后在切面类里，获取方法上的dataSource注解里面设置的值，从而决定使用哪个数据源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.spring.ds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mjy.spring.beanlife.annotation.DataSource;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.Signature;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20 17:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceExchange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger= LoggerFactory.getLogger(DataSourceExchange.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;DataSourceExchange==&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object obj=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Signature signature = pjp.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method targetMethod = methodSignature.getMethod();</span><br><span class="line">        Method realMethod=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            realMethod=pjp.getTarget().getClass().getDeclaredMethod(signature.getName(),targetMethod.getParameterTypes());</span><br><span class="line">            <span class="keyword">if</span>(realMethod.isAnnotationPresent(DataSource.class))&#123;</span><br><span class="line">                DataSource annotation = realMethod.getAnnotation(DataSource.class);</span><br><span class="line">                DataContext.setDbType(annotation.name());</span><br><span class="line">                logger.info(realMethod.getName()+<span class="string">&quot; set dbType==&gt;&quot;</span>+annotation.name());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                DataContext.setDbType(DataContext.DATA_SOURCE_WRITE);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            obj=pjp.proceed();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(realMethod.getName()+<span class="string">&quot; clear dbType&quot;</span>);</span><br><span class="line">        DataContext.clearDbType();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法执行前，设置具体的数据源，然后方法执行完以后，再清除掉该值</p><p>注：注意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Signature signature = pjp.getSignature();</span><br><span class="line">MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">Method targetMethod = methodSignature.getMethod();</span><br></pre></td></tr></table></figure><p>通过这种方法获取的method，它是没有注解信息的。这种方法获取的是代理方法，不是目标方法，代理方法是不带注解信息的。</p><p>定义DataContext类，设置数据源上下文</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE_READ=<span class="string">&quot;dataSourceRead&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA_SOURCE_WRITE=<span class="string">&quot;dataSourceWrite&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; contextHolder=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDbType</span><span class="params">(String dbType)</span></span>&#123;</span><br><span class="line">        contextHolder.set(dbType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDbType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String)contextHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDbType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        contextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义MultipleDataSource类，继承与Spring的AbstractRoutingDataSource类，并重写它的determineCurrentLookupKey方法，作用就是从上下文获取当前线程使用的数据源标识</p><p>spring提供了AbstractRoutingDataSource根据用户定义的规则选择当前的数据源，这样我们可以在执行查询之前，设置使用的数据源。实现可动态路由的数据源，在每次数据库查询操作前执行。它的抽象方法determineCurrentLookupKey()决定使用哪个数据源。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.spring.ds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-01-20 21:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultipleDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MultipleDataSource.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String dbType = DataContext.getDbType();</span><br><span class="line">        <span class="keyword">if</span>(dbType!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前线程使用的数据源标识为[&quot;</span>+dbType+<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dbType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置数据源</p><p>spring-dao.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--包扫瞄--&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--加载配置文件--&gt;</span><br><span class="line">     &lt;context:property-placeholder location=<span class="string">&quot;classpath:*.properties&quot;</span>&gt;&lt;/context:property-placeholder&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;!--数据库连接池--&gt;</span><br><span class="line">     &lt;bean id=<span class="string">&quot;dataSourceWrite&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;url.write&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;username.write&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;password.write&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;maxActive&quot;</span> value=<span class="string">&quot;10&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;minIdle&quot;</span> value=<span class="string">&quot;5&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">     &lt;bean id=<span class="string">&quot;dataSourceRead&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> destroy-method=<span class="string">&quot;close&quot;</span>&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;url.read&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;username.read&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;password.read&#125;&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;maxActive&quot;</span> value=<span class="string">&quot;10&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;minIdle&quot;</span> value=<span class="string">&quot;5&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">     &lt;bean id=<span class="string">&quot;multipleDataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.spring.ds.MultipleDataSource&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">          &lt;property name=<span class="string">&quot;defaultTargetDataSource&quot;</span> ref=<span class="string">&quot;dataSourceWrite&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;targetDataSources&quot;</span>&gt;</span><br><span class="line">               &lt;map&gt;</span><br><span class="line">                    &lt;entry key=<span class="string">&quot;dataSourceWrite&quot;</span> value-ref=<span class="string">&quot;dataSourceWrite&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">                    &lt;entry key=<span class="string">&quot;dataSourceRead&quot;</span> value-ref=<span class="string">&quot;dataSourceRead&quot;</span>&gt;&lt;/entry&gt;</span><br><span class="line">               &lt;/map&gt;</span><br><span class="line">          &lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--sqlSessionFactory--&gt;</span><br><span class="line">     &lt;bean id=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br><span class="line">          &lt;!--注入dataSource--&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;multipleDataSource&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;mapperLocations&quot;</span> value=<span class="string">&quot;classpath*:com/mjy/spring/mapper/xml/*.xml&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!--配置Dao接口扫描包，动态的实现了Dao接口可以注入到Spring容器中--&gt;</span><br><span class="line">     &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br><span class="line">          &lt;!--注入sqlSessionFactory--&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> value=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">          &lt;!--扫描要扫描的包--&gt;</span><br><span class="line">          &lt;property name=<span class="string">&quot;basePackage&quot;</span> value=<span class="string">&quot;com.mjy.spring.mapper&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">     &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>至此与spring相关的配置基本就配完了，还需要配置一下mysql的主从复制。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java线程池</title>
      <link href="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h4><p>ThreadPoolExecutor是JDK中的线程池实现的，这个类实现了一个线程池需要的各个方法，它提供了任务提交、线程管理、监控等方法。</p><p>ThreadPoolExecutor类的构造方法源码，其他创建线程池的方法最终都会导向这个构造方法，共有7个参数：corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、ThreadFactory、handler</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些参数都通过volatile修饰</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line">    <span class="comment">// 是否允许核心线程被回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h4><p><strong>corePoolSize:核心线程数</strong></p><p>线程池维护的最小线程数量，核心线程创建后不会被回收（若设置allowCoreThreadTimeout=true，当核心线程空闲时间超过存活时间后，也会被回收）</p><p>大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。</p><p>线程池刚创建时，里面没有一个线程，当调用execute()方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新的线程并运行这个任务</p><p><strong>maximumPoolSize:最大线程数</strong></p><p>线程池允许创建的最大线程数量</p><p>当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。</p><p><strong>keepAliveTime:空闲线程存活时间</strong></p><p>当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收</p><p>可被回收的线程：</p><ul><li>设置allowCoreThreadTimeout=true</li><li>大于核心线程数的线程（非核心线程）</li></ul><p><strong>unit:时间单位</strong></p><p>keepAliveTime的时间单位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TimeUnit.NANOSECONDS</span><br><span class="line">TimeUnit.MICROSECONDS</span><br><span class="line">TimeUnit.MILLISECONDS // 毫秒</span><br><span class="line">TimeUnit.SECONDS</span><br><span class="line">TimeUnit.MINUTES</span><br><span class="line">TimeUnit.HOURS</span><br><span class="line">TimeUnit.DAYS</span><br></pre></td></tr></table></figure><p><strong>workQueue:工作队列</strong></p><p>存放待执行的任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就放在工作队列，任务调度时再从队列中取出来。它仅仅用来存放被execute()方法提交的Runnable任务。工作队列实现了BlockingQueue接口</p><p>JDK默认的工作队列：</p><ul><li>ArrayBlockingQueue(数组型阻塞队列)：数组结构，初始化传入大小，有界、FIFO，使用一个重入锁，默认使用非公平锁，入队和出队共用一个锁，互斥</li><li>LinkedBlockingQueue(链表型阻塞队列)：链表结构，默认初始化大小为Integer.MAX_VALUE，有界、FIFO，使用两个重入锁分别控制元素的入队和出队，用Condition进行线程间的唤醒和等待。</li><li>SynchronousQueue同步队列：容量为0，添加任务必须等待取出任务，这个队列相当于通道，不存储元素。‘</li><li>PriorityBlockingQueue优先阻塞队列：无界，默认采用元素自然顺序升序排列</li><li>DelayQueue延时队列：无界，元素有过期时间，过期的元素才能被取出。</li></ul><p><strong>threadFactory:线程工厂</strong></p><p>创建线程的工厂，可以设定线程名，线程编号</p><p>默认线程工厂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"> </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>handler：拒绝策略</strong></p><p>当线程池线程数已满，并且工作队列数量也达到限制，新提交的任务使用拒绝策略处理。可以自定义拒绝策略，拒绝策略需要实现RejectedExecutionHandler接口</p><p>JDK默认的拒绝策略有四种：</p><ul><li>AbortPolicy：丢弃任务并抛出RejectedExecutionException异常</li><li>DiscardPolicy：丢弃任务，但是不抛出异常。可以导致无法发现系统的异常状态</li><li>DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务</li><li>CallerRunsPolicy:由调用线程处理该任务</li></ul><p>默认拒绝策略</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default rejected execution handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><img src="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220120162431200.png" class title="image-20220120162431200"><p>自定义线程池工具</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">createFixedThreadPool</span><span class="params">(String threadName)</span></span>&#123;</span><br><span class="line">        AtomicInteger threadNumber=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="comment">// 核心线程数</span></span><br><span class="line">                desiredThreadNum(),</span><br><span class="line">                <span class="comment">// 最大线程数</span></span><br><span class="line">                desiredThreadNum(),</span><br><span class="line">                <span class="comment">// 空闲线程存活时间</span></span><br><span class="line">                <span class="number">60L</span>,</span><br><span class="line">                <span class="comment">// 空闲线程存活时间的单位</span></span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="comment">// 工作队列</span></span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1024</span>),</span><br><span class="line">                <span class="comment">// 线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, threadName + <span class="string">&quot;-&quot;</span> + threadNumber.getAndIncrement());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 拒绝策略</span></span><br><span class="line">                <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!executor.isShutdown())&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 尝试阻塞加入任务队列</span></span><br><span class="line">                                executor.getQueue().put(r);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// 保持当前线程的中断状态</span></span><br><span class="line">                                Thread.currentThread().interrupt();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理想的线程数，使用两倍cpu核心数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">desiredThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().availableProcessors()*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="创建线程池的方式"><a href="#创建线程池的方式" class="headerlink" title="创建线程池的方式"></a>创建线程池的方式</h4><p>创建线程池最好不要使用Executors去创建，而是通过ThreadPoolExecutor的方式创建，通过这样子的创建方式，能够更加清除线程池的运行规则，可以尽量避免内存溢出的情况。</p><h4 id="Executors创建线程池的缺点"><a href="#Executors创建线程池的缺点" class="headerlink" title="Executors创建线程池的缺点"></a>Executors创建线程池的缺点</h4><ul><li><p>newFixedThreadPool：返回一个固定线程池数量的线程池，线程数量自定义。该方法创建的线程池最大线程数量等于核心线程数量。如果新提交的任务没有空闲的线程去处理，就会被放入阻塞队列中。</p><p>缺点：该线程池使用的阻塞队列是LinkedBlockingQueue：链表阻塞队列，默认容量为Integer.MAX_VALUE，容量过大，可能会堆积大量任务，导致OOM</p><img src="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220306235129705.png" class title="image-20220306235129705"></li><li><p>newSingleThreadExecutor：该方法创建了只有一个线程的线程池，如果提交的任务没有空闲线程处理就会放入阻塞队列中</p><p>缺点：该线程池使用的阻塞队列是LinkedBlockingQueue：链表阻塞队列，默认容量为Integer.MAX_VALUE，容量过大，可能会堆积大量任务，从而造成OOM</p><img src="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220306235611136.png" class title="image-20220306235611136"></li><li><p>newCachedThreadPool：该方法返回一个可根据实际需求调整线程数量的线程池。如果提交的任务没有空闲的线程处理，就会创建新的线程去处理该任务，如果有线程空闲时间超过60秒就会被销毁。</p><p>缺点：该线程池允许创建的最大线程数为Integer.MAX_VALUE，可能会创建出大量线程，导致OOM。</p><img src="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220307000201873.png" class title="image-20220307000201873"></li><li><p>newScheduleThreadPool：该方法可以创建自定义大小核心线程容量的线程池，而且该线程池支持定时以及周期性的任务执行。</p><p>缺点：该线程池允许创建的最大线程数量为Interger.MAX_VALUE，可能会创建大量线程，导致OOM</p><img src="/2022/01/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20220307000643719.png" class title="image-20220307000643719"></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL复习</title>
      <link href="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/"/>
      <url>/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL的基础架构"><a href="#MySQL的基础架构" class="headerlink" title="MySQL的基础架构"></a>MySQL的基础架构</h3><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220112104351166.png" class title="image-20220112104351166"><p>简单来说MySQL主要分为Server层和存储引擎层：</p><ul><li>Server层主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图、函数等，还有一个通用的日志模块binglog模块</li><li>存储引擎：主要负责数据的存储和读取，采用可替换的插件式架构，支持InnoDB、MyISAM、Memory等多个存储引擎，其中InnoDB引擎有自己的日志模块redolog模块。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始就被当做默认存储引擎</li></ul><p>对于更新等语句执行流程如下：分析器-&gt;权限校验-&gt;执行器-&gt;存储引擎-&gt;redo log prepare-&gt;binlog-&gt;redo log commit</p><h4 id="为什么需要两个日志模块？-基于InnoDB"><a href="#为什么需要两个日志模块？-基于InnoDB" class="headerlink" title="为什么需要两个日志模块？(基于InnoDB)"></a>为什么需要两个日志模块？(基于InnoDB)</h4><p>InnoDB拥有自己的日志模块redo log，其它存储引擎都没有，这就会导致没有crash-safe的能力(crash-safe的能力即时数据库发生异常重启，之前提交的记录都不会丢失)，binlog日志只能用来归档。</p><p>InnoDB就是通过redo log来支持事务的。当我们向数据库写入和修改数据时，InnoDB引擎会把数据保存在内存中，同时记录redo log，此时redo log进入prepare状态，然后告诉执行器，执行完成了，随时可以提交。执行器收到通知后记录binlog，然后调用引擎接口，提交redo log为提交状态。</p><h4 id="redo-log要引入prepare预提交状态原因"><a href="#redo-log要引入prepare预提交状态原因" class="headerlink" title="redo log要引入prepare预提交状态原因"></a>redo log要引入prepare预提交状态原因</h4><p>通过反证法来证明：</p><ul><li>若先写redo log直接提交，然后写binlog，假设写完redo log，机器挂了，binlog日志没有被写入，那么机器重启后，这台机器会通过redo log恢复数据，但binlog中并未记录该数据，后续进行数据备份时，就会丢失这条数据，同时主从同步也会丢失一条数据</li><li>若先写binlog，然后写redo log，假设写完binlog，机器重启了，由于redo log里没有该数据，所以本机是无法恢复该数据的，同样会造成数据不一致的问题</li></ul><p>若采用redo log两阶段提交的方式就不一样了，写完binlog后，然后再提交redo log就会避免上述问题，能够保证数据的一致性。<strong>若redo log处于预提交状态，binlog也已经写完了，这个时候发生了异常重启会怎么样？</strong></p><p>这需要依赖于MySQL的处理机制，MySQL的处理过程如下：</p><ul><li>判断redo log是否完整，如果判断是完整的就立即提交</li><li>如果redo log只是预提交但不是commit状态，这个时候就会去判断binlog是否完整，如果完整就提交redo log，不完整就会回滚事务。</li></ul><h3 id="Mysql基本数据类型"><a href="#Mysql基本数据类型" class="headerlink" title="Mysql基本数据类型"></a>Mysql基本数据类型</h3><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>数据类型</th><th>字节数</th><th>带符号最小值</th><th>带符号最大值</th><th>不带符号最小值</th><th>不带符号最大值</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128</td><td>127</td><td>0</td><td>255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768</td><td>32767</td><td>0</td><td>65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608</td><td>8388607</td><td>0</td><td>16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648</td><td>2147483647</td><td>0</td><td>4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808</td><td>9223372036854775807</td><td>0</td><td></td></tr></tbody></table><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><table><thead><tr><th>数据类型</th><th>字节数</th><th>备注</th></tr></thead><tbody><tr><td>float</td><td>4</td><td>单精度浮点型</td></tr><tr><td>double</td><td>8</td><td>双精度浮点型</td></tr></tbody></table><p>存在精度丢失的问题，写入数据库的数据未必是插入数据库的数据，可能存的是近似值</p><h4 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h4><p>Decimal(M,D)：不存在精度丢失的问题，常用于银行、互联网金融等对小数点后的数字比较敏感的系统中。</p><p>Decimal是以字符串形式进行存储的。</p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><table><thead><tr><th>数据类型</th><th>字节数</th><th>格式</th><th>备注</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>yyyy-MM-dd</td><td>存储日期值</td></tr><tr><td>time</td><td>3</td><td>HH:mm:ss</td><td>存储时分秒</td></tr><tr><td>year</td><td>1</td><td>yyyy</td><td>存储年</td></tr><tr><td>datetime</td><td>8</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间</td></tr><tr><td>timestamp</td><td>4</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间，可作时间戳</td></tr></tbody></table><p>datetime与timestamp两种类型的区别：</p><ul><li>datetime占8个字节，timestamp占4个字节</li><li>datetime能存储的时间范围为000-01-01 00:00:00——9999-12-31 23:59:59，timestamp存储的时间范围为19700101080001——20380119111407</li><li>datetime值默认为空，当插入值为null时，该列的值就是null;timestamp默认值不为空，当插入值为null时，mysql会取当前时间。</li><li>datetime存储的时间与时区无关，timestamp存储的时间及显示的时间都依赖于当前时区。</li></ul><h4 id="char类型和varchar类型"><a href="#char类型和varchar类型" class="headerlink" title="char类型和varchar类型"></a>char类型和varchar类型</h4><ul><li>char是固定长度字符串，其长度范围为0~255且与编码方式无关，无论字符实际长度是多少，都会按照指定长度进行存储，不够的用空格补上</li><li>char实际占用的字节数即存储的字符所占用的字节数，varchar实际占用的字节数为存储的字符+1或+2或+3</li><li>mysql在处理char类型时会将结尾的所有空格处理掉而varchar类型数据则不会</li></ul><h4 id="text和blob"><a href="#text和blob" class="headerlink" title="text和blob"></a>text和blob</h4><p>这两种类型的设计初衷就算为了存储大数据使用的，Mysql单行最大数据为64k。</p><p>text和varchar是一组既有区别也有联系的数据类型，其联系在于<strong>当varchar(M)的M大于某些数值时，varchar会自动转化为text</strong></p><ul><li>M&gt;255时转为tinytext</li><li>M&gt;500时转为text</li><li>M&gt;20000时转为mediumtext</li></ul><p>所以过大的内容varchar和text没有区别，varchar(M)和text的区别在于：</p><ul><li>单行64k即65535字节的空间，varchar只能用63352/65533字节，但是text可以65535个字节全部用起来</li><li>text可以指定text(M)，但M无论等于多少都没有影响</li><li>text不允许有默认值，varchar允许有默认值</li></ul><p>varchar和text两种数据类型，使用建议是能用varchar就用varchar而不用text（存储效率高），varchar(M)的M有长度限制，如果大于限制，可以使用mediumtext(16M)或longtext(4G)</p><p>text存储的是字符串而blob存储的是二进制字符串，简单说blob是用于存储例如图片、音视频这种文件的二进制数据的。</p><h3 id="Mysql语法"><a href="#Mysql语法" class="headerlink" title="Mysql语法"></a>Mysql语法</h3><h4 id="mysql基本sql语句"><a href="#mysql基本sql语句" class="headerlink" title="mysql基本sql语句"></a>mysql基本sql语句</h4><p><strong>表注释语句</strong></p><p>创建表的时候写注释（包含表注释和字段注释）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `test1` ( </span><br><span class="line">    `field_name` <span class="type">int</span> comment <span class="string">&#x27;字段的注释&#x27;</span> </span><br><span class="line">)comment<span class="operator">=</span><span class="string">&#x27;表的注释&#x27;</span>;</span><br></pre></td></tr></table></figure><p>修改表的注释</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;test1&#x27;</span> comment <span class="string">&#x27;修改后的表的注释&#x27;</span>;</span><br></pre></td></tr></table></figure><p>修改字段注释，此时的字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;test1&#x27;</span> modify <span class="keyword">column</span> <span class="string">&#x27;field_name&#x27;</span> <span class="type">int</span> comment <span class="string">&#x27;修改后的字段注释&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>表添加字段</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;tb_name&#x27;</span> <span class="keyword">add</span> <span class="string">&#x27;file_name&#x27;</span> <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> comment <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>表修改字段</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;tb_name&#x27;</span> change <span class="string">&#x27;old_id&#x27;</span> <span class="string">&#x27;new_id&#x27;</span> <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>索引相关语句</strong></p><p>alter table用来创建普通索引、UNIQUE索引或primary key索引</p><p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，alter table允许在单个语句中更改多个表，因此可以同时创建多个索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">add</span> index index_name (column_list);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">add</span> <span class="keyword">unique</span> (column_list);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">add</span> <span class="keyword">primary</span> key(column_list);</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">drop</span> index index_name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">&#x27;table_name&#x27;</span> <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure><h4 id="MySQL变量"><a href="#MySQL变量" class="headerlink" title="MySQL变量"></a>MySQL变量</h4><p>MySQL的变量分为以下两种：</p><ul><li>系统变量：配置MySQL服务器的运行环境，可以用show variables查看</li><li>状态变量：监控MySQL服务器的运行状态，可以用show status查看</li></ul><h5 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h5><p>系统变量按其作用域的不同可以分为以下两种：</p><ul><li>分为全局(GLOBAL)级：对整个MySQL服务器有效</li><li>会话(SESSION或LOCAL)级：只影响当前会话</li></ul><p>有些变量同时拥有以上两个级别，MySQL将在建立连接时用全局变量初始化会话级变量，但一旦建立连接之后，全局级变量的改变不会影响到会话级变量。</p><p>查看系统变量的值</p><ul><li><p>可以通过show variables语句查看系统变量的值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log%&#x27;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">where</span> Variable_name <span class="keyword">like</span> <span class="string">&#x27;log%&#x27;</span> <span class="keyword">and</span> <span class="keyword">value</span><span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure><p>注：show variables优先显示会话级变量的值，如果这个值不存在，则显示全局级变量的值，当然你也可以加上GLOBAL或SESSION关键字区别</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables;</span><br><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">local</span> variables;</span><br></pre></td></tr></table></figure></li><li><p>也可以通过从INFORMATION_SCHEMA里的GLOBAL_VARIABLES和SESSION_VARIABLES表获得</p></li></ul><p><strong>设置和修改系统变量的值</strong></p><ul><li><p>在MySQL服务器启动前，可以通过两种方法设置系统变量的值</p><ul><li>命令行参数，如：mysqld–max_connections=200</li><li>选项文件(my.cnf)</li></ul></li><li><p>在MySQL服务器启动后，如果需要修改系统变量的值，可以通过SET语句</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> global var_name=value</span><br><span class="line"><span class="built_in">set</span> @@GLOBAL.var_name=value</span><br><span class="line"><span class="built_in">set</span> SESSION var_name=value</span><br><span class="line"><span class="built_in">set</span> @@SESSION.var_name=value</span><br></pre></td></tr></table></figure><p>注：若在变量名前没有级别限定符，表示修改会话级变量</p></li></ul><p>单纯使用show variables的话就等同于使用的是show session variables，查询的是会话变量，只有使用show global variables，查询的才是全局变量。</p><h5 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h5><p>状态变量可以使我们即时了解MySQL服务器的运行状况，可以使用show status语句查看。</p><p>状态变量和相同变量类似，也分为全局级和会话级，show status也支持like匹配查询，比较大的不同是状态变量只能由MySQL服务器本身设置和修改，对用户来说是只读的</p><h3 id="数据库的垂直切分与水平切分"><a href="#数据库的垂直切分与水平切分" class="headerlink" title="数据库的垂直切分与水平切分"></a>数据库的垂直切分与水平切分</h3><p>拆分数据库的顺序：先水平切分，然后再垂直切分</p><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>水平切分：按照某个字段的某种规则，把数据切分到多张数据表。一张数据表化整为零，拆分成多张数据表，这样就可以起到缩表的作用。</p><p>水平切分出的数据表并非必须存储到不同的MySQL的节点上，其实水平切分出来的数据表也可以保存在一个MySQL节点上。不是水平切分一定需要多个MySQL节点。</p><p>MySQL自带一种数据分区的技术，可以把一张表的数据，按照特殊规则，切分存储到不同的目录下。如果我们给Linux主机挂载了多块硬盘，我们完全可以利用MySQL分区技术，把一张表的数据切分存储到多个硬盘上。这样就由原来的一块硬盘有限的IO能力，升级成了多个磁盘增强型的IO</p><h5 id="水平切分的用途"><a href="#水平切分的用途" class="headerlink" title="水平切分的用途"></a>水平切分的用途</h5><p>水平切分可以把数据切分到多张数据表，可以起到缩表的作用。</p><h5 id="水平切分的缺点"><a href="#水平切分的缺点" class="headerlink" title="水平切分的缺点"></a>水平切分的缺点</h5><ul><li><p>不同数据表的切分规则并不一致，要根据实际业务来确定。所以我们在选择数据库中间件产品的时候，就要选择切分规则丰富的产品。常见的数据库中间件有：Mycat、Atlas、ProxySQL</p></li><li><p>扩容比较麻烦，日积月累，分片迟早有不够用的时候。这时候不是首先选择增加新的集群分片。因为一个MySQL分片需要4-8个MySQL节点（最小规模），增加一个分片的投入成本是很高的。正确的做法是冷热数据分离，定期对分片中的数据进行归档。把过期的业务数据，从分片转移到归档库。目前来说数据压缩比最高的MySQL引擎是TokuDB，而且带事务的写入速度是InnoDB的6-14倍。用TokuDB作为归档数据库最合适不过</p></li></ul><h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其它数据库</p><h5 id="垂直切分的用途"><a href="#垂直切分的用途" class="headerlink" title="垂直切分的用途"></a>垂直切分的用途</h5><p>垂直切分可以降低单节点数据库的负载。原来所有的数据表都放在一个数据库节点中，无疑所有的读写请求也都发送到这个MySQL上，数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效降低每个MySQL数据库的负载。</p><h5 id="垂直切分的缺点"><a href="#垂直切分的缺点" class="headerlink" title="垂直切分的缺点"></a>垂直切分的缺点</h5><p>垂直切分不能解决缩表的问题，因为无论拆分成多少个数据库，数据表中的数据还是那么多，MySQL单表记录超过2000万，读写性能会下降得很快。</p><h4 id="为什么先做水平切分后做垂直切分"><a href="#为什么先做水平切分后做垂直切分" class="headerlink" title="为什么先做水平切分后做垂直切分"></a>为什么先做水平切分后做垂直切分</h4><p>随着数据量的增加，最先应该做的是数据分片，利用多块磁盘来增大数据IO能力和存储空间，这么做是成本最低的。</p><p>若数据量继续增大，则进入下一个阶段，我们应该把数据切分到多个MySQL节点上，用Mycat管理数据切分。当然还要做数据的读写分离。在后台做水平切分的同时，业务系统也可以引入负载均衡、分布式架构等，理论上，使用了冷热数据分离之后，水平切分这种方式还可以继续持续很久，数据量再大也不怕，定期归档就行。</p><p>数据库到了水平切分的阶段，数据量的增加已经不是更改架构的主要原因了。反而是这个阶段业务系统承受不住了，如果再不对系统做模块拆分，业务系统也支撑不下去了，所以按照模块和业务，把一个系统拆分成若干子系统。若干子系统之间，数据相对独立。</p><h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>概念：脏读就是B事务读到了A事务尚未提交的数据</p><p>示例：</p><p>将隔离级别设为read-uncommitted</p><p>查看隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220120225418626.png" class title="image-20220120225418626"><p>开启事务</p><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220120225533394.png" class title="image-20220120225533394"><p>在左边这个客户端，tom给lucy转钱1000，所以需要下面两个update语句，此时还未commit</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="number">-1000</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">update account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="operator">+</span><span class="number">1000</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;lucy&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220120230021665.png" class title="image-20220120230021665"><p>从结果可以看到，我们可以看到还未提交的数据，这样就会造成一个问题，若此时tom给lucy打电话，告诉他钱已经转过去了，然后lucy也查询了钱数，发现钱确实到了，于是说好，但是此时如果tom那边的服务出了问题rollback了一下，这样lucy的钱就会变成3500，这样lucy就亏了。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>一个事务中两次读取的数据的内容不一致就叫做不可重复读。</p><p>解决办法：将隔离级别设置为repeat-read</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>一个事务中两次读取的数据的数量不一致。</p><h4 id="事务的ACID"><a href="#事务的ACID" class="headerlink" title="事务的ACID"></a>事务的ACID</h4><p><strong>原子性（Atomicity）</strong></p><p>概念：事务是不可分割的，指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p>mysql里面一个sql语句默认也是一个事务。</p><p><strong>一致性（Consistency）</strong></p><p>保证数据在事务的执行周期内是一致的。</p><p><strong>隔离性（Isolation）</strong></p><p>事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离。</p><p><strong>持久性（Durability）</strong></p><p>事务一旦被提交，就不可能再回滚。即一个事务一旦被提交，它对数据库中的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="B-树原理"><a href="#B-树原理" class="headerlink" title="B+树原理"></a>B+树原理</h4><p>数据结构：</p><p>B Tree指的是Banlance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。B+ Tree是基于B Tree和叶子节点顺序访问指针进行实现，它具有B Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在B+ Tree中，一个节点中的key从左到右非递减排序，如果某个指针的左右相邻key分别是keyi和keyi+1，且不为null，则该指针指向节点的所有key大于等于$key_i$且小于等于$key_{i+1}$</p><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220121101358711.png" class title="image-20220121101358711"><p><strong>操作</strong></p><p>进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。</p><p>插入删除操作会破环平衡树的平衡性，因此在进行插入删除操作之后需要对树进行分裂，合并、旋转等操作来维护平衡性。</p><p><strong>与红黑树的比较</strong></p><p>红黑树等平衡树也可以用来实现索引，但是文件系统即数据库系统普遍采用B+ Tree作为索引结构，这是因为使用B+树访问磁盘数据有更高的性能。</p><ol><li><p>B+树有更低的树高</p><p>平衡树的树高O(h)=O($log_d{N}$),其中d为每个节点的出度。红黑树的出度为2，而B+树的出度一般都非常大，所以红黑树的树高比B+树高得多</p></li><li><p>磁盘访问原理</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。</p><p>如果数据不在同一个磁盘上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+树相对于红黑树有更低树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+树更适合磁盘数据的读取</p></li><li><p>磁盘预读特性</p><p>为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快，并且可以利用预读特性，相邻的节点也能够被预先载入。</p></li></ol><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h5><p>B+树索引是大多数MySQL存储引擎的默认存储类型。因为不需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为B+ Tree的有序性，所以除了用于查找，还可以用来排序和分组，可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序查找，则无法使用索引。</p><p>InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据存储在两个不同的地方，所以一个表只能有一个聚簇索引。</p><img src="/2022/01/12/MySQL%E5%A4%8D%E4%B9%A0/image-20220121120721442.png" class title="image-20220121120721442"><p>辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引的时候，需要先查找主键的值，再根据主键的值进行查找数据。</p><p>哈希索引</p><p>哈希索引能以O(1)时间进行查找，但是失去了有序性</p><ul><li>无法用于排序与分组</li><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><p>InnoDB存储引擎有一个特殊的功能叫做“自适应哈希索引”，当某个索引被使用的非常频繁时，会在B+ Tree索引之上在再创建一个哈希索引，这样就让B+ Tree索引具有哈希索引的一些特点，比如快速的哈希查找。</p><p>全文索引</p><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用match against ，而不是普通的where。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB存储引擎在MySQL5.6.4版本中也开始支持全文索引。</p><p>空间数据索引</p><p>MyISAM存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用GIS相关函数来维护数据。</p><h4 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h4><h5 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h5><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用actor_id列的的索引：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select actor_id from actor where actor_id+1=5;</span><br></pre></td></tr></table></figure><h5 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h5><p>在需要使用多个列作为条件进行查询时，使用多列索引比多个单列索引性能更好。例如下面的语句中，最好把actor_id和film_id设置为多列索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class="line">WHERE actor_id = 1 AND film_id = 1;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>lamdba表达式的基本使用</title>
      <link href="/2022/01/06/lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/01/06/lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="lambda表达式里面的sum"><a href="#lambda表达式里面的sum" class="headerlink" title="lambda表达式里面的sum()"></a>lambda表达式里面的sum()</h5><p>对集合中的字段进行相加计算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Goods&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Goods goods = <span class="keyword">new</span> Goods(<span class="number">12</span>,<span class="string">&quot;可乐&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    Goods goods1 = <span class="keyword">new</span> Goods(<span class="number">6</span>,<span class="string">&quot;牛奶&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    list.add(goods);</span><br><span class="line">    list.add(goods1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = list.stream().mapToInt(x -&gt; x.getGoodsNum() * x.getGoodsPrice()).sum();</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lambda表达式转map"><a href="#lambda表达式转map" class="headerlink" title="lambda表达式转map"></a>lambda表达式转map</h5><p>注：写代码使用lambda表达式转map的时候，注意key重复的问题。</p><p><strong>基本方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Integer&gt; <span class="title">getNamePriceMap</span><span class="params">(List&lt;Goods&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.stream().collect(Collectors.toMap(Goods::getGoodsName,Goods::getGoodsPrice));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>根据某一个字段进行分类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据某一个字段分类</span></span><br><span class="line">        Map&lt;Integer, List&lt;Goods&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(Goods::getGoodsPrice));</span><br><span class="line">        System.out.println(collect);</span><br></pre></td></tr></table></figure><p><strong>收集成实体本身map</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Account&gt; <span class="title">getIdAccountMap</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法代替，使整个方法更简洁优雅：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, Account&gt; <span class="title">getIdAccountMap</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getId, Function.identity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重复key的情况</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Account&gt; <span class="title">getNameAccountMap</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可能报错（java.lang.IllegalStateException: Duplicate key），因为name是有可能重复的。toMap有个重载方法，可以传入一个合并的函数来解决key冲突问题：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Account&gt; <span class="title">getNameAccountMap</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的使用后者覆盖前者来解决问题。</p><h5 id="指定具体收集的Map"><a href="#指定具体收集的Map" class="headerlink" title="指定具体收集的Map"></a>指定具体收集的Map</h5><p>toMap还有另一个重载方法，可用指定一个Map的具体实现类，来收集数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Account&gt; <span class="title">getNameAccountMap</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2, LinkedHashMap::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lambda表达式里面的排序"><a href="#lambda表达式里面的排序" class="headerlink" title="lambda表达式里面的排序"></a>lambda表达式里面的排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Goods&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Goods goods = <span class="keyword">new</span> Goods(<span class="number">12</span>,<span class="string">&quot;可乐&quot;</span>,<span class="number">4</span>);</span><br><span class="line">Goods goods1 = <span class="keyword">new</span> Goods(<span class="number">6</span>,<span class="string">&quot;牛奶&quot;</span>,<span class="number">30</span>);</span><br><span class="line">Goods goods2 = <span class="keyword">new</span> Goods(<span class="number">12</span>,<span class="string">&quot;coffee&quot;</span>,<span class="number">30</span>);</span><br><span class="line">list.add(goods);</span><br><span class="line">list.add(goods1);</span><br><span class="line">list.add(goods2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">list.sort((a,b)-&gt;a.getGoodsPrice()-b.getGoodsPrice());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>n个骰子的点数</title>
      <link href="/2022/01/01/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/"/>
      <url>/2022/01/01/n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p><p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><p><code>1&lt;=n&lt;=11</code></p><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>这个题目的题意比较清晰：就是将n个骰子的所有可能点数的之和的概率以一个数组的形式返回就行。</p><p>这题我会^_^，不就是概率题嘛，我直接运用概率论进行解题，开始写代码，等等代码…</p><p>虽然本题的题意比较好理解，但若没有思路还真不知道如何写。我们仔细想想，当骰子为n时，它点数的概率不就等于当骰子为n-1时的概率乘以1/6的和嘛。所以可以得到<br>$$<br>f(n)(k)=1/6*\sum{f(n-1)(i+j)}<br>$$<br>其中n指的骰子数，i指的是n个骰子的点数之和的可能数，第n个骰子的可能的点数。k=i+j</p><p>从上面的算式，可知我们只需要每次记录骰子n-1的状态，即可求出骰子数为n时的结果。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] dicesProbability(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">double</span>[] ans=<span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1.0</span>/<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6</span>,<span class="number">1.0</span>/<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">// 记录状态</span></span><br><span class="line">            <span class="keyword">double</span>[] temp=<span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>*i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans.length;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;k++)&#123;</span><br><span class="line">                    <span class="comment">// 根据上一次的状态，计算出当前状态</span></span><br><span class="line">                    temp[j+k]+=ans[j]/<span class="number">6</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：这个题的解题思路运用了动态规划的思想，但我对动态规划还没掌握，还得多练</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2021/12/28/HashMap/"/>
      <url>/2021/12/28/HashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h4 id="HashMap基础"><a href="#HashMap基础" class="headerlink" title="HashMap基础"></a>HashMap基础</h4><p>HashMap类有一个非常重要的属性Node是HashMap</p><p>的一个内部类实现了Map.Entry接口，本质上是一个映射。</p><img src="/2021/12/28/HashMap/image-20211228194359152.png" class title="image-20211228194359152"><p>Node类的基本属性有：</p><p><code>hash</code>：key的哈希值</p><p><code>key</code>：节点的key，类型和定义HashMap的key相同</p><p><code>value</code>：节点的value，类型和定义HashMap的value相同</p><p><code>next</code>：该节点的下一节点</p><h5 id="HashMap的容量"><a href="#HashMap的容量" class="headerlink" title="HashMap的容量"></a>HashMap的容量</h5><p>HashMap的容量默认是16</p><img src="/2021/12/28/HashMap/image-20211228194820147.png" class title="image-20211228194820147"><h5 id="HashMap的负载因子"><a href="#HashMap的负载因子" class="headerlink" title="HashMap的负载因子"></a>HashMap的负载因子</h5><p>HashMap的负载因子为0.75</p><img src="/2021/12/28/HashMap/image-20211228194957309.png" class title="image-20211228194957309"><p>当HashMap中的元素数量超过容量*负载因子时，HashMap会进行扩容。</p><h5 id="HashMap的hash-算法"><a href="#HashMap的hash-算法" class="headerlink" title="HashMap的hash()算法"></a>HashMap的hash()算法</h5><p>源码：</p><img src="/2021/12/28/HashMap/image-20211228195248724.png" class title="image-20211228195248724"><p>问题：HashMap里面的<code>hash()</code>返回值为什么不是<code>key.hashcode()</code>，而是<code>key.hashcode()^(key.hashcode()&gt;&gt;&gt;16)</code></p><p>解析：<code>key.hashcode()^(key.hashcode()&gt;&gt;&gt;16)</code>的逻辑就算先获得key的hashcode值h，然后将h与h右移16位的结果进行异或运算。实际上就是把一个数的低16位与它的高16位进行异或运算。</p><p>若不这样的话，那么就只有hash()返回值的末x位参与到运算，这样就会造成hash冲突的概率高些。如果先把key的hashcode()返回值的高16位和低16位进行异或运算，这样高16位业参与了运算，能够减少hash碰撞的概率。</p><h4 id="HashMap的数组-链表"><a href="#HashMap的数组-链表" class="headerlink" title="HashMap的数组+链表"></a>HashMap的数组+链表</h4><h5 id="HashMap为什么引入链表"><a href="#HashMap为什么引入链表" class="headerlink" title="HashMap为什么引入链表"></a>HashMap为什么引入链表</h5><p>HashMap底层是数组，当map进行put()操作的时候，会进行hash计算，判断这个元素在数组的哪个位置。当多个元素的值在同一个数组位置上的时候，就会有hash冲突了，这个时候就需要链表来存储这些相同hash值的元素。</p><h5 id="为什么jdk1-8会引入红黑树呢"><a href="#为什么jdk1-8会引入红黑树呢" class="headerlink" title="为什么jdk1.8会引入红黑树呢"></a>为什么jdk1.8会引入红黑树呢</h5><p>HashMap底层的Node数组长度大于64且链表长度大于8时，遍历查找速度慢，所以引入红黑树以提高查找效率</p><h5 id="HashMap为什么不一开始就使用红黑树"><a href="#HashMap为什么不一开始就使用红黑树" class="headerlink" title="HashMap为什么不一开始就使用红黑树"></a>HashMap为什么不一开始就使用红黑树</h5><p>因为红黑树相对于链表维护成本高，红黑树在插入数据后，可能会通过左旋、右旋、变色来保持平衡，造成维护成本过高，姑链表长度较短时，不适合使用红黑树</p><h5 id="HashMap的底层数组取值的时候，为什么不用取模，而是-amp"><a href="#HashMap的底层数组取值的时候，为什么不用取模，而是-amp" class="headerlink" title="HashMap的底层数组取值的时候，为什么不用取模，而是&amp;"></a>HashMap的底层数组取值的时候，为什么不用取模，而是&amp;</h5><img src="/2021/12/28/HashMap/image-20211229185812430.png" class title="image-20211229185812430"><p>因为计算机底层位运算比%快。</p><h5 id="数组的长度为什么是2的次幂"><a href="#数组的长度为什么是2的次幂" class="headerlink" title="数组的长度为什么是2的次幂"></a>数组的长度为什么是2的次幂</h5><p>原因：</p><ul><li>为了减少hash冲突，使数据分布均匀。因此我们一般使用<code>hashcode()%size</code>，这样可以达到最大的平均分配。而<code>(n-1)&amp;hashcode</code>，当n为2次幂时，会满足<code>(n-1)&amp;hash=hash%n</code></li><li>能保证索引值肯定在capacity中，不会超出数组长度；</li></ul><p>总结：如果既要达到最可能的平均分配HashMap的value的在table的各个index，又要用二进制计算实现存取效率，就要求HashMap的容量必须为2的幂次方</p><h5 id="若指定数组的长度不为2次幂，就破坏了数组的长度是2次幂的这个规则吗？"><a href="#若指定数组的长度不为2次幂，就破坏了数组的长度是2次幂的这个规则吗？" class="headerlink" title="若指定数组的长度不为2次幂，就破坏了数组的长度是2次幂的这个规则吗？"></a>若指定数组的长度不为2次幂，就破坏了数组的长度是2次幂的这个规则吗？</h5><p>不会，在HashMap的构造方法中调用了tableForSize方法做了处理，能保证n永远是二次幂</p><img src="/2021/12/28/HashMap/image-20211229221533659.png" class title="image-20211229221533659"><img src="/2021/12/28/HashMap/image-20211229221544875.png" class title="image-20211229221544875"><h4 id="HashMap的源码"><a href="#HashMap的源码" class="headerlink" title="HashMap的源码"></a>HashMap的源码</h4><h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h5><p>1.8中的put()方法</p><ul><li>如果key对应的索引位置是null，那么直接插入</li><li>数组里面key对应的索引值位置的key不为null，判断这个旧值的key是否和新值的key相同，若相同，则把旧值返回，并记录这个位置</li><li>数组里面key对应的索引值位置的key不为null，判断这个索引位置的值是不是树结构，如果是树结构，调用putTreeVal方法添加数据</li><li>数组里面key对应的索引位置的值不为null，且这个索引位置的值为链表结构，然后遍历整个链表(当数组长度大于等于64，且链表长度大于8时转化为树结构)，如果链表结构有key值和新key值相同，就把老的值给返回，并且记录这个值，如果遍历到尾部还不相同就使用尾插法把数据插入进去</li><li>将新插入的值放到标记的位置上面</li></ul><p>注：HashMap在调用put()方法时，若key已存在，则会返回原来key对应的value/ </p><p>底层源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果table为空，或者还没有元素时，则扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果首结点值为空，则创建一个新的首结点。</span></span><br><span class="line">    <span class="comment">// 注意：(n - 1) &amp; hash才是真正的hash值，也就是存储在table位置的index。在1.6中是封装成indexFor函数。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">// 到这儿了，就说明碰撞了，那么就要开始处理碰撞。</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 如果在首结点与我们待插入的元素有相同的hash和key值，则先记录。</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果首结点的类型是红黑树类型，则按照红黑树方法添加该元素</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;  <span class="comment">// 到这一步，说明首结点类型为链表类型。</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                        <span class="comment">// 如果遍历到末尾时，先在尾部追加该元素结点。</span></span><br><span class="line">                        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="comment">// 当遍历的结点数目大于8时，则采取树化结构。</span></span><br><span class="line">                            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                                treeifyBin(tab, hash);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果找到与我们待插入的元素具有相同的hash和key值的结点，则停止遍历。此时e已经记录了该结点</span></span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 表明，记录到具有相同元素的结点</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">// onlyIfAbsent表示如果当前位置已存在一个值，是否替换，false是替换，true是不替换</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);  <span class="comment">// 这个是空函数，可以由用户根据需要覆盖</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 当结点数+1大于threshold时，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">// 这个是空函数，可以由用户根据需要覆盖</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h5><ul><li>首先获取当前key对应的数组索引位置，然后根据key判断该位置的首节点是否是自己想要的节点</li><li>若首节点不是的话，判断节点是否是树节点，如果是的话，通过调用getTreeNode()来实现get()方法，若不是树节点，那么就遍历整个链表，查询是否有自己想要的值</li><li>若上述步骤都没有查询到数据，直接返回null</li></ul><p>底层源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个Node对象来接收</span></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="comment">//调用getNode()方法，返回值赋值给e，如果取得的值为null，就返回null，否则就返回Node对象e的value值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//取hash值方法，HashMap的put方法的也是调用了这个方法，get方法也调用这个方法，保证存取时key值对应的hash值是一致的，这样才能正确对应 </span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义几个变量 </span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">//首先是判断数组table不能为空且长度要大于0，同时把数组长度tab.length赋值给n</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">             <span class="comment">//其次是通过[(n - 1) &amp; hash]获取key对应的索引，同时数组中的这个索引要有值，然后赋值给first变量</span></span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这个first其实就是链表头的节点了，接下来判断first的hash值是否等于传进来key的hash值</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; </span><br><span class="line">                <span class="comment">//再判断first的key值赋值给k变量，然后判断其是否等于key值，或者判断key不为null时，key和k变量的equals比较结果是否相等</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果满足上述条件的话，说明要找的就是first节点，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//走到这步，就说明要找的节点不是首节点，那就用first.next找它的后继节点 ，并赋值给e变量，在这个变量不为空时   </span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果首节点是树类型的，那么直接调用getTreeNode()方法去树里找</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                     <span class="comment">//这里就不跟进去了，获取树中对应key的节点后直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">//走到这步说明结构还是链表    </span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//这一步其实就是在链表中遍历节点，找到和传进来key相符合的节点，然后返回</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                  <span class="comment">//获取e节点的后继节点，然后赋值给e，不为空则进入循环体  </span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以上条件都不满足，说明没有该key对应的数据节点，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="HashMap的扩容原理"><a href="#HashMap的扩容原理" class="headerlink" title="HashMap的扩容原理"></a>HashMap的扩容原理</h4><h5 id="1-7的扩容原理"><a href="#1-7的扩容原理" class="headerlink" title="1.7的扩容原理"></a>1.7的扩容原理</h5><p>put()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);<span class="comment">//计算键的hash值</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//通过hash值对应到桶位置</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">    <span class="comment">//顺序遍历桶外挂的单链表</span></span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">    <span class="comment">//注意这里的键的比较方式== 或者 equals()</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);<span class="comment">//遍历单链表完毕，没有找到与键相对的Entry，需要新建一个Entry换句话说就是桶i是一个空桶；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>addEntry()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></span><br><span class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></span><br><span class="line"><span class="comment"> * method to resize the table if appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">      <span class="comment">// 当size大于等于某一个阈值thresholdde时候且该桶并不是一个空桶；</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//将容量扩容为原来的2倍</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);<span class="comment">//扩容后的，该hash值对应的新的桶位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);<span class="comment">//在指定的桶位置上，创建一个新的Entry</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Like addEntry except that this version is used when creating entries</span></span><br><span class="line"><span class="comment"> * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span></span><br><span class="line"><span class="comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span></span><br><span class="line"><span class="comment"> * clone, and readObject.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<span class="comment">//链表的头插法插入新建的Entry</span></span><br><span class="line">    size++;<span class="comment">//更新size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size记录的是map中包含的Entry的数量</li><li>而threshold记录的需要resize的阈值，<code>threshold=loadFactor*capacity</code></li><li>capacity其实就是桶的长度</li></ul><p>扩容的时机：</p><p>当map中Entry的数量大于等于threshold的时候，且新建的Entry刚好落在一个非空的桶上，此刻触发扩容机制，将其容量扩大为2倍。当size大于等于threshold的时候，并不一定会触发扩容机制，但是很可能就触发扩容机制，只要新建一个新建的Entry出现哈希冲突就会进行扩容</p><p>扩容过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></span><br><span class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></span><br><span class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></span><br><span class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></span><br><span class="line"><span class="comment">     * This has the effect of preventing future calls.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></span><br><span class="line"><span class="comment">     *        must be greater than current capacity unless current</span></span><br><span class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></span><br><span class="line"><span class="comment">     *        is irrelevant).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">    <span class="comment">//最大容量为 1 &lt;&lt; 30</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];<span class="comment">//新建一个新表</span></span><br><span class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;<span class="comment">//是否再hash</span></span><br><span class="line">        transfer(newTable, rehash);<span class="comment">//完成旧表到新表的转移</span></span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers all entries from current table to newTable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">    <span class="comment">//遍历同桶数组中的每一个桶</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">    <span class="comment">//顺序遍历某个桶的外挂链表</span></span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;<span class="comment">//引用next</span></span><br><span class="line">                <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                    e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">//找到新表的桶位置;原桶数组中的某个桶上的同一链表中的Entry此刻可能被分散到不同的桶中去了，有效的缓解了哈希冲突。</span></span><br><span class="line">                e.next = newTable[i];<span class="comment">//头插法插入新表中</span></span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>旧桶数组中的某个桶的外挂链表是通过头插法插入新桶数组中的，并且原链表中的Entry节点并不一定仍然在新桶数组的同一链表。</p><p>注：由于1.7中的put方法是使用的头插法，而原链表的Entry节点在扩容后位置可能会发生变化，有可能会导致遍历链表时产生死循环。</p><h5 id="1-8的扩容原理"><a href="#1-8的扩容原理" class="headerlink" title="1.8的扩容原理"></a>1.8的扩容原理</h5><p>JDK1.8对resize()方法进行很大的调整，JDK1.8的resize()方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)                      <span class="comment">//注释1</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;                                 <span class="comment">//注释2</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)                                        <span class="comment">//注释3</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;                      <span class="comment">//注释4</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)                            <span class="comment">//注释5</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;                           <span class="comment">//注释6</span></span><br><span class="line">                            loTail = e;                                    <span class="comment">//注释7</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;                                  <span class="comment">//注释8</span></span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解析：</p><p>注释1：在resize()方法中定义了oldCap参数，记录了原table的长度，定义了newCap参数，记录新table的长度，newCap是oldCap长度的2倍，同时扩展点也为原来的两倍</p><p>注释2：遍历原table，把原table中的每个链表中的每个元素放入到新table</p><p>注释3：e.next==null，指的是链表中只有一个元素，所以直接把e放入新table，其中的<code>e.hash&amp;(newCap-1)</code>是元素在新数组中的下标</p><p>注释4：正常情况下，计算节点在table中的下标的方法是：hash&amp;(oldTable.length-1)，扩容之后，table长度翻倍，计算table下标的方法是hash &amp; (newTable.length-1)，也就是hash &amp; (oldTable.length2-1)，于是我们有了这样的结论：*这新旧两次计算下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度。</p><p>注：HashMap的方法是线程不安全的。HashMap在并发执行put操作时发生扩容，可能会导致节点丢失，产生环形链表等情况。节点丢失，会导致数据不准；生成环形链表，会导致get()方法死循环。</p><p>在jdk1.7中，由于扩容时使用头插法，在并发时可能会形成环形链表，导致死循环，在jdk1.8中改为尾插法，可以避免这种问题，但是依然避免不了这种问题。</p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h4 id="ConcurrentHashMap跟HashMap，HashTable的对比"><a href="#ConcurrentHashMap跟HashMap，HashTable的对比" class="headerlink" title="ConcurrentHashMap跟HashMap，HashTable的对比"></a>ConcurrentHashMap跟HashMap，HashTable的对比</h4><p>HashMap是线程不安全的，所以在多线程的环境下会出现问题。</p><p>HashTable虽然是线程安全的，但是是通过整个方法加锁的方式实现的，当一个线程在写操作时，其它线程不能进行读写。</p><p>而ConcurrentHashMap则可以支持并发的读写。跟1.7版本相比，1.8版本有了很大的变化，已经抛弃了Segment的概念，虽然代码里面还保留了，也只是为了兼容性考虑。</p><h4 id="ConcurrentHashMap原理概览"><a href="#ConcurrentHashMap原理概览" class="headerlink" title="ConcurrentHashMap原理概览"></a>ConcurrentHashMap原理概览</h4><p>在ConcurrentHashMap中通过一个Node[]数组来保存添加到map中的键值对，而在同一个数组位置是通过链表和红黑树的形式来保存的。但是这个数组只有在第一次添加元素的时候才会初始化，否则只是初始化一个ConcurrentHashMap对象的话，只是设定了一个sizeCtl变量，这个变量用来判断对象的一些状态和是否需要扩容。</p><p>第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取与来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个以上，如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64了的话，在会将该节点的链表转换成树。</p><p>过扩容数组的方式来把这些节点给分散开。然后将这些元素复制到扩容后的新的数组中，同一个链表中的元素通过hash值的数组长度位来区分，是还是放在原来的位置还是放到扩容的长度的相同位置去 。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p><h4 id="ConcurrentHashMap重要概念"><a href="#ConcurrentHashMap重要概念" class="headerlink" title="ConcurrentHashMap重要概念"></a>ConcurrentHashMap重要概念</h4><p>重要的属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>; <span class="comment">// 表示正在转移</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEBIN   = -<span class="number">2</span>; <span class="comment">// 表示已经转换成树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RESERVED  = -<span class="number">3</span>; <span class="comment">// hash for transient reservations</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_BITS = <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//默认没初始化的数组，用来保存元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//转移的时候用的数组</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制表初始化和扩容的，默认值为0，当在初始化的时候指定了大小，这会将这个大小保存在sizeCtl中，大小为数组的0.75</span></span><br><span class="line"><span class="comment"> * 当为负的时候，说明表正在初始化或扩张，</span></span><br><span class="line"><span class="comment"> *     -1表示初始化</span></span><br><span class="line"><span class="comment"> *     -(1+n) n:表示活动的扩张线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><p>重要的类</p><p>Node：构成每个元素的基本类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//key的hash值</span></span><br><span class="line">        <span class="keyword">final</span> K key;       <span class="comment">//key</span></span><br><span class="line">        <span class="keyword">volatile</span> V val;    <span class="comment">//value</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;K,V&gt; next; <span class="comment">//表示链表中的下一个节点</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>TreeNode：构造树的节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">                 TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeBin：用作树的头节点，只存储root和first节点，不存储节点的key，value值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; root;</span><br><span class="line">        volatile TreeNode&lt;K,V&gt; first;</span><br><span class="line">        volatile Thread waiter;</span><br><span class="line">        volatile int lockState;</span><br><span class="line">        // values for lockState</span><br><span class="line">        static final int WRITER = 1; // set while holding write lock</span><br><span class="line">        static final int WAITER = 2; // set when waiting for write lock</span><br><span class="line">        static final int READER = 4; // increment value for setting read lock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ForwardingNode：在转移的时候放在头部的节点，是一个空节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap几个重要方法"><a href="#ConcurrentHashMap几个重要方法" class="headerlink" title="ConcurrentHashMap几个重要方法"></a>ConcurrentHashMap几个重要方法</h4><p>在ConcurrentHashMap中使用了unSafe方法，通过直接操作内存的方式来保证并发处理的安全性，使用的是硬件的安全机制。下面的代码中的U就指的是unSafe。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 用来返回节点数组的指定位置的节点的原子操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * cas原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 原子操作，在指定位置设定值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">        U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果在实例化对象的时候指定了容量，则初始化sizeCtl</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当出入一个Map的时候，先设定sizeCtl为默认容量，在添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在构造方法中并未对存储Map元素Node的table变量进行初始化。而是在第一次put操作的时候再进行初始化。</p><p>initTable</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化数组table，</span></span><br><span class="line"><span class="comment">     * 如果sizeCtl小于0，说明别的数组正在进行初始化，则让出执行权</span></span><br><span class="line"><span class="comment">     * 如果sizeCtl大于0的话，则初始化一个大小为sizeCtl的数组</span></span><br><span class="line"><span class="comment">     * 否则的话初始化一个默认大小(16)的数组</span></span><br><span class="line"><span class="comment">     * 然后设置sizeCtl的值为数组长度的3/4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;    <span class="comment">//第一次put的时候，table还没被初始化，进入while</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)                            <span class="comment">//sizeCtl初始值为0，当小于0的时候表示在别的线程在初始化表或扩展表</span></span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;    <span class="comment">//SIZECTL：表示当前对象的内存偏移量，sc表示期望值，-1表示要替换的值，设定为-1表示要初始化表了，这一步会将sizeCtl设置成-1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;        <span class="comment">//指定了大小的时候就创建指定大小的Node数组，否则创建指定大小(16)的Node数组</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;            <span class="comment">//初始化后，sizeCtl长度为数组长度的3/4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap的put操作详解"><a href="#ConcurrentHashMap的put操作详解" class="headerlink" title="ConcurrentHashMap的put操作详解"></a>ConcurrentHashMap的put操作详解</h4><p>put方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    单纯的额调用putVal方法，并且putVal的第三个参数设置为false</span></span><br><span class="line"><span class="comment"> *  当设置为false的时候表示这个value一定会设置</span></span><br><span class="line"><span class="comment"> *  true的时候，只有当这个key的value为空的时候才会设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当添加一对键值对的时候，首先会去判断保存这些键值对的数组是不是初始化了，</span></span><br><span class="line"><span class="comment">     * 如果没有的话就初始化数组</span></span><br><span class="line"><span class="comment">     *  然后通过计算hash值来确定放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 如果这个位置为空则直接添加，如果不为空的话，则取出这个节点来</span></span><br><span class="line"><span class="comment">     * 如果取出来的节点的hash值是MOVED(-1)的话，则表示当前正在对这个数组进行扩容，复制到新的数组，则当前线程也去帮助复制</span></span><br><span class="line"><span class="comment">     * 最后一种情况就是，如果这个节点，不为空，也不在扩容，则通过synchronized来加锁，进行添加操作</span></span><br><span class="line"><span class="comment">     *    判断当前取出的节点位置存放的是链表还是树</span></span><br><span class="line"><span class="comment">     *    如果是链表的话，则遍历整个链表，直到取出来的节点的key来个要放的key进行比较，如果key相等，并且key的hash值也相等的话，则说明是同一个key，则覆盖掉value，否则的话则添加到链表的末尾</span></span><br><span class="line"><span class="comment">     *    如果是树的话，则调用putTreeVal方法把这个元素添加到树中去</span></span><br><span class="line"><span class="comment">     *  最后在添加完成之后，会判断在该节点处共有多少个节点（注意是添加前的个数），如果达到8个以上了的话，</span></span><br><span class="line"><span class="comment">     *  则调用treeifyBin方法来尝试将处的链表转为树，或者扩容数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//K,V都不能为空，否则的话跑出异常</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());    <span class="comment">//取得key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;    <span class="comment">//用来计算在这个节点总共有多少个元素，用来控制扩容或者转移为树</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">// table变量会在initTable()里面进行赋值</span></span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)    </span><br><span class="line">                tab = initTable();    <span class="comment">//第一次put的时候table没有初始化，则初始化table，在initTable()里面对table变量赋值</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;    <span class="comment">//通过哈希计算出一个表中的位置因为n是数组的长度，所以(n-1)&amp;hash肯定不会出现数组越界，在这一步算出具体的索引位置i变量的值</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,        </span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))        <span class="comment">//cas的方式尝试添加Node节点，注意这个时候是没有加锁的，这里的第一个null表示只有当前的i位置的变量是null的时候，才会插入Node节点，第二个null表示Node节点的是下一个节点为空</span></span><br><span class="line">                    <span class="keyword">break</span>;                   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果检测到某个节点的hash值是MOVED，则表示正在进行数组扩张的数据复制阶段，</span></span><br><span class="line"><span class="comment">             * 则当前线程也会参与去复制，通过允许多线程复制的功能，一次来减少数组的复制所带来的性能损失</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)    </span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意执行到这里的时候，f局部变量、n和i和fh局部变量都已经有值了，因为执行到这里说明上面的几个判断都已经执行过了</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果在这个位置有元素的话，就采用synchronized的方式加锁，</span></span><br><span class="line"><span class="comment">                 *     如果是链表的话(hash大于0)，就对这个链表的所有元素进行遍历，</span></span><br><span class="line"><span class="comment">                 *         如果找到了key和key的hash值都一样的节点，则把它的值覆盖掉</span></span><br><span class="line"><span class="comment">                 *         如果没找到的话，则添加在链表的最后面</span></span><br><span class="line"><span class="comment">                 *  否则，是树的话，则调用putTreeVal方法添加到树中去</span></span><br><span class="line"><span class="comment">                 *  </span></span><br><span class="line"><span class="comment">                 *  在添加完之后，会对该节点上关联的的数目进行判断，</span></span><br><span class="line"><span class="comment">                 *  如果在8个以上的话，则会调用treeifyBin方法，来尝试转化为树，或者是扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;        <span class="comment">//再次取出要存储的位置的元素，跟前面取出来的比较</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                <span class="comment">//取出来的元素的hash值大于0，当转换为树之后，hash值为-2，就是变量TREEBIN的值</span></span><br><span class="line">                            binCount = <span class="number">1</span>;            </span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;    <span class="comment">//遍历这个链表</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;        <span class="comment">//要存的元素的hash，key跟要存储的位置的节点的相同的时候，替换掉该节点的value即可</span></span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)        <span class="comment">//当使用putIfAbsent的时候，只有在这个key没有设置值得时候才设置</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//如果不是同样的hash，同样的key的时候，则判断该节点的下一个节点是否为空，</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,        <span class="comment">//为空的话把这个要加入的节点设置为当前节点的下一个节点</span></span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//表示已经转化成红黑树类型了</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,    <span class="comment">//调用putTreeVal方法，将该元素添加到树中去</span></span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)    <span class="comment">//当在同一个节点的数目达到8个的时候，则扩张数组或将给节点的数据转为tree</span></span><br><span class="line">                        treeifyBin(tab, i);    </span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);    <span class="comment">//计数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap的扩容详解"><a href="#ConcurrentHashMap的扩容详解" class="headerlink" title="ConcurrentHashMap的扩容详解"></a>ConcurrentHashMap的扩容详解</h4><p>在put方法中，我们可以看到，在同一个节点的个数超过8个的时候，会调用treeifyBin方法来看看是扩容还是转化为一颗树，同时在每次添加完元素的addCount方法中，也会判断当前数组中的元素是否达到了sizeCtl的量，如果达到了话；则会进入transfer方法去扩容。</p><p>treeifyBin</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at given index unless table is</span></span><br><span class="line"><span class="comment"> * too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> * 当数组长度小于64的时候，扩张数组长度一倍，否则的话把链表转为树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                            hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要扩容的时候，调用tryPresize方法</p><p>tryPresize</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容表为指可以容纳指定个数的大小（总是2的N次方）</span></span><br><span class="line"><span class="comment"> * 假设原来的数组长度为16，则在调用tryPresize的时候，size参数的值为16&lt;&lt;1(32)，此时sizeCtl的值为12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * MAXIMUM_CAPACITY = 1 &lt;&lt; 30 = 1073741824</span></span><br><span class="line"><span class="comment">         * 如果给定的大小大于等于数组容量的一半，则直接使用最大容量，</span></span><br><span class="line"><span class="comment">         * 否则使用tableSizeFor算出来，tableSizeFor()返回值是入参的二倍</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;   <span class="comment">// while循环来进行扩容</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果数组table还没有被初始化，则初始化一个大小为sizeCtrl和刚刚算出来的c中较大的一个大小的数组</span></span><br><span class="line"><span class="comment">         * 初始化的时候，设置sizeCtrl为-1，初始化完成之后把sizeCtrl设置为数组长度的3/4</span></span><br><span class="line"><span class="comment">         * 为什么要在扩张的地方来初始化数组呢？这是因为调用putAll方法直接put一个map的话，在putALl方法中没有调用initTable方法去初始化table，而是直接调用了tryPresize方法，所以这里需要做一个是不是需要初始化table的判断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            n = (sc &gt; c) ? sc : c;   </span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;    <span class="comment">//初始化tab的时候，把sizeCtl设为-1</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];  <span class="comment">// 扩容一个长度是n的新数组</span></span><br><span class="line">                        table = nt;  <span class="comment">// 把新数组赋值给table变量</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    <span class="comment">// 开始转移数据</span></span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 开始转移数据</span></span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在tryPresize方法中，并没有加锁，允许多个线程进入，如果数组正在扩张，则当前线程也去帮助扩容。</p><p>transfer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Moves and/or copies the nodes in each bin to new table. See</span></span><br><span class="line"><span class="comment">     * above for explanation.</span></span><br><span class="line"><span class="comment">     * 把数组中的节点复制到新的数组的相同位置，或者移动到扩张部分的相同位置</span></span><br><span class="line"><span class="comment">     * 在这里首先会计算一个步长，表示一个线程处理的数组长度，用来控制对CPU的使用，</span></span><br><span class="line"><span class="comment">     * 每个CPU最少处理16个长度的数组元素,也就是说，如果一个数组的长度只有16，那只有一个线程会对其进行扩容的复制移动操作</span></span><br><span class="line"><span class="comment">     * 扩容的时候会一直遍历，知道复制完所有节点，没处理一个节点的时候会在链表的头部设置一个fwd节点，这样其他线程就会跳过他，</span></span><br><span class="line"><span class="comment">     * 复制后在新数组中的链表不是绝对的反序的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)    <span class="comment">//MIN_TRANSFER_STRIDE 用来控制不要占用太多CPU</span></span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range    //MIN_TRANSFER_STRIDE=16</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果复制的目标nextTab为null的话，则初始化一个table两倍长的nextTab</span></span><br><span class="line"><span class="comment">         * 此时nextTable被设置值了(在初始情况下是为null的)</span></span><br><span class="line"><span class="comment">         * 因为如果有一个线程开始了表的扩张的时候，其他线程也会进来帮忙扩张，</span></span><br><span class="line"><span class="comment">         * 而只是第一个开始扩张的线程需要初始化下目标数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 创建一个fwd节点，这个是用来控制并发的，当一个节点为空或已经被转移之后，就设置为fwd节点</span></span><br><span class="line"><span class="comment">         * 这是一个空的标志节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;    <span class="comment">//是否继续向前查找的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep(清扫) before committing nextTab,在完成之前重新在扫描一遍数组，看看有没完成的没</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing) &#123;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;        <span class="comment">//已经完成转移</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);    <span class="comment">//设置sizeCtl为扩容后的0.75</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)            <span class="comment">//数组中把null的元素设置为ForwardingNode节点(hash值为MOVED[-1])</span></span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;                <span class="comment">//加锁操作</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;        <span class="comment">//该节点的hash值大于等于0，说明是一个Node节点</span></span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * 因为n的值为数组的长度，且是power(2,x)的，所以，在&amp;操作的结果只可能是0或者n</span></span><br><span class="line"><span class="comment">                                 * 根据这个规则</span></span><br><span class="line"><span class="comment">                                 *         0--&gt;  放在新表的相同位置</span></span><br><span class="line"><span class="comment">                                 *         n--&gt;  放在新表的（n+原来位置）</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n; </span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * lastRun 表示的是需要复制的最后一个节点</span></span><br><span class="line"><span class="comment">                             * 每当新节点的hash&amp;n -&gt; b 发生变化的时候，就把runBit设置为这个结果b</span></span><br><span class="line"><span class="comment">                             * 这样for循环之后，runBit的值就是最后不变的hash&amp;n的值</span></span><br><span class="line"><span class="comment">                             * 而lastRun的值就是最后一次导致hash&amp;n 发生变化的节点(假设为p节点)</span></span><br><span class="line"><span class="comment">                             * 为什么要这么做呢？因为p节点后面的节点的hash&amp;n 值跟p节点是一样的，</span></span><br><span class="line"><span class="comment">                             * 所以在复制到新的table的时候，它肯定还是跟p节点在同一个位置</span></span><br><span class="line"><span class="comment">                             * 在复制完p节点之后，p节点的next节点还是指向它原来的节点，就不需要进行复制了，自己就被带过去了</span></span><br><span class="line"><span class="comment">                             * 这也就导致了一个问题就是复制后的链表的顺序并不一定是原来的倒序</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;    <span class="comment">//n的值为扩张前的数组的长度</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 构造两个链表，顺序大部分和原来是反的</span></span><br><span class="line"><span class="comment">                             * 分别放到原来的位置和新增加的长度的相同位置(i/n+i)</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同为0的节点)设置到旧的table的第一个hash计算后为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                         * 假设runBit的值不为0，</span></span><br><span class="line"><span class="comment">                                         * 则第一次进入这个设置的时候相当于把旧的序列的最后一次发生hash变化的节点(该节点后面可能还有hash计算后同不为0的节点)设置到旧的table的第一个hash计算后不为0的节点下一个节点</span></span><br><span class="line"><span class="comment">                                         * 并且把自己返回，然后在下次进来的时候把它自己设置为后面节点的下一个节点</span></span><br><span class="line"><span class="comment">                                         */</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);    </span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);    </span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;    <span class="comment">//否则的话是一个树节点</span></span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                             * 在复制完树节点之后，判断该节点处构成的树还有几个节点，</span></span><br><span class="line"><span class="comment">                             * 如果≤6个的话，就转回为一个链表</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>复制之后的新链表不是旧链表的绝对倒序</li><li>在扩容的时候每个线程都有处理的步长，最少为16，在这个步长范围内的数组节点只有自己一个线程来处理</li></ul><h4 id="ConcurrentHashMap的get操作详解"><a href="#ConcurrentHashMap的get操作详解" class="headerlink" title="ConcurrentHashMap的get操作详解"></a>ConcurrentHashMap的get操作详解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 相比put方法，get就很单纯了，支持并发操作，</span></span><br><span class="line"><span class="comment">     * 当key为null的时候回抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">     * get操作通过首先计算key的hash值来确定该元素放在数组的哪个位置</span></span><br><span class="line"><span class="comment">     * 然后遍历该位置的所有节点</span></span><br><span class="line"><span class="comment">     * 如果不存在的话返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentHashMap的同步机制"><a href="#ConcurrentHashMap的同步机制" class="headerlink" title="ConcurrentHashMap的同步机制"></a>ConcurrentHashMap的同步机制</h4><p>在ConcurrentHashMap中，同步处理主要是通过synchronized和unsafe两种方式来完成的。</p><ul><li>在取得sizeCtl、某个位置的Node的时候，使用的都是unsafe的方法，来达到并发安全的目的</li><li>当需要在某个位置设置节点的时候，则会通过Synchronized的同步机制来锁定该位置的节点</li><li>在数组扩容的时候，则通过处理的步长和fwd节点来达到并发安全的目的，并将hash值设置为MOVED</li><li>当把某个位置的节点复制到扩张后的table的时候，也通过synchronized的同步机制来保证线程安全。</li></ul><h4 id="链表转化为红黑树的过程"><a href="#链表转化为红黑树的过程" class="headerlink" title="链表转化为红黑树的过程"></a>链表转化为红黑树的过程</h4><p>当数组中的某个链表上的元素超过8个的时候，就会尝试去扩容数组或将链表转化为红黑树</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程:&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;进入treeifyBin方法&quot;</span>);</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)    <span class="comment">//MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);        <span class="comment">// 数组扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;    <span class="comment">//使用synchronized同步器，将该节点出的链表转为树</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;    <span class="comment">//hd：树的头(head)</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)        <span class="comment">//把Node组成的链表，转化为TreeNode的链表，头结点任然放在相同的位置</span></span><br><span class="line">                                hd = p;    <span class="comment">//设置head</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));<span class="comment">//把TreeNode的链表放入容器TreeBin中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先将Node的链表转化为一个TreeNode的链表，然后将TreeNode链表的头结点来构造一个TreeBin。　</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">            <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);    <span class="comment">//创建的TreeBin是一个空节点，hash值为TREEBIN（-2）</span></span><br><span class="line">            <span class="keyword">this</span>.first = b;</span><br><span class="line">            TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = <span class="keyword">null</span>;</span><br><span class="line">                    x.red = <span class="keyword">false</span>;</span><br><span class="line">                    r = x;</span><br><span class="line">                &#125;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;<span class="comment">//x代表的是转换为树之前的顺序遍历到链表的位置的节点，r代表的是根节点</span></span><br><span class="line">                        <span class="keyword">int</span> dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        <span class="keyword">if</span> ((ph = p.hash) &gt; h)    <span class="comment">//</span></span><br><span class="line">                            dir = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                            dir = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);    <span class="comment">//当key不可以比较，或者相等的时候采取的一种排序措施</span></span><br><span class="line">                            TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;<span class="comment">//在这里判断要放的left/right是否为空，不为空继续用left/right节点来判断</span></span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            r = balanceInsertion(r, x); <span class="comment">//每次插入一个元素的时候都调用balanceInsertion来保持红黑树的平衡</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.root = r;</span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>红黑树所有操作的复杂度都是O(logn)，所以当元素量比较大的时候，效率也很高。</p><h4 id="ConcurrentHashMap面试题"><a href="#ConcurrentHashMap面试题" class="headerlink" title="ConcurrentHashMap面试题"></a>ConcurrentHashMap面试题</h4><p>为什么出现ConcurrentHashMap</p><p>因为传统的HashMap是线程不安全的，无法在多线程环境下使用。</p><p>JDK1.8ConcurrentHashMap的设计与实现非常巧妙，大量利用了volatile，CAS等乐观锁技术来减少锁竞争对于性能的影响。</p><p><strong>ConcurrentHashMap保证线程安全的方案是</strong></p><ul><li>JDK1.8：synchronized+CAS+红黑树+Node数组</li><li>JDK1.7：ReentrantLock+segment+HashEntry</li></ul><h4 id="链表变成红黑树的条件"><a href="#链表变成红黑树的条件" class="headerlink" title="链表变成红黑树的条件"></a>链表变成红黑树的条件</h4><p>当同一个位置的链表中的元素数量大于8，且数组长度大于等于64时才会将链表转化为红黑树；若链表中的元素数量大于8但数组长度小于64时，会进行扩容。</p><h4 id="ConcurrentHashMap不支持key或者value为null"><a href="#ConcurrentHashMap不支持key或者value为null" class="headerlink" title="ConcurrentHashMap不支持key或者value为null"></a>ConcurrentHashMap不支持key或者value为null</h4><p>ConcurrentHashMap和HashTable都是支持并发的，这样会有一个问题，当你通过get(key)获取对应的value时，如果获取到的是null，那么我们无法判断它是put的时候值就为null，还是根本就没做过映射。</p><p>而HashMap是非并发的，可以通过containsKey(key)来做这个判断，在HashMap里面，如果存储的是null，那么就直接放到key对应的链表第一位。而支持并发的Map在调用m.containsKey()和get(key)时的m可能已经不同了，所以ConcurrentHashMap不支持key或者value</p><h4 id="ConcurrentHashMap的put如何保证安全性的"><a href="#ConcurrentHashMap的put如何保证安全性的" class="headerlink" title="ConcurrentHashMap的put如何保证安全性的"></a>ConcurrentHashMap的put如何保证安全性的</h4><ul><li><p>在初始化数组的时候，根据sizeCtl变量来保证只有一个数组来进行初始化</p></li><li><p>在put元素的时候，如果put的值没有发生hash冲突此时<code>(f = tabAt(tab, i = (n - 1) &amp; hash)) == null</code>中使用tabAt原子操作获取数组，并利用<code>casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value))</code>CAS操作将元素插入到Hash表中</p></li><li><p>在存在hash冲突时，先把当前节点使用关键字synchronized加锁，然后再使用tabAt()原子操作判断下有没有线程对数组进行了修改，最后再进行其他操作。</p></li><li><p>锁住更新操作的代码块的原因</p><p>为什么要锁住更新操作的代码块?<br>因为发生了哈希冲突，当前线程正在f所在的链表上进行更新操作，假如此时另外一个线程也需要到这个链表上进行更新操作，如果不锁住更新链表操作的代码块，那么就会像hashmap那样造成数据丢失</p></li></ul><h4 id="ConcurrentHashMap的get-保证安全性"><a href="#ConcurrentHashMap的get-保证安全性" class="headerlink" title="ConcurrentHashMap的get()保证安全性"></a>ConcurrentHashMap的get()保证安全性</h4><p>这里要注意ConcurrentHashmap数组上面也添加了volatile关键字，但是这个volatile关键字只是针对数组的地址，数组元素的值不是volatile的，而为了保证数组里面的元素也是volatile的，所以有了tabAt()和casTabAt()和setTabAt()这几个方法。这里添加volatile关键字的目的为了使得Node数组在扩容的时候对其他线程具有可见性而加的volatile</p><h4 id="ConcurrentHashMap1-7和1-8的区别"><a href="#ConcurrentHashMap1-7和1-8的区别" class="headerlink" title="ConcurrentHashMap1.7和1.8的区别"></a>ConcurrentHashMap1.7和1.8的区别</h4><p>从Segment+HashEntry+Unsafe+ReentrantLock变为了Synchronized+Unsafe+Node+红黑树</p><p>用Synchronized+CAS代替了Segment，这样锁的粒度更小了，并不是每次都要加锁，CAS失败了才尝试加锁。</p><p><strong>JDK7ConcurrentHashMap</strong></p><p>在JDK1.7中ConcurrentHashMap由Segment(分段锁)数组结构和HashEntry数组组成，且主要通过Segment(分段锁)段技术实现线程安全。</p><p>Segment是一种可重入锁，是一种数组和链表的结构，一个Segment中包含一个HashEntry数组，每个HashEntry又是一个链表结构，因此在ConcurrentHashMap查询一个元素的过程需要进行两次Hash操作，如下所示：</p><p>第一次Hash定位到Segment，<br>第二次Hash定位到元素所在的链表的头部</p><p>正是通过Segment分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p><p>这样结构会使Hash的过程要比普通的HashMap要长，影响性能，但写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，ConcurrentHashMap提升了并发能力。</p><p><strong>JDK8ConcurrentHashMap</strong></p><p>在JDK8ConcurrentHashMap内部结构：数组+链表+红黑树，Java 8在链表长度超过一定阈值(8)时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N)))，结构基本上与功能和JDK8的HashMap一样，只不过ConcurrentHashMap保证线程安全性。</p><p>但在JDK1.8中摒弃了Segment分段锁的数据结构，基于CAS操作保证数据的获取以及使用synchronized关键字对相应数据段加锁来实现线程安全，这进一步提高了并发性。</p><p>ConcurrentHashMap采用Node类作为基本的存储单元，每个键值对(key-value)都存储在一个Node中，使用了volatile关键字修饰value和next，保证并发的可见性。其中Node子类有：</p><ul><li>ForwardingNode：扩容节点，只是在扩容阶段使用的节点，主要作为一个标记，在处理并发时起着关键作用，有了ForwardingNodes，也是ConcurrentHashMap有了分段的特性，提高了并发效率</li><li>TreeBin：TreeNode的代理节点，用于维护TreeNodes，ConcurrentHashMap的红黑树存放的是TreeBin</li><li>TreeNode：用于树结构中，红黑树的节点（当链表长度大于8时转化为红黑树），此节点不能直接放入桶内，只能是作为红黑树的节点</li><li>ReservationNode：保留结点</li></ul><p>ConcurrentHashMap中查找元素、替换元素和赋值元素都是基于sun.misc.Unsafe中原子操作实现多并发的无锁化操作。</p><h4 id="1-8在put-方法中初始化数组不需要加锁"><a href="#1-8在put-方法中初始化数组不需要加锁" class="headerlink" title="1.8在put()方法中初始化数组不需要加锁"></a>1.8在put()方法中初始化数组不需要加锁</h4><p>因为用了sizeCtl变量，将这个变量置为-1，就标明table正在初始化数组。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载</title>
      <link href="/2021/12/27/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2021/12/27/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h4 id="什么是类加载过程"><a href="#什么是类加载过程" class="headerlink" title="什么是类加载过程"></a>什么是类加载过程</h4><p>一个Java文件从编码完成到最终完成，需要经过<strong>编译</strong>和<strong>运行</strong>两个过程，其中编译就是将java文件通过javac命令编译成.class文件，运行则是将字节码文件(.class)文件交给JVM执行。<strong>类加载过程即指将字节码文件中的数据信息加载到内存中，并进行解析生成对应的Class对象的过程</strong>。</p><p>JVM不是一开始就把所有的类都加载到内存中的，而是只有第一次遇到某个需要运行的类时才会进行类加载，且只加载一次。</p><h4 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h4><p>类加载主要分为三个阶段：加载、链接、初始化</p><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类的加载：将类的.class文件中的二进制数据读入到内存中，将其放到方法区的运行时常量池内，然后在堆内创建一个这个类的java.lang.Class对象，用来封装类在方法区内的对象，主要步骤：</p><ul><li>根据一个类的全限定类名来获取定义的二进制字节流</li><li>将这个二进制字节流所代表的静态存储结构转化为方法区运行时数据结构</li><li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中数据的访问口</li></ul><img src="/2021/12/27/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20211227152902871.png" class title="image-20211227152902871"><p>加载类的方式：</p><ol><li>从本地系统直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ol><h5 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h5><p>JVM的类加载机制是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图叙述</p><p>双亲委派机制</p><img src="/2021/12/27/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/image-20211227153445070.png" class title="image-20211227153445070"><ul><li><p>BootstrapClassLoader（启动类加载器）</p><p>负责加载<code>$JAVA_HOME中jre/lib/rt.jar</code>里所有的class，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar</p></li><li><p>ExstentionClassLoader（标准扩展类加载器）</p><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。</p></li><li><p>AppClassLoader（系统类加载器）</p><p>负责记载classpath中指定的jar包及目录中的class</p></li><li><p>CustomClassLoader（自定义加载器）</p><p>属于应用程序根据自身需要自定义的ClassLoader</p></li></ul><p>类加载器的顺序</p><ul><li>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从CustomClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只被ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类</li><li>在加载类时，每个类加载器会将加载任务上交给其父，如果其父找不到，再由自己去加载</li><li>BoostrapClassLoader （启动类加载器）是最顶级的类加载器，其父加载器为null</li></ul><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><p>连接又分为三个阶段：验证、准备、解析</p><p><strong>验证</strong></p><p>目的：保证加载进来的字节流符合虚拟机规范不会造成安全错误</p><p>验证的具体内容:</p><ul><li>文件格式验证：验证字节流是否符合Class文件格式的规范</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，如循环、分支</li><li>符号引用验证：确保解析动作能正确执行，比如不能访问引用类的私有方法等</li></ul><p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p><strong>准备</strong></p><p>为静态变量分配内存，并赋默认值</p><p><strong>解析</strong></p><p>把常量池中的符号引用替换为直接引用</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化工作内容：JVM负责主要对类变量(类变量就是static修饰的变量)进行初始化，这里主要对类变量进行初始化，初始化主要有两种方式：</p><ul><li>声明静态变量时指定初始值</li><li>在静态代码块中对静态变量进行赋值</li></ul><p>类初始化时机</p><ul><li>创建类的实例，也就是new的方式</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（ClassLoader不会引起类的连接和初始化）</li><li>初始化某个类的子类，也会初始化其父类</li><li>Java虚拟机启动时被标明为启动类的类</li></ul><p>初始化顺序</p><ul><li>如果这个类还没被加载和链接，那就先进行加载和链接</li><li>假如这个类存在直接父类，并且这个类还没有被初始化，那就先初始化直接父类</li><li>若类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句</li><li>（静态变量、静态初始化块）–&gt;(变量、初始化块)–&gt;构造器</li></ul><p>若有父类，则顺序是：父类静态代码块—&gt;子类静态代码块—&gt;父类构造方法–&gt;子类构造方法</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 类加载 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="设计模式常用的七大原则"><a href="#设计模式常用的七大原则" class="headerlink" title="设计模式常用的七大原则"></a>设计模式常用的七大原则</h3><h4 id="设计模式的目的："><a href="#设计模式的目的：" class="headerlink" title="设计模式的目的："></a>设计模式的目的：</h4><ul><li>提高代码的可重用性</li><li>提高代码的可读性</li><li>提高代码的可扩展性</li><li>提高程序的可靠性：即增加新的功能后，对原来的功能没有影响</li><li>使程序呈现高内聚、低耦合的特性</li></ul><h4 id="七大原则–即应当遵守的原则"><a href="#七大原则–即应当遵守的原则" class="headerlink" title="七大原则–即应当遵守的原则"></a>七大原则–即应当遵守的原则</h4><ul><li>单一职责原则</li><li>接口隔离原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>开闭原则</li><li>迪米特法则</li><li>合成复用原则</li></ul><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>概述：对类来说，一个类应该只负责一项职责，如类A负责两个不同职责：职责1，职责2.当职责1需求变更而改变A时，可能会导致职责2执行错误，所以需要将类A的粒度分解为A1、A2</p><p>例子：交通工具运行在道路上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未遵守单一职责原则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上行驶....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遵守了单一职责原则，但为每一种类型都创建了对应的对象比较消耗资源，效率不高</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        WaterVehicle waterVehicle = <span class="keyword">new</span> WaterVehicle();</span><br><span class="line">        waterVehicle.run(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在水中行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在空中行驶...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 就类而言不算实现了单一职责原则，但就方法而言，遵守了单一职责原则</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle1 vehicle1 = <span class="keyword">new</span> Vehicle1();</span><br><span class="line">        vehicle1.roadRun(<span class="string">&quot;汽车&quot;</span>);</span><br><span class="line">        vehicle1.waterRun(<span class="string">&quot;轮船&quot;</span>);</span><br><span class="line">        vehicle1.airRun(<span class="string">&quot;飞机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roadRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在公路上行驶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waterRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在水中行驶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">airRun</span><span class="params">(String vehicle)</span></span>&#123;</span><br><span class="line">        System.out.println(vehicle+<span class="string">&quot;在空中行驶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单一职责原则注意事项和细节：</p><ul><li>降低类的复杂度，尽量保证一个类只负责一项职责</li><li>提高类的可读性，可维护性</li><li>降低变更引起的风险</li><li>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类中方法数量足够少时，可以在方法级别保持单一职责原则</li></ul><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>概念：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小接口上</p><p>例如：有一个接口中定义了5个方法，类C需要使用其中的三个方法就需要实现其中的5个方法。这是没有遵守接口隔离原则的，所以需要将接口分为多个接口，再通过类去实现接口，类C再依赖其中的实现类即可。</p><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p>概念：</p><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒转的中心思想是面向接口编程</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定得多。以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何的具体操作，把展现细节的任务交给实现类去实现</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependenceInversion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到发来邮件....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单容易想到</span></span><br><span class="line"><span class="comment">// 若我们获取的对象是微信、短信等，需要添加相应的接收方法</span></span><br><span class="line"><span class="comment">// 解决思路：引入一个IReceiver，表示接收者，这样Person类与IReceiver发生依赖</span></span><br><span class="line"><span class="comment">// 若有微信、短信等，让它们各自实现接口即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email)</span></span>&#123;</span><br><span class="line">        email.receive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependenceInversion1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到邮件...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver)</span></span>&#123;</span><br><span class="line">        receiver.receive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖传递的三种方式：</p><ul><li>接口传递</li><li>构造方法传递</li><li>set方法传递</li></ul><p>注意事项：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li><li>继承时遵守里氏替换原则</li></ul><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>概念：</p><ul><li>如果在每个对象类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序在所有的对象o1都替换成o2时，程序的行为都没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的的地方必须能透明的使用其子类的对象</li><li>在使用继承时，遵守里氏替换原则，在子类中尽量不要重写父类的方法</li><li>继承实际上让两个类耦合性增强了，在适合的情况下，可以通过聚合，组合，依赖来解决问题。</li></ul><h4 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h4><p>概念：</p><ul><li>开闭原则是编程中最基础、最重要的设计原则</li><li>一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象类构建框架，用实现扩展细节。</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不通过修改已有代码来实现变化</li></ul><p>示例：不遵守开闭原则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OcpDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shape.m_type==<span class="number">1</span>)&#123;</span><br><span class="line">            drawRectangle();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape.m_type==<span class="number">2</span>)&#123;</span><br><span class="line">            drawCircle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_type=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_type=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：遵守开闭原则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OcpDemo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape shape)</span> </span>&#123;</span><br><span class="line">        shape.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制矩形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;绘制圆形&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h4><p>概念：</p><ul><li>一个对象应该对其他对象保持最少的了解</li><li>类与类关系越密切，耦合度越大</li><li>迪米特法则又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。</li><li>更简单的定义：只与直接朋友通信</li></ul><p>直接朋友：每个对象都会与其它对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中我们称出现在成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接朋友。陌生的类最好不要以局部变量的形式出现在类的内部。</p><h4 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h4><p>概念：尽量使用合成/聚合的方式，而不是使用继承。</p><h4 id="设计原则的核心思想"><a href="#设计原则的核心思想" class="headerlink" title="设计原则的核心思想"></a>设计原则的核心思想</h4><ul><li>找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起</li><li>针对接口编程，而不是针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li></ul><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>概念：Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p><p>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和它们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211220204520958.png" class title="image-20211220204520958"><h3 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>饿汉式（静态变量的实现）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代码块的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优缺点说明：</p><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题</p><p>缺点：在类装载的时候就完成实例化，没有达到Lazy loading的效果。如果从始至终从未使用过这个实例则会造成内存的浪费</p><p>懒汉式（线程不安全的实现）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式，线程不安全的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点分析：</p><ul><li>起到了lazy loading的效果，但是只能在单线程下使用</li><li>如果在多线程下使用，会有线程安全问题，instance可能会有多个不同的实例</li></ul><p>结论：在实际开发中，不要使用这种方式</p><p>懒汉式（线程安全的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 懒汉式，线程不安全</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优缺点说明：</p><ul><li>解决了线程不安全的问题</li><li>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就行了，后面直接返回instance就行了</li></ul><p>结论：在实际开发中，不推荐使用这种方法</p><p>懒加载（双重验证）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// volatile：保持可见性(一旦变量的值改变，会立即同步到主存)，防止指令重排</span></span><br><span class="line">    <span class="comment">// 这里主要是防止指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><ul><li>双检锁是多线程开发中常使用到的，我们进行了两次if(singleton==null)检查，保证了线程安全</li><li>这样实例化代码只执行一次，后面再次访问时，就会直接return 实例化对象，也避免反复进行方法同步</li><li>线程安全；延迟加载；效率较高</li></ul><p>结论：在实际开发中推荐使用这种单例设计模式</p><p>静态内部类实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><ul><li>这种方式采用了类加载机制来保证初始化实例时只有一个线程</li><li>静态内部类在Singleton类被类加载时并不会立即加载，而是在需要实例化时，调用getInstance方法，静态内部类才会加载，从而完成Singleton的实例化</li><li>类的静态属性只会在第一次加载类的时候初始化，所以这里JVM帮我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的</li><li>避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li></ul><p>结论：推荐使用</p><p>利用枚举实现单例模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello我是单例&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点说明：</p><ul><li>利用枚举实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象（防止反射破坏单例）</li><li>是Effective Java中提倡的方式</li></ul><p>结论：推荐使用</p><p>单例模式在JDK应用的源码分析</p><p>JDK中，java.lang.Runtime就是经典的单例模式</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211221234113411.png" class title="image-20211221234113411"><p>单例模式注意事项和细节说明</p><ul><li>单例模式保证了系统内存中该类只有一个对象，节省了系统资源，对于一些需要频繁创建和销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须记住使用对应的获取对象的方法，而不是new</li><li>单例模式使用的场景：需要频繁的创建和销毁的对象；创建对象耗时过多或耗费资源过多（即：重量级对象）但又经常用到的对象，工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>需求：</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211222210408858.png" class title="image-20211222210408858"><p>传统方式实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:开始烘焙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:开始切分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:打包&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreekPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始准备&quot;</span>+getName()+<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始准备&quot;</span>+getName()+<span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderType;</span><br><span class="line">    <span class="keyword">private</span> Pizza pizza;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            orderType=getOrderType();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;greek&quot;</span>.equals(orderType))&#123;</span><br><span class="line">                pizza=<span class="keyword">new</span> GreekPizza();</span><br><span class="line">                pizza.setName(<span class="string">&quot;希腊披萨&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;cheese&quot;</span>.equals(orderType))&#123;</span><br><span class="line">                pizza=<span class="keyword">new</span> CheesePizza();</span><br><span class="line">                pizza.setName(<span class="string">&quot;起司披萨&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getOrderType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String next = scan.next();</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OrderPizza();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优缺点分析：</p><p>优点：好理解，易操作</p><p>缺点：违反了ocp原则，即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码或尽可能的少修改代码</p><h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>概念：简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。</p><p>简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)</p><p>在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时就会使用到工厂模式。</p><p> 使用简单工厂模式对上面的实现进行优化：</p><p>优化点：将制作披萨的任务交给简单工厂，OrderPizza不用了解如何制作披萨，只用将想要制作的pizza告诉简单任务工厂即可，这样在增加新的pizza的时候只需要修改简单工厂里的代码即可。</p><p>SimplePizzaFactory</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 制造披萨</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String orderType)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Pizza pizza=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;greek&quot;</span>.equals(orderType))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> GreekPizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot;希腊披萨&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;cheese&quot;</span>.equals(orderType))&#123;</span><br><span class="line">            pizza=<span class="keyword">new</span> CheesePizza();</span><br><span class="line">            pizza.setName(<span class="string">&quot;奶酪披萨&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OrderPizza</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SimplePizzaFactory simplePizzaFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderPizza</span><span class="params">(SimplePizzaFactory simplePizzaFactory)</span></span>&#123;</span><br><span class="line">        setFactory(simplePizzaFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactory</span><span class="params">(SimplePizzaFactory factory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.simplePizzaFactory=factory;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            String orderType = getOrderType();</span><br><span class="line">            Pizza pizza = simplePizzaFactory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span>(pizza!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;很抱歉，本店没有此类披萨&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getOrderType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入想要订购的披萨名称：&quot;</span>);</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String next = scan.next();</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>将createPizza定义为一个抽象方法，不同的需求的OrderPizza子类继承OrderPizza类，并实现OrderPizza;</p><h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>概念：定义一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。</p><p>抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合</p><p>从设计层面上看，抽象工厂模式就是对简单工厂模式的进一步抽象</p><p>将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。</p><p><strong>披萨项目的UML图</strong></p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211223122858069.png" class title="image-20211223122858069"><p>工厂模式在JDK源码中的使用</p><p>JDK的Calendar类中就使用了简单工厂模式。</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211223144002020.png" class title="image-20211223144002020"><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>工厂模式的意义：</p><p>将实例化对象的任务提取出来交给工厂类统一管理和维护，达到和主项目依赖关系的解耦，当需要增加或修改功能时，只需要修改工厂类即可，不需要改动其它代码。能够提高项目的扩展性和可维护性。</p><p>依赖抽象原则：</p><ul><li><p>创建对象实例时，不要直接new 类，而应该把new 的操作放在一个工厂的方法中并返回。</p></li><li><p>不要让类继承具体类，而是继承抽象类或是实现interface(接口)</p></li><li><p>不要覆盖基类中已经实现的方法</p></li></ul><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>需求： 克隆羊，有一只羊，复制10只相同的羊</p><p>传统的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraditionalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传统做法</span></span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;多莉&quot;</span>, <span class="number">1</span>, <span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        Sheep sheep1 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        Sheep sheep2 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        Sheep sheep3 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line">        Sheep sheep4 = <span class="keyword">new</span> Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点分析：</p><p>优点：比较好理解，简单易操作</p><p>缺点：在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低，总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活。</p><p>原型模式的概念：</p><ul><li>原型模式指用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li><li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节</li><li>原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()</li></ul><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211224132808933.png" class title="image-20211224132808933"><p>克隆羊使用原型模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Sheep <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Sheep)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrototype</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用了原型模式&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;多莉&quot;</span>, <span class="number">1</span>, <span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">        System.out.println(sheep);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Sheep clone = sheep.clone();</span><br><span class="line">            Sheep clone1 = sheep.clone();</span><br><span class="line">            System.out.println(<span class="string">&quot;克隆羊：&quot;</span>+clone);</span><br><span class="line">            System.out.println(<span class="string">&quot;克隆羊1：&quot;</span>+clone1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原型模式在Spring中的使用：</p><p>在注入Bean时，可设置scope为单例或原型</p><p>测试：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sheep1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.spring.entity.Sheep&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;多莉&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白色&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211224140250504.png" class title="image-20211224140250504"><p>在doGetBean方法中对所设置的scope进行了判断</p><p>浅拷贝的介绍：</p><ul><li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将属性的值复制一份给新的对象</li><li>对于数据类型是引用数据类型的成员变量，浅拷贝会进行引用传递，也就是将该成员变量的内存地址复制一份给新的对象</li><li>上面所用的原型模式就是浅拷贝</li><li>浅拷贝就是使用默认的clone方法实现的</li></ul><p>深拷贝的介绍：</p><ul><li>复制对象的所有基本数据类型的成员变量值</li><li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，知道该对象可达的所有对象。</li></ul><p>深拷贝实现方式：</p><ul><li>重写clone方法进行深拷贝</li><li>通过对象序列化实现深拷贝</li></ul><p>原型模式的注意事项</p><ul><li>创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能提高效率</li><li>不用重新初始化对象，而是动态地获得对象运行时的状态</li><li>如果原始对象发生变化(增加或减少属性)，其它克隆对象也会发生相应的变化</li><li>实现深拷贝时比较复杂</li></ul><p>缺点：需要为每一个类配备一个clone方法，这对全新的类不难，但对已有的类进行改造时，需要修改其源代码，这违背了ocp原则。</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>盖房项目需求</p><ol><li>需要建房子：这一过程为打桩、砌墙、封顶</li><li>房子有各种各样的，比如普通房，高楼，别墅，各种房子的过程虽然一样，但是要求不同</li></ol><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211225135604379.png" class title="image-20211225135604379"><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHouse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打地基</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 砌墙</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 盖房顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        buildBasic();</span><br><span class="line">        buildWall();</span><br><span class="line">        roofed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commonHouse</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">AbstractHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通楼房打地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房砌墙&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房盖顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        commonHouse.build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点分析：</p><p>优点：简单易懂</p><p>缺点：将房子和盖房子的操作封装到一起，耦合性较高</p><p>基本概念介绍：</p><ul><li>建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性的对象)</li><li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</li></ul><p>建造者模式的四个核心角色</p><ul><li>Product(产品角色)：一个具体的产品角色。</li><li>Builder(抽象构建者)：创建一个Product对象的各个部件指定的接口/抽象类</li><li>ConcreteBuilder(具体建造者)：实现接口，构建和装配各个部件</li><li>Director(指挥者)：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程</li></ul><p>盖房子（应用到建造者模式）</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211225142759828.png" class title="image-20211225142759828"><p>代码：</p><p>House</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地基</span></span><br><span class="line">    <span class="keyword">private</span> String basic;</span><br><span class="line">    <span class="comment">// 墙</span></span><br><span class="line">    <span class="keyword">private</span> String walls;</span><br><span class="line">    <span class="comment">// 房顶</span></span><br><span class="line">    <span class="keyword">private</span> String roof;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HouseBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> House house=<span class="keyword">new</span> House();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建造过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回建造的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">buildHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HighBuilding</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HighBuilding</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高楼打地基100m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;高楼砌墙10cm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;透明房顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CommonHouse</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonHouse</span> <span class="keyword">extends</span> <span class="title">HouseBuilder</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBasic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子打地基20m&quot;</span>);</span><br><span class="line">        house.setBasic(<span class="string">&quot;50m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildWalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子砌墙10cm&quot;</span>);</span><br><span class="line">        house.setWalls(<span class="string">&quot;10cm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roofed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;红房顶&quot;</span>);</span><br><span class="line">        house.setRoof(<span class="string">&quot;红房顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HouseDirector</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HouseBuilder houseBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseDirector</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseBuilder</span><span class="params">(HouseBuilder houseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseBuilder = houseBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> House <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        houseBuilder.buildBasic();</span><br><span class="line">        houseBuilder.buildWalls();</span><br><span class="line">        houseBuilder.roofed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> houseBuilder.buildHouse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CommonHouse commonHouse = <span class="keyword">new</span> CommonHouse();</span><br><span class="line">        HouseDirector houseDirector = <span class="keyword">new</span> HouseDirector(commonHouse);</span><br><span class="line">        House construct = houseDirector.construct();</span><br><span class="line"></span><br><span class="line">        System.out.println(construct);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建造者模式在JDK源码中的应用</p><p>StringBuilder</p><p>源码中建造者模式角色分析</p><ul><li>Appendable接口定义了多个append方法(抽象方法)，即Appendable为抽象建造者</li><li>AbstractStringBuilder实现了Appendable接口，这里的AbstractStringBuilder已经可以算是建造者了，只是还不能实例化</li><li>StringBuilder既充当了指挥者角色，同时充当了具体的建造者，建造方法是由AbstractStringBuilder实现的，而StringBuilder继承了AbstractStringBuilder。</li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>概念：</p><ul><li>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</li><li>适配器模式属于结构型模式</li><li>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</li></ul><p>工作原理：</p><ul><li>适配器模式：将一个类的接口转换成另一个接口，让原本接口不兼容的类可以兼容</li><li>从用户的角度看不到被适配者，是解耦的</li><li>用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法</li><li>用户收到反馈，感觉只是与目标接口交互</li></ul><p>类适配器模式：</p><p>介绍：</p><p>Adapter类，通过继承src类，实现dst类接口，完成src-&gt;dst的适配</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211226213852680.png" class title="image-20211226213852680"><p>220V转换成5V供手机使用</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211226212919255.png" class title="image-20211226212919255"><p>Voltage220V</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220v</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src=<span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输出220V&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Voltage5V</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">output5v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VoltageAdapter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5v</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src=output220v();</span><br><span class="line">        <span class="keyword">int</span> dst=src/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Phone</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charging</span><span class="params">(Voltage5V voltage)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;以&quot;</span>+voltage.output5v()+<span class="string">&quot;伏的电压进行充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charging(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类适配器模式注意事项和细节</p><ul><li>Java是单继承机制，所以适配器需要继承src类这一点算是一个缺点，因为这要求dst必须是接口，有一定局限性。</li><li>src类的方法在Adapter中都会暴露出来，也增加了使用的成本</li><li>由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增加。</li></ul><p>对象适配器模式：</p><p>概念：</p><ul><li>基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现dst接口，完成src-&gt;dst的适配</li><li>根据合成复用原则，在系统中尽量用关联关系来替代继承关系</li><li>对象适配器模式是适配器模式常用的一种</li></ul><p>依旧是上面的那个案例（使用对象适配器模式来做）</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211226220747093.png" class title="image-20211226220747093"><p>只有VoltageAdapter变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span>  <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Voltage220V voltage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage=voltage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5v</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = voltage.output220v();</span><br><span class="line">        <span class="keyword">int</span> dst=src/<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口适配器模式</p><p>概念：</p><ul><li>适配器模式或缺省适配器模式</li><li>当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</li><li>使用于一个接口不想使用其所有方法的情况</li></ul><p>适配器模式在Spring MVC框架应用的源码分析</p><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>概念：</p><ul><li>桥接模式是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变</li><li>是一种结构型设计模式</li><li>Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开，从而可以保持各部分的独立性以及应对他们的功能扩展。</li></ul><p>原理图：</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211227212130270.png" alt="image-20211227212130270" style="zoom:200%;"><p>说明：</p><ul><li>Client类：桥接模式的调用者</li><li>Abstraction(抽象类)：维护了Implementor 即它的实现类ConcreteImplementerA,二者是聚合关系，Abstraction充当桥接类</li><li>RefinedAbstraction：是Abstraction抽象类的子类</li><li>Implementor：行为实现类的接口</li><li>ConcreateImplementorA/B：行为的具体实现类</li></ul><p>实例：手机品牌与类型</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211227214041571.png" class title="image-20211227214041571"><p> 代码：</p><p>Brand</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 性价比</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 口碑</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">comment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vivo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vivo</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;vivo手机尺寸：1788x437&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;vivo手机性价比：价格亲民，性价比还行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;vivo手机评论：质量还行，特别是拍照功能很好用&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XiaoMI</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMI</span> <span class="keyword">implements</span> <span class="title">Brand</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机尺寸：1980x230&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机性价比：性价比之王&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机评论：性价比高，实惠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Phone</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public abstract <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    private Brand brand;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">Phone</span>(<span class="params">Brand brand</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand=brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">size</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        brand.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">price</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        brand.price();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">comment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        brand.comment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FoldPhone</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoldPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FoldPhone</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.size();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠式手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.price();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠式手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">comment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.comment();</span><br><span class="line">        System.out.println(<span class="string">&quot;折叠式手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone foldPhone = <span class="keyword">new</span> FoldPhone(<span class="keyword">new</span> XiaoMI());</span><br><span class="line">        foldPhone.size();</span><br><span class="line">        foldPhone.price();</span><br><span class="line">        foldPhone.comment();</span><br><span class="line"></span><br><span class="line">        Phone foldPhone1 = <span class="keyword">new</span> FoldPhone(<span class="keyword">new</span> Vivo());</span><br><span class="line">        foldPhone1.size();</span><br><span class="line">        foldPhone1.price();</span><br><span class="line">        foldPhone1.comment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接模式在JDBC源码中的剖析</p><img src="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20211227222910810.png" class title="image-20211227222910810"><p>桥接模式的注意事项</p><ul><li>实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。</li><li>对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成</li><li>桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本</li><li>桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jdk环境变量配置不起作用</title>
      <link href="/2021/12/07/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/12/07/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>原文地址：<a href="https://blog.csdn.net/xu10281/article/details/77074514">(22条消息) could not open ‘D:\Java\lib\amd64\jvm.cfg_xu10281的博客-CSDN博客_amd64jvm.cfg</a></p><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在cmd界面中输入java -version，报错(环境变量配置正确)</p><img src="/2021/12/07/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/image-20211207233209002.png" class title="image-20211207233209002"><p>且报错的该路径与我当前配置的环境变量的地址不同</p><p>上网查资料发现是因为系统还在调用上次配置的路径，即系统还在调用缓存中配置的环境变量路径，而未使用我们配置的路径</p><img src="/2021/12/07/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/image-20211207233727433.png" class title="image-20211207233727433"><p>按照缓存路径点进去发现存在一个javapath文件</p><img src="/2021/12/07/jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/image-20211207233829873.png" class title="image-20211207233829873"><p>删除该文件即可使用当前自己配置的路径</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> jdk环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM学习</title>
      <link href="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h4><p>定义：Java Virtual Machine - java程序的运行环境（Java二进制字节码的运行环境）</p><p>好处：</p><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收功能</li><li>数组下标越界越界检查</li><li>多态</li></ul><p>比较：jdk、jvm、jre</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211129153939974.png" class title="image-20211129153939974"><h4 id="JVM学习路线"><a href="#JVM学习路线" class="headerlink" title="JVM学习路线"></a>JVM学习路线</h4><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211129154604303.png" class title="image-20211129154604303"><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>作用：记住下一条jvm的指令的地址</p><p>特点：</p><ul><li>线程私有，每个线程有自己的程序计数器</li><li>不会存在内存溢出</li></ul><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>概念：</p><ul><li>栈，每个线程在执行时所需要的一块内存空间</li><li>栈帧：每个方法执行所需要的内存空间，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息</li><li>每个线程只能有一个活动栈帧，对应当前正在执行的方法 </li></ul><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211129213830808.png" class title="image-20211129213830808"><p><strong>问题：</strong></p><p>垃圾回收是否涉及到栈内存？</p><p>答案：否，栈内存存储的就是一个个的栈帧，而每一个栈帧在方法执行完毕后都会自动释放内存</p><p>栈内存分配越大越好吗？</p><p>答案：否，栈内存分配比较大，会导致能够执行的线程的数量减少</p><p>方法内的局部变量是否线程安全？</p><ul><li><p>若方法内局部变量没有逃离方法的作用范围，它是线程安全的</p></li><li><p>若局部变量引用了对象，并逃离了方法的作用范围，需要考虑线程安全</p></li><li><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存在线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(StringBuilder sb)</span></span>&#123;</span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在线程安全问题</span></span><br><span class="line">    <span class="comment">// 未逃离方法的作用范围</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="number">2</span>);</span><br><span class="line">        sb.append(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h5><p>原因：StackOverflowError</p><ul><li><p>栈帧过多导致栈内存溢出，（死循环、无限递归）</p><p>-Xss256k 在IDEA中设置JVM栈内存大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStackOverFlow</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>栈帧过大导致栈内存溢出</p></li></ul><h5 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h5><p>CPU占用过多</p><p>定位：</p><ul><li>用top命令定位哪个进程对cpu的占用过高‘</li><li>ps H -eo pid,tid,%cpu | grep 进程号（用ps命令进一步定位是哪个线程导致cpu引用过高）</li><li>jstack 进程id<ul><li>可以根据线程id找到有问题的线程，进一步定位到源码中有问题的位置</li></ul></li></ul><p>程序运行很久没有结果（死锁）</p><ul><li>jstack 进程id</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>作用：为本地方法的运行，提供运行的空间</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>Heap 堆，垃圾收集器管理的内存区域</p><p>通过new关键字，创建的对象都会使用堆内存</p><p>特点：</p><ul><li>它是线程共享的，存在线程安全问题</li><li>垃圾回收机制</li></ul><h5 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h5><p>堆内存溢出：java.lang.OutOfMemoryError: Java heap space</p><p>-Xmx 大小：修改堆内存大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutOfMemoryError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String str=<span class="string">&quot;hellop&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                str=str+str;</span><br><span class="line">                list.add(str);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="堆内存诊断’"><a href="#堆内存诊断’" class="headerlink" title="堆内存诊断’"></a>堆内存诊断’</h5><p>jps工具</p><ul><li>查看当前系统中有哪些java进程</li></ul><p>jmap工具</p><ul><li>查看堆内存占用情况（只能查看某一时刻的）jmap -heap 进程id</li></ul><p>jconsole工具</p><ul><li>图形化界面的，多功能的监测工具，可以连续监测</li></ul><p>jvisualvm工具</p><ul><li>图形化界面，特别的是能够实现堆dump，查找到比较占内存的对象</li><li> <img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130165216908.png" class title="image-20211130165216908"></li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130170124781.png" class title="image-20211130170124781"><h5 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h5><p>1.8以前会导致永久代溢出</p><p>1.8以后会导致元空间内存溢出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试元空间内存溢出</span></span><br><span class="line"><span class="comment"> *默认元空间使用的是本地内存，大小不设限，很难测试出想要的效果</span></span><br><span class="line"><span class="comment"> * -XX:MaxMetaspaceSize=8m 设置元空间内存大小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-11-30 17:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMetaSpaceOverFlow</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestMetaSpaceOverFlow myClassLoader = <span class="keyword">new</span> TestMetaSpaceOverFlow();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 生成类的二进制字节码</span></span><br><span class="line">                ClassWriter classWriter = <span class="keyword">new</span> ClassWriter(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 参数：版本号、public、类名、包名、父类、实现的接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8,Opcodes.ACC_PUBLIC,<span class="string">&quot;Class&quot;</span>+i,<span class="keyword">null</span>,<span class="string">&quot;java/lang/Object&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 返回的byte[]</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = classWriter.toByteArray();</span><br><span class="line">                myClassLoader.defineClass(<span class="string">&quot;Class&quot;</span>+i,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130172350528.png" class title="image-20211130172350528"><h5 id="方法区常量池"><a href="#方法区常量池" class="headerlink" title="方法区常量池"></a>方法区常量池</h5><p>定义：常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 二进制字节码包含了：类基本信息，常量池，类方法定义，包含了虚拟机指令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-11-30 17:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 利用javap -v HelloWorld.class 进行反编译查看具体信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130174443675.png" class title="image-20211130174443675"><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>定义：常量池是*.class文件中的，当类被加载时，它的常量池信息就会放入运行时常量池中，并把里面的符号地址变为真实地址</p><h5 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h5><p>字符串拼接例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringTable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量池是在class文件中的，当该类被加载时，就会将常量池的信息放到运行时常量池中，此时a b ab都还没变为Java字符串对象</span></span><br><span class="line">    <span class="comment">// ldc #2 会把a 符号变为&quot;a&quot;字符串对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 懒加载，只有在用到的时候才被转换成字符串对象放入StringTable中</span></span><br><span class="line">        <span class="comment">// StringTable底层是hashTable，不能扩容</span></span><br><span class="line">        String str=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">        String str1=<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String str3=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="comment">// str2==str3 true</span></span><br><span class="line">        <span class="comment">// javac 在编译期间的优化，结果已经在编译器确定为ab</span></span><br><span class="line">        System.out.println(str2==str3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>特性：</p><ul><li>常量池中的字符串仅是符号，第一次用到时才会变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder(1.8)</li><li>字符串常量的拼接原理是编译器优化，若StringTable中已存在则不会再重复创建字符串对象</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul><li>jdk1.8会将当前字符串尝试放入字符串常量池，若常量池已有当前字符串则不会放入；若没有，则放入常量池中，并返回常量池中的对象</li><li>jdk1.6会将当前字符串尝试放入字符串常量池，若常量池已有当前字符串则不会放入；若没有则将当前对象复制一份放入常量池中（即放入常量池的对象与当前对象是不同的），并返回常量池中的对象</li></ul></li></ul><h5 id="StringTable的位置"><a href="#StringTable的位置" class="headerlink" title="StringTable的位置"></a>StringTable的位置</h5><p>jdk1.6及以前，StringTable在永久代的常量池中，当StringTable内存溢出时，会报Perman space</p><p>jdk1.7后，StringTable在堆中，当StringTable内存溢出时，会报heap space</p><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试StringTable的位置</span></span><br><span class="line"><span class="comment"> * -Xmx10m：设置堆的大小 -XX:-UseGCOverheadLimit：需要关闭UseGCOverheadLimit，否则会报overheadLimit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-11-30 23:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLocationStringTable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">260000</span>; i++) &#123;</span><br><span class="line">                list.add(String.valueOf(i).intern());</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130233855134.png" class title="image-20211130233855134"><h5 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h5><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * -Xmx10m:堆内存的最大值，-XX:+PrintStringTableStatistics -XX:PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-11-30 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringTableGc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                String.valueOf(i).intern();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211130235224923.png" class title="image-20211130235224923"><h5 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h5><p>-XX:StringTableSize：设置StringTable的桶的数目</p><p>若程序中字符串常量较多,可以将-XX:StringTableSize适当设置大一些，这样性能会有明显的提升。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>常见于NIO操作时，用于数据缓冲区</p><p>分配回收成本高，但读写性能高</p><p>不受JVM内存回收管理</p><h5 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h5><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner(虚引用)来检测ByteBuffer对象，一旦被ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDirectMemory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> capacity=<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Unsafe unsafe = getUnsafe();</span><br><span class="line">            <span class="comment">// 返回分配的内存的地址</span></span><br><span class="line">            <span class="keyword">long</span> base = unsafe.allocateMemory(capacity);</span><br><span class="line">            unsafe.setMemory(base,capacity,(<span class="keyword">byte</span>)<span class="number">0</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">            unsafe.freeMemory(base);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe)theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><h4 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>当某个变量对当前对象引用一次，计数加一，当某个变量不再引用当前对象时，计数减一，当计数为0时即意味着没有变量引用该对象，可以被垃圾回收（存在循环引用导致内存泄漏）。</p><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p><p>扫描堆中的对象，看是否能够沿着GC root对象为起点的引用链找到该对象，找不到，表示可回收。</p><p>在Java中能够作为GC Roots的对象包含以下几种：</p><ul><li>虚拟机栈(栈帧中的本地方法变量表)中引用的对象</li><li>方法区中的静态变量所引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈JNI(即native方法)引用的对象。</li></ul><p>根对象：肯定不能当作垃圾回收的对象</p><p>被根对象直接或间接引用的对象不能被当作垃圾回收，不被根对象引用的对象可以当作垃圾回收</p><h5 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h5><p>强引用</p><p>软引用</p><p>弱引用</p><p>虚引用</p><p>终结器引用</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211201231612968.png" class title="image-20211201231612968"><p>上图实线的是强引用，只要存在GC Root对象实现的强引用，则该对象不能被垃圾回收</p><p>被软引用的对象在没有强引用的情况下，可以被垃圾回收机制回收，但必须满足当前内存不足的条件才能进行回收</p><p>被弱引用的对象在没有强引用的情况下，会被垃圾回收机制回收，不需要满足其他条件</p><p>软引用、弱引用本身也是对象，也会占用内存，当被软引用/弱引用对象被垃圾回收时，软引用/弱引用对象会被加入到引用队列中，遍历引用队列即可释放它们的内存。</p><p>虚引用需要配合引用队列使用，例如ByteBuffer的实现类中使用了Cleaner(虚引用)，当GC Root对ByteBuffer的强引用失去时，ByteBuffer被垃圾回收机制回收，但创建时分配的直接内存并不由GC管理，这时会将虚引用的Cleaner加入到引用队列中，ReferenceHandler线程会监听引用队列中是否有Cleaner若有Cleaner则调用它的clean方法调用Unsafe.freeMemory释放掉直接内存。</p><p>终结器引用是在对象没有强引用的情况下，将终结器引用放入引用队列中，此时该对象还没被垃圾回收，放入引用队列的终结器引用会由一个优先级很低的finallizeHandler线程进行处理，调用它的finallize()方法进行垃圾回收（该方法效率比较低，不建议使用）</p><p>演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 演示软引用</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-01 23:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSoftReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> capacity=<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        strong();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        soft();</span></span><br><span class="line">        weekUse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强引用会造成内存溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strong</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">byte</span>[]&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[capacity]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不会内存溢出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">soft</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue=<span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference=<span class="keyword">new</span> SoftReference(<span class="keyword">new</span> <span class="keyword">byte</span>[capacity],queue);</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">            list.add(softReference);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">        Reference&lt;? extends <span class="keyword">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span>(poll!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference : list) &#123;</span><br><span class="line">            System.out.println(softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 演示弱引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weekUse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference=<span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[capacity]);</span><br><span class="line">            list.add(weakReference);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="keyword">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">                System.out.print(reference.get()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="垃圾回收方法"><a href="#垃圾回收方法" class="headerlink" title="垃圾回收方法"></a>垃圾回收方法</h4><h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>缺点：会造成较多的内存碎片</p><p>沿着GC root寻找没有GC Root直接或间接引用的对象进行标记，然后将该段内存开始和结束地址放入一个空闲的地址列表里面，后面分配内存时不会再使用该地址</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211202215351516.png" class title="image-20211202215351516"><h5 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h5><p>速度较慢</p><p>会将清除的内存，整理成一片连续的内存，不会造成产生较多的内存碎片</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211202220949478.png" class title="image-20211202220949478"><h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>将From中的存活的对象，复制到To中，然后清空掉From,然后交换To和From的位置</p><p>优点：不会产生内存碎片</p><p>缺点：会占用双倍的内存</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211202223137143.png" class title="image-20211202223137143"><h4 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h4><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211202224830711.png" class title="image-20211202224830711"><ul><li>对象首先会分配到伊甸园</li><li>当新生代空间不足时，触发minor gc，将伊甸园和From中存活的对象复制到To中，存活年龄加一并且交换From To</li><li>minor gc会引发stop the world,暂停其他用户线程，等垃圾回收结束后，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升到老年代中，阈值最大为15（因为对象头中分配的内存为4bit）</li><li>当老年代中内存不足时，会先尝试触发minor gc，若之后内存空间仍不足，那么会执行full gc，STW的时间会更长</li><li>若full gc后空间仍然不足，则会导致内存溢出</li></ul><h5 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h5><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx或-XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn或(-XX:NewSize=size+-XX:MaxNewSize=size)</td></tr><tr><td>幸存区比例(动态)</td><td>-XX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC 前 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h5 id="分代回收测试"><a href="#分代回收测试" class="headerlink" title="分代回收测试"></a>分代回收测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-02 23:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当加入的对象超过新生代的空间时，会直接晋升到老年代，不会触发minor gc</span></span><br><span class="line">    <span class="comment">// 子线程造成OutOfMemory不会使主线程停止执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            List&lt;<span class="keyword">byte</span>[]&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">8</span>]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">8</span>]);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h5><p>特点：</p><ul><li>单线程</li><li>适合堆内存小，适合个人电脑</li></ul><p>-XX:+UserSerialGC=Serial(新生代：复制算法)+SerialOld(老年代：标记整理算法)</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203174351896.png" class title="image-20211203174351896"><h5 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h5><p>特点：</p><ul><li>多线程</li><li>堆内存较大的，多核cpu</li><li>让单位时间内，STW的时间最短（垃圾回收所占的时间占程序总运行时间的比例越小，吞吐量越大）</li></ul><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203183303384.png" class title="image-20211203183303384"><p>-XX:UseParallelGC ~ -XX:+UseParallelOldGC：垃圾回收算法，与串行一致</p><p>-XX:+UseAdaptiveSizePolicy：动态调整堆、伊甸区、两个Survior的比例</p><p>-XX:GCTimeRatio=ratio：根据1/(1+ratio)这个公式来算出垃圾回收时间占总的运行时间的比例</p><p>-XX:MaxGCPauseMillis=ms：垃圾回收时间的最大值（与上面的参数需要选择一个择中的数）</p><p>-XX:ParallelGCThreads=n：垃圾回收的线程数</p><h5 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h5><p>CMS中为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。</p><p>特点：</p><ul><li>多线程</li><li>堆内存较大，多核cpu</li><li>尽可能让单次的STW的时间最短</li></ul><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203184057986.png" class title="image-20211203184057986"><p>只在初始标记（只标记一些GC Root对象，很快）和重新标记（用户线程在运行过程中可能会改变对象的引用）中进行stop the world，其他的时间垃圾回收线程和普通用户线程是并发执行的</p><p>-XX:+UseConcMarkSweepGC~-XX:+UseParNewGC ~SerialOld</p><p>​    CMS垃圾回收器使用的垃圾回收算法是<strong>标记清除算法</strong>，所以会产生内存碎片，当并发失败时就会退化为SerialOld垃圾回收（<strong>标记整理算法</strong>），这样下一次的垃圾回收时间就会变得较长。</p><p>-XX:ParallelGCThreads=n：并行的垃圾回收线程数~ -XX:ConcGCThreads=threads：并发的垃圾回收线程数，一般设置为并行垃圾回收线程数的1/4</p><p>-XX:CMSInitiatingOccupancyFraction=percent：触发垃圾回收的时机（老年代内存使用占比超过多少时触发垃圾回收）</p><p>-XX:+CMSScavengeBeforeRemark：重新标记前进行一次新生代的垃圾回收，避免新生代中的垃圾引用老年代的对象导致重新标记时浪费了时间去寻找新生代中的垃圾引用  </p><h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p>定义：Garbage First</p><ul><li>2004论文发布</li><li>2009JDK6u14体验</li><li>2012JDK7u4官方支持</li><li>2017JDK9默认</li></ul><p>适用场景：</p><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)，默认暂停目标是200ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region(一个Region单独作为新生代、老年代或幸存区)</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul><p>相关参数：</p><ul><li>-XX:UseG1GC：使用G1垃圾回收器</li><li>-XX:G1HeapRegionSize=size：定义每个region的大小</li><li>-XX:MaxGCPauseMills=time：最大的垃圾回收时间 </li></ul><p>G1垃圾回收阶段：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203193904156.png" class title="image-20211203193904156"><p><strong>Young Collection</strong></p><p>会stw，但时间较短</p><p>新生代的垃圾回收，与之前的分代垃圾回收类似</p><p><strong>Young Collection+CM</strong></p><ul><li>在Young GC时会进行GC Root的初始标记</li><li>老年代占用堆空间比例到达阈值时，进行并发标记（不会STW）,由下面的JVM参数决定</li></ul><p>-XX:InitiatingHeapOccupancyPercent=percent(默认为45%)</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203195719544.png" class title="image-20211203195719544"><p> <strong>Mixed Collection</strong></p><p>会对E、S、O进行全面垃圾回收</p><ul><li>最终标记（Remark）会STW</li><li>拷贝存活（Evacuation）会STW</li></ul><p>并不是回收所有的老年代区域，而是回收垃圾最多的几个老年代</p><p>-XX:MaxGCPauseMills=ms</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203200205144.png" class title="image-20211203200205144"><p><strong>Full GC</strong></p><p>Serial GC</p><ul><li>新生代内存不足发生的垃圾回收，minor gc</li><li>老年代内存不足发生的垃圾回收，full gc</li></ul><p>ParallelGC</p><ul><li>新生代内存不足不足发生的垃圾回收，minor gc</li><li>老年代内存不足发生的垃圾回收，full gc</li></ul><p>CMS</p><ul><li>新生代内存不足发生的垃圾回收，minor gc</li><li>老年代内存不足，并发执行失败时（即垃圾回收速率跟不上垃圾生产速率），会退化为SerialGC,单线程执行full gc</li></ul><p>G1</p><ul><li>新生代内存不足发生的垃圾回收，minor gc</li><li>老年代内存不足，并发执行失败（即垃圾回收速率跟不上垃圾生产速率）时，会退化为SerialGC,单线程执行full gc</li></ul><p><strong>Young Collection跨代引用</strong></p><p>新生代回收的跨代引用（老年代引用新生代）问题</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203214934177.png" class title="image-20211203214934177"><p>老年代中有一个卡表，可以用来记录哪些新生代对象被引用，称为脏卡，而新生代中也有Remember Set可以用来记住哪些对象被老年代中引用，后面垃圾回收的时候可以先遍历Remember Set得到有哪些脏卡区，再到对应的脏卡去找GC Root</p><p>在引用发生变更时会将变更写入 post-write barrier+dirty card queue(更新卡表，变更操作是异步的)</p><p>然后通过concurrent refinement threads 更新Remembered Set</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203220516127.png" class title="image-20211203220516127"><p><strong>Remark</strong></p><p>pre-write barrier(写屏障)+stab_mark_queue</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211203222020784.png" class title="image-20211203222020784"><p><strong>写屏障</strong>是指，在改变特定内存的值（实际上也就是写入内存）的时候额外执行的一些动作。在大多数的垃圾回收算法中，都利用到了写屏障。写屏障通常用于在运行时探测并记录回收相关指针(interesting pointer)，在回收器只回收堆中部分区域的时候，任何来自该<strong>区域外的指针</strong>都需要被写屏障捕获，这些指针将会在垃圾回收的时候作为标记开始的根。JAVA使用的其余的分代的垃圾回收器，都有写屏障。举例来说，每一次将一个老年代对象的引用修改为指向年轻代对象，都会被写屏障捕获，并且记录下来。因此在年轻代回收的时候，就可以避免扫描整个老年代来查找根。</p><p><strong>JDK8u20字符串去重</strong>    </p><p>优点：节省大量内存</p><p>缺点：略微多占用了cpu时间，新生代回收时间略微增加</p><p>开启去重：-XX:+UseStringDeduplication</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] chars=new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span></span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>); <span class="comment">// char[] chars=new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;</span></span><br></pre></td></tr></table></figure><p>将所有新分配的字符串放入一个队列</p><p>当新生代回收时，G1并发检查是否有字符串重复</p><p>如果它们值一样，让它们引用同一个char[]</p><p>与String.intern()不同，String.intern()关注的是字符串对象，而字符串去重关注的是char[],在JVM内部使用了不同的字符串表</p><p><strong>JDK8u40并发标记类卸载</strong></p><p>所有对象都经过并发标记后，就能知道那些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</p><p>-XX:+ClassUnloadingWithConcurrentMark默认启用</p><p><strong>JDK8u60回收巨型对象</strong></p><p>一个对象大于region的一半时，称之为巨型对象</p><p>G1不会对巨型对象进行拷贝</p><p>回收时被优先考虑</p><p>G1跟踪老年代所有incoming引用，这样老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉。</p><p><strong>JDK9并发标记起始时间的调整</strong></p><p>并发标记必须在堆空间占满之前完成，否则退化为FullGC</p><p>JDK9之前需要使用-XX:InitiatingHeapOccupancyPercent</p><p>JDK9可以动态调整</p><h4 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h4><h5 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h5><p>内存、锁竞争、cpu占用、io</p><h5 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h5><p>根据对延迟和吞吐量的需求，选择合适的回收器</p><p>CMS、G1、ZGC(JDK12试用：超低延迟)、ParallelGC</p><h5 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h5><p>查看FullGC前后的内存占用，考虑下面几个问题：</p><ul><li>数据是不是太多</li><li>数据表示是否太臃肿<ul><li>对象中有一些无用的属性</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul><h5 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h5><p>新生代的特点：</p><ul><li>所有的new操作的内存分配非常廉价<ul><li>使用了TLAB thread-local allocation buffer(缓冲区)，每个线程使用私有的一块伊甸园的内存，这样保证了线程安全</li></ul></li><li>死亡对象的回收代价是零</li><li>大部分对象用过即死</li><li>Minor GC的时间远远低于Full GC</li></ul><p>新生代能容纳所有【并发量*(请求—响应)】的数据</p><p>幸存区大到能保留【当前活跃对象+需要晋升对象】</p><p>晋升阈值配置得当，让长时间存活对象尽快晋升</p><p>-XX:MaxTenuringThreshold=thresold：最大晋升阈值</p><p>-XX:+PrintTenuringDistribution：打印晋升的详情</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204215110984.png" class title="image-20211204215110984"><h5 id="老年代的调优"><a href="#老年代的调优" class="headerlink" title="老年代的调优"></a>老年代的调优</h5><p>以CMS为例：</p><ul><li>CMS的老年代内存越大越好</li><li>先尝试不做调优，如果没有Full GC那么已经…，否则先尝试调优新生代</li><li>观察发生Full GC时老年代内存占用，将老年代内存预设调大1/4~1/3<ul><li>-XX:CMSInitiatingOccupancyFraction=percent：发生GC的时机</li></ul></li></ul><h3 id="类加载与字节码技术"><a href="#类加载与字节码技术" class="headerlink" title="类加载与字节码技术"></a>类加载与字节码技术</h3><p>查看class二进制文件（Linux下）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexdump -C xxx.class</span><br></pre></td></tr></table></figure><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204230400041.png" class title="image-20211204230400041"><h4 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h4><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204225532490.png" class title="image-20211204225532490"><p><strong>魔术：</strong></p><p>第0~3个字节，表示它是否是【class】类型的文件</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204231219093.png" class title="image-20211204231219093"><p><strong>版本：</strong></p><p>第4~7字节，表示类的版本00 34(十进制为52)表示是Java 8</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204231431310.png" class title="image-20211204231431310"><p><strong>常量池:</strong></p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204231709919.png" class title="image-20211204231709919"><p>第8<del>9字节，表示常量池长度，00 23(35)，表示常量池有#1</del>#34项，注意#0项不计入，也没有值</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211204231902706.png" class title="image-20211204231902706"><p><strong>Field信息</strong></p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211206165500402.png" class title="image-20211206165500402"><p>中间还有一些知识听不明白，直接跳过了 </p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>自己分析类文件结构太麻烦了，Oracle提供了javap工具来反编译class文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -v xxx.class</span><br></pre></td></tr></table></figure><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><strong>常量池载入运行时常量池</strong></p><p>注：运行时常量池应该在方法区内，这里只是为了好理解才这样画的</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211206181110421.png" class title="image-20211206181110421"><p><strong>方法字节码载入方法区</strong></p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211206220121858.png" class title="image-20211206220121858"><p><strong>main线程开始运行，分配栈帧内存</strong></p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211206220348947.png" class title="image-20211206220348947"><p><strong>执行引擎开始执行字节码</strong></p><p>bipush 10</p><ul><li>将一个byte压入操作数栈(其长度会补齐4个字节)</li><li>sipush将一个short压入操作数栈(其长度会补齐4个字节)</li><li>idc将一个int压入操作数栈</li><li>idc2_w将一个long压入操作数栈(分两次压入，因为long是8个字节)</li><li>小的数字都是和字节码指令存在一起，超过short范围的数字存入了常量池</li><li>iinc(自增)指令是直接在局部变量表对应的位置进行的运算，不是在操作数栈中进行的</li></ul><p><strong>练习：</strong></p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211206230616252.png" class title="image-20211206230616252"><p>load_x</p><p>iinc x 1</p><p>instore_x</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><h4 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h4><p><strong>测试样例代码</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 演示多态原理，需要加上下面的JVM参数,禁用指针压缩</span></span><br><span class="line"><span class="comment"> * -XX:UseCompressedOops -XX:UseCompressedClassPointers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-07 20:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMoreObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal animal)</span></span>&#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        System.out.println(animal.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Dog());</span><br><span class="line">        test(<span class="keyword">new</span> Cat());</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是&quot;</span>+getClass().getSimpleName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行代码</strong></p><p>程序停在System.in.read()方法上，这时运行jps获取进程id</p><p><strong>运行HSDB工具</strong></p><p>进入JDK安装目录，执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure><p>进入图形化界面attach进程id</p><p>这里也没听懂，qaq</p><p><strong>小结：</strong></p><p>当执行invokevirtual指令时，</p><ul><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际Class</li><li>Class结构中有vtable，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li><li>查表得到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="finally-面试题"><a href="#finally-面试题" class="headerlink" title="finally 面试题"></a>finally 面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            i=<span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法执行的返回值是10；</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211207224535744.png" class title="image-20211207224535744"><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSynchronized</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二进制字节码：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211207225930178.png" class title="image-20211207225930178"><h4 id="编译器处理"><a href="#编译器处理" class="headerlink" title="编译器处理"></a>编译器处理</h4><p>语法糖：指Java编译器把*.java源码编译 *.class字节码的过程中，自动生成和转换的一些代码。</p><h5 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211207230855074.png" class title="image-20211207230855074"><h5 id="自动装拆箱："><a href="#自动装拆箱：" class="headerlink" title="自动装拆箱："></a>自动装拆箱：</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211207231314447.png" class title="image-20211207231314447"><h5 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211207232003717.png" class title="image-20211207232003717"><h5 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h5><p>方法重写时对返回值分两种情况：</p><ul><li>父类和子类的返回值类型完全一致</li><li>子类返回值可以是父类返回的子集</li></ul><p>例子：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211208222838000.png" class title="image-20211208222838000"><p>对于子类，java编译器会做如下处理：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211208222948155.png" class title="image-20211208222948155"><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211208223145567.png" class title="image-20211208223145567"><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211208223341792.png" class title="image-20211208223341792"><p>为什么匿名内部类引用局部变量时，局部变量必须是final的</p><p>因为在创建Candy11$ 1对象时，将x的值赋值给了valx属性，所以x不应该再发生变化，如果发生变化，那么valx属性没有机会再跟着变化</p><h4 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h4><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>将类的字节码载入方法区中，内部采用C++的instanceKlass描述java类，它的重要的field有：</p><ul><li>_java_mirror即java的类镜像，例如对String来说，就是String.class，作用是把kclass暴露给java使用</li><li>_super即父类</li><li>_fields即成员变量</li><li>_methods即方法</li><li>_constants即常量池</li><li>_class_loader即类加载器</li><li>_vtable虚方法表</li><li>_itable接口方法表</li></ul><p>若这个类还有父类未加载，先加载父类</p><p>加载和链接可能是交替运行的</p><p>注：</p><p>instanceKlass这样的元数据是存储在方法区(1.8后的元空间中的)，但_java_mirror是存储在堆中的</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211208233211786.png" class title="image-20211208233211786"><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><p>验证：验证类是否符合JVM规范，安全性检查</p><p>准备：为静态变量分配内存，设置默认值</p><ul><li>static 变量在JDK7之前存储于instanceKlass末尾，从JDK7开始，存储于_java _mirror末尾</li><li>static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果static 变量是final的基本类型，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static 变量是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>将常量池中的符号引用解析为直接引用</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><cinit>（）V方法</cinit></p><p>初始化即调用&lt; cinit&gt;()V，虚拟机会保证这个类的构造方法的线程很安全</p><p><strong>发生的时机</strong></p><p>类初始化是懒惰的</p><ul><li>main方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的static final 静态常量(指基础类型和字符串)不会触发初始化</li><li>类对象.class不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的loadClass方法，（不会进行链接和初始化）</li><li>Class.forName的参数2为false时</li></ul><p><strong>单例模式的懒汉式的一种实现方式</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazyHolder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton SINGLETON=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>JDK8</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，显示为null</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>上级为 Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h5 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bootstrap ClassLoader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBootStrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;entity.F&quot;</span>);</span><br><span class="line">        System.out.println(aClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211209225923035.png" class title="image-20211209225923035"><ul><li>-Xbootclasspath表示设置bootclasspath</li><li>其中/a:.表示将当前目录追加到bootclasspath 之后</li></ul><h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211209230321319.png" class title="image-20211209230321319"><h5 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h5><p>双亲委派：指调用类加载器的loadClass方法时，查找类的规则</p><p>注：这里的双亲称为上级似乎更为合适，因为它们没有继承关系</p><p>loadClass源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h5><h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><p>步骤：</p><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写findClass方法<ul><li>注意不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用该类加载器的loadClass方法</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name ：类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String path=<span class="string">&quot;E:\\myPath\\&quot;</span>+name+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            Files.copy(Paths.get(path),bos);</span><br><span class="line">            <span class="comment">// 得到字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// byte[] -&gt; *.class</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;类文件未找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h4><h5 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h5><p><strong>分层编译</strong></p><p>JVM将执行状态分成了5个层次：</p><ul><li>0层，解释执行(Interpreter)</li><li>1层，使用C1即时编译器编译执行(不带profiling)</li><li>2层，使用C1即时编译器编译执行(带基本的profiling)</li><li>3层，使用C1即时编译器编译执行(带完全的profiling)</li><li>4层，使用C2即时编译器编译执行</li></ul><p>profiling：指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p><p>即时编译器(JIT)与解释器的区别</p><ul><li>解释器是将字节码解释为机器码，下次即使再遇到相同的字节码，还是会执行重复的解释</li><li>即时编译器是将一些字节码编译为机器码，并存入Code Cache，下次遇到相同的代码时，不需要重新编译，直接执行即可</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译为机器码，而是采取解释执行的方式运行；对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。</p><p>执行效率的比较：Interpreter&lt;C1&lt;C2</p><p>逃逸分析：分析代码中的对象或内容是否被引用，若未被引用则不需要创建或执行，这样大大提高了运行速度</p><h5 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211210180306360.png" class title="image-20211210180306360"><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 方法内联</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-10 18:00</span></span><br><span class="line"><span class="comment"> * -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining ：打印内联信息</span></span><br><span class="line"><span class="comment"> * -XX:CompileCommand=dontinline,*JIT.square：禁止TestJIT的square方法内联</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJIT</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start=System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                x=square(<span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> end=System.nanoTime();</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\n&quot;</span>,i,x,end-start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i*i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h5><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>java内存模型与之前的java内存结构不同，java内存模型是Java Memory Model(JMM)的意思。JMM定义了一套在多线程读写共享数据时(成员变量、数组)时，对数据的可见性、有序性、和原子性的规则和保障</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性是指 一个操作是不可中断的，要么全部执行成功要么全部执行失败</p><p>例子：两个线程对初始值为0的静态变量一个做自增，一个做自减，各做5000次，结果是0 吗？</p><p>答案：不一定是，可能是正数、负数、零。因为Java中对静态变量的自增、自减并不是原子操作</p><h5 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h5><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211211214407039.png" class title="image-20211211214407039"><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211211215050047.png" class title="image-20211211215050047"><p>因为多线程，会轮流拿到时间片，导致指令交替执行，最终导致出现了正数、负数等情况</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>加锁，synchronized</p><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">要作为原子操作代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> Object o=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(o)&#123;</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// join()等待子线程结束后，主线程再结束</span></span><br><span class="line">        t.join();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><h5 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h5><p>例子：main线程对run变量的修改对于t线程不可见，导致了t线程无法停止</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAccessiableCycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> run=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">while</span>(run)&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        run=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>初始情况下，t线程刚开始从主内存中读取了run的值到工作内存中</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211211231559654.png" class title="image-20211211231559654"><p>因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率。</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211211231803398.png" class title="image-20211211231803398"><p>1秒后，main线程修改了run的值，并同步至主存，而t是从工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211211232132956.png" class title="image-20211211232132956"><h5 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h5><p>volatile(易变关键字)</p><p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存。</p><p>volatile保证可见性，不保证原子性，可防止指令重排序，保证指令的有序性</p><h5 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h5><p>上面的例子体现了可见性，它保证了在多个线程之间，一个线程对volatile变量的修改对另一个线程是可见的，但不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p><strong>注</strong>：synchronized语句块既可以保证代码块的原子性，也能保证代码块内变量的可见性，但缺点是synchronized属于重量级操作，性能相对比较低</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><h5 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h5><p>需要使用到压测工具jcstress</p><p>首先引入jar包依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jcstress 核心包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jcstress测试用例包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-samples<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先写一个简单测试用例此样例会在高并发下调用actor1和actor2方法各一次，按照正常逻辑，x最后的值要么是1要么是4，如果actor2方法内的2行代码发生了指令重排序，就会导致x的值可能为0。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> avo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试指令重排序问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-11 23:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id=&#123;&quot;1&quot;,&quot;4&quot;&#125;,expect = Expect.ACCEPTABLE,desc = &quot;normal result&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id=&#123;&quot;0&quot;&#125;,expect=Expect.ACCEPTABLE_INTERESTING,desc=&quot;!!!&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstructionReorder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            r.r1=x+x;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r.r1=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span></span>&#123;</span><br><span class="line">        x=<span class="number">2</span>;</span><br><span class="line">        flag=<span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置程序的主类，<code>org.openjdk.jcstress.Main</code>是JCStress自带的一个启动类；然后可以配置-t参数设置需要测试的类，当然 -t 后面也可以指定包名，表示执行指定包下的所有测试类。如果不指定-t参数，默认会扫描项目下所有包的类。</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212000647065.png" class title="image-20211212000647065"><p>测试结果，确实出现了三种结果</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212000949987.png" class title="image-20211212000949987"><h5 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h5><p>用volatile修饰变量，volatile能够防止指令重排</p><h5 id="有序性的理解"><a href="#有序性的理解" class="headerlink" title="有序性的理解"></a>有序性的理解</h5><p>同一个线程内，JVM会在不影响正确性的前提下，可以调整语句的执行顺序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作</span></span><br><span class="line">i= ...;<span class="comment">// 较为耗时的操作</span></span><br><span class="line">j= ...;</span><br></pre></td></tr></table></figure><p>可以看到，至于是先执行i还是先执行j，对最终的结果不会产生影响。所以上面的代码在真正执行时，既可以是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i= ...;<span class="comment">// 较为耗时的操作</span></span><br><span class="line">j= ...;</span><br></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">j= ...;</span><br><span class="line">i= ...;<span class="comment">// 较为耗时的操作</span></span><br></pre></td></tr></table></figure><p>这种特性称之为指令重排，多线程下指令重排会影响正确性，例如著名的double-checked locking 实现单例模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 使用double-checked locking模式实现的单例模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-12-12 10:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">private</span> <span class="keyword">static</span> SafeSingleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SafeSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁加在方法上会导致锁粒度较大，执行效率相对较慢，因为每次调用方法都需要获取锁</span></span><br><span class="line">    <span class="comment">// 这里使用双检锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SafeSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(SafeSingleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SafeSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种实现方式的特点是：</p><ul><li>懒惰实例化</li><li>首次使用getInstance()方法才加锁，后续使用时无需加锁。</li></ul><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212111132059.png" class title="image-20211212111132059"><h5 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h5><p>happens-before规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结</p><ul><li><p>线程解锁m之前对变量的写，对于接下来对m加锁的其它线程对该变量的读可见</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212203942277.png" class title="image-20211212203942277"></li><li><p>线程对volatile修饰的变量的写，对接下来其它线程对该变量的读可见</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212204044988.png" class title="image-20211212204044988"></li><li><p>线程start前对变量的写，对该线程开始后对该变量的读可见</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212204209120.png" class title="image-20211212204209120"></li><li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见(比如其它线程调用t1.isAlive()或t1.join()等待它结束)</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212204450848.png" class title="image-20211212204450848"></li><li><p>线程t1打断t2(interrupt)前对变量的写，对于其它线程得知t2被打断后对变量的读可见(通过t2.interrupted或t2.isInterrupted)</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212204735469.png" class title="image-20211212204735469"></li></ul><h4 id="CAS与原子类"><a href="#CAS与原子类" class="headerlink" title="CAS与原子类"></a>CAS与原子类</h4><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS即Compare and Swap，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行+1操作：</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212205940802.png" class title="image-20211212205940802"><p>获取变量时为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的场景下</p><ul><li>因为没有使用synchronized，所以线程不会陷入阻塞，这时效率提升的因素之一</li><li>但在激烈的情况下，可能会导致重试频繁发生，反而效率会受影响</li></ul><h5 id="CAS的底层实现"><a href="#CAS的底层实现" class="headerlink" title="CAS的底层实现"></a>CAS的底层实现</h5><h5 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h5><p>CAS是基于乐观锁的思想的：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，再重新尝试修改共享变量</p><p>synchronized是基于悲观锁的思想：最悲观的估计，需要防着其它线程来修改共享变量，我上了锁你们谁都别想改，我改完解开锁，你们才有机会。</p><h5 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h5><p>juc(java.util.concurrent)中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用CAS技术+volatile来实现的</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicInteger</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建原子整数对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                ai.getAndIncrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                ai.getAndDecrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待线程结束</span></span><br><span class="line">        t.join();</span><br><span class="line">        t1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(ai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h4><p>Java HotSpot虚拟机中，每个对象都有对象头(包括class指针和Mark word)。Mark word平时存储这个对象的哈希码、分代年龄，当加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。</p><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的(也就是没有竞争)，那么可以使用轻量级锁来优化。</p><p>举例：学生(线程A)用课本占座，上了半节课，出门了(CPU时间到了)，回来一看，发现课本没变，说明没有竞争继续上他的课。</p><p>如果这期间有其它学生(线程B)来了会告知(线程A)有并发访问，线程A随即升级为重量级锁，进入重量级锁的流程。</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212222426240.png" class title="image-20211212222426240"><p>每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p><p>上面示例代码的加锁过程</p><table><thead><tr><th>线程1</th><th>对象Mark word</th><th>线程2</th></tr></thead><tbody><tr><td>访问同步代码块A，把Mark复制到线程1锁记录中</td><td>01（无锁）</td><td></td></tr><tr><td>CAS修改Mark为线程1的锁记录地址</td><td>01（无锁）</td><td></td></tr><tr><td>成功（加锁）</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>执行同步代码块A</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>访问同步代码块B，把Mark复制到线程1锁记录中</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>CAS修改Mark为线程1的锁记录地址</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>失败(发现是自己的锁)</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>锁重入</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>执行同步代码块B</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>同步代码块B执行完毕</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>同步代码块A执行完毕</td><td>00（轻量级锁）线程1锁标记地址</td><td></td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td></td></tr></tbody></table><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212233005060.png" class title="image-20211212233005060"><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211212233710292.png" class title="image-20211212233710292"><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><p>重量级锁竞争的时侯，还可以使用自旋来进行优化，如果当前线程自旋成功(即这时候持锁线程已经退出了同步块，释放了锁)，这时当前线程就可以避免阻塞</p><p>自旋的优点：自旋锁能尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒操作的消耗，这些操作会导致线程发生两次上下文切换。</p><p>缺点：不适合用于锁竞争激烈，或持有锁的线程需要长时间占用锁执行同步代码块，因为自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，同时由于线程自旋一直占用cpu，导致其它线程获取不到cpu，造成cpu的浪费。</p><p>在Java6之后自旋锁是自适应的，比如对象刚刚一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之就少自旋或不自旋</p><ul><li>自旋会占用cpu时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</li><li>Java7之后不能控制是否开启自旋功能</li></ul><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行CAS操作。Java6引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后对比线程ID，若发现线程ID是自己的就表示没有竞争，就不需要进行CAS操作。</p><ul><li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程所有线程需要停止(STW)</li><li>访问对象的hashCode也会撤销偏向锁(因为在无锁条件下hashcode会存在对象头，当为偏向锁时，对象头会存储线程ID将hashCode存到对应的线程中去，访问hashCode需要将信息还原)</li><li>如果对象被多个线程访问，但没有竞争，这时偏向线程t1的对象仍有机会重新偏向t2，重偏向会重置对象的Thread ID</li><li>如果撤销偏向到达某个阈值，那么整个类的对象都会变为不可偏向</li><li>可以主动使用-XX:-UseBiasedLocking禁用偏向锁</li></ul><h5 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h5><p><strong>减少上锁时间</strong></p><p>同步代码块中尽量短</p><p><strong>减少锁的粒度</strong></p><p>将一个锁拆分为多个锁提高并发度，例如</p><ul><li>ConcurrentHashMap</li></ul><p><strong>锁粗化</strong></p><p>多次循环进入同步块不如同步块中多次循环</p><p>另外JVM可能会做如下优化，把多次append的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p><img src="/2021/11/29/JVM%E5%AD%A6%E4%B9%A0/image-20211214002412554.png" class title="image-20211214002412554"><p><strong>锁消除</strong></p><p>JVM会进行代码的逃逸分析，例如某个加锁对象是方法内的局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java运行环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础复习</title>
      <link href="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h4><p><strong>抽象</strong>：抽象是将一类对象的共同特征总结构造类的过程，包括数据抽象和行为抽象。抽象只关注对象有哪些属性和行为，并不关注具体的细节。</p><p><strong>继承</strong>：继承是从已有的类得到继承信息构建新的类的过程。提供继承信息的称为父类（超类或基类）。得到继承信息的称为子类（派生类）。继承大大的提高了代码的可复用性，可以让变化中的软件系统有一定的延续性。Java中的类只能单继承，不支持多继承。</p><p><strong>封装</strong>：把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。这样使用户使用我们所编写的程序时，只需要通过已定义的接口来访问所需要的操作，而不需要了解接口中的细节。充分的实现了高内聚。</p><p><strong>多态性</strong>：多态性是指允许对不同子类型的对象对同一消息做出不同的响应。即同样的对象引用调用同样的方法但是做了不同的事情。多态性分为编译时多态和运行时多态。</p><p>方法重载实现的是编译时多态，方法重写实现的是运行时多态</p><h4 id="权限修饰符的区别"><a href="#权限修饰符的区别" class="headerlink" title="权限修饰符的区别"></a><strong>权限修饰符的区别</strong></h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211127142835338.png" class title="image-20211127142835338"><h4 id="Java中的基本类型"><a href="#Java中的基本类型" class="headerlink" title="Java中的基本类型"></a>Java中的基本类型</h4><p>byte: 1个字节</p><p>short: 2个字节</p><p>int: 4个字节</p><p>long: 8个字节</p><p>float: 4个字节（单精度）</p><p>double: 8个字节（双精度）</p><p>char: 英文字母一个字节，中文2-4个字节</p><p>boolean</p><h4 id="switch能够作用的类型"><a href="#switch能够作用的类型" class="headerlink" title="switch能够作用的类型"></a>switch能够作用的类型</h4><p>从Java7开始，expr:byte\short\int\char\String</p><p>在Java7之前，expr只能为byte\short\int\char</p><p><strong>当一个对象被当作参数传递到一个方法后，此方法可以改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</strong></p><p>是值传递。Java语言的方法中只支持参数的值传递。当一个对象实例被传递到方法中时，参数的值就是该对象的引用。</p><h4 id="String、StringBuilder、StringBuffer的区别"><a href="#String、StringBuilder、StringBuffer的区别" class="headerlink" title="String、StringBuilder、StringBuffer的区别"></a>String、StringBuilder、StringBuffer的区别</h4><p>String是不可变字符串，而StringBuilder、StringBuffer是可变字符串。StringBuilder是Java 5引入的，因此它和StringBuffer的方法完全相同，区别在于StringBuffer的方法都被synchronized修饰是线程安全的，而StringBuilder则是线程不安全的，因此StringBuilder比StringBuffer的效率要高。</p><p> 字符串的+操作其本质是创建了StringBuilder对象进行append操作，然后将拼接后的StringBuilder对象用toString方法处理成String对象</p><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><p>重载和重写都是多态的体现。重载实现的是编译时的多态，发生在同一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或都不同）则视为重载。重写实现的是运行时多态，发生在父类与子类之间，重写要求子类重写的方法与父类被重写的方法有相同的返回值，权限访问符不能低于父类方法的权限访问符，不能比父类方法声明更多的异常。</p><p><strong>为什么不能根据返回类型来区分重载</strong></p><p>原因：调用方法时不能指定具体类型，编译器不知道需要调用哪个函数。</p><h4 id="JVM加载class文件的原理机制"><a href="#JVM加载class文件的原理机制" class="headerlink" title="JVM加载class文件的原理机制"></a>JVM加载class文件的原理机制</h4><p>JVM中的类的加载是由类加载器(ClassLoader)和它的子类实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件的类。</p><p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用到某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把.class文件中的数据读入到内存中，通常是创建一个byte[] 读入数据，然后产生与加载类对应的class对象。加载后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：如果类存在直接父类并且这个类还没有被初始化，那么就先初始化父类；如果类中存在初始化语句，就依次执行这些语句。</p><p>类的加载是由类加载器完成的，类加载器包括：根加载器(BootStrap)、扩展加载器(Extension)、类加载器(System)和用户自定义类加载器。从Java2开始，类加载过程中采取了父亲委托机制(PDM).PDM保证了Java平台的安全性，在该机制中，JVM自带的BootStrap是根加载器，其它的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器进行加载。JVM不会向Java程序提供对BootStrap的引用。</p><h4 id="抽象类和接口有什么异同"><a href="#抽象类和接口有什么异同" class="headerlink" title="抽象类和接口有什么异同"></a>抽象类和接口有什么异同</h4><p>异：</p><ul><li>抽象类中可以定义构造器，而接口不能定义接口</li><li>抽象类中可以定义成员变量，接口里只能定义常量</li><li>抽象类的成员的权限修饰符可以是private、protected、default、public，而接口中的成员都是public</li></ul><p>同：</p><ul><li>都不能实例化</li><li>继承了抽象类，或实现了接口都必须对它们里面的抽象方法进行重写</li></ul><h4 id="Java会存在内存泄漏吗"><a href="#Java会存在内存泄漏吗" class="headerlink" title="Java会存在内存泄漏吗"></a>Java会存在内存泄漏吗</h4><p>理论上Java因为有垃圾回收机制(GC)不会存在内存泄漏问题，然而在实际开发中，存在无用但可达的对象，这些对象，GC不会对其进行垃圾回收，因此也可能会导致内存泄漏。</p><h4 id="抽象方法是否可以是静态的？是否可以是本地方法-native-，是否可同时被synchronized修饰"><a href="#抽象方法是否可以是静态的？是否可以是本地方法-native-，是否可同时被synchronized修饰" class="headerlink" title="抽象方法是否可以是静态的？是否可以是本地方法(native)，是否可同时被synchronized修饰"></a>抽象方法是否可以是静态的？是否可以是本地方法(native)，是否可同时被synchronized修饰</h4><p>抽象方法需要子类重写，静态方法不能被重写；本地方法是由本地代码如(C语言)实现的方法，而抽象方法是，没有实现的；synchronized和方法的实现细节有关，抽象方法不涉及实现细节</p><h4 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="headerlink" title="静态变量和实例变量的区别"></a>静态变量和实例变量的区别</h4><p>静态变量是由static修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中仅有一个拷贝即静态变量只会被加载一次。示例变量必须依存于某一实例，需要先创建对象才可以被访问到，而静态变量可以直接通过类访问。</p><h4 id="如何实现对象克隆"><a href="#如何实现对象克隆" class="headerlink" title="如何实现对象克隆"></a>如何实现对象克隆</h4><ul><li>实现Cloneable接口并重写Object类的clone()方法</li><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">17020286042305L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brand;       <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSpeed;       <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSpeed</span><span class="params">(<span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Car&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;brand=&#x27;&quot;</span> + brand + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, maxSpeed=&quot;</span> + maxSpeed +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, car=&quot;</span> + car +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现Cloneable接口实现浅拷贝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;28394&quot;</span>, <span class="number">19</span>,<span class="keyword">new</span> Car(<span class="string">&quot;大众&quot;</span>,<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student clone = stu.clone();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// true，因为Car对象未实现Cloneable接口</span></span><br><span class="line">            System.out.println(clone.getCar()==stu.getCar());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String uid, <span class="keyword">int</span> age,Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.car=car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.car = car;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, uid=&#x27;&quot;</span> + uid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, car=&quot;</span> + car +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Student <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Student)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现Serializable接口，实现深拷贝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">        <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line"></span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> (T)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCloneUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>,<span class="keyword">new</span> Car(<span class="string">&quot;BMW&quot;</span>,<span class="number">120</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Person clone = MyUtil.clone(p);</span><br><span class="line">            <span class="comment">// true</span></span><br><span class="line">            System.out.println(p.getCar()==clone.getCar());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种方案明显是优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露总是好过把问题留到运行时</p><h4 id="GC是什么？为什么要有GC"><a href="#GC是什么？为什么要有GC" class="headerlink" title="GC是什么？为什么要有GC"></a>GC是什么？为什么要有GC</h4><p>GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃。Java的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p><p>垃圾回收可以有效的防止内存泄漏，合理并有效的使用有效的内存。垃圾回收器通常作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡或长时间未使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。</p><h4 id="String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="String s=new String(“xyz”);创建了几个字符串对象"></a>String s=new String(“xyz”);创建了几个字符串对象</h4><p>两个，一个在字符串常量池，一个new 在堆中</p><h4 id="匿名内部类是否可以继承其它类？是否可以实现接口"><a href="#匿名内部类是否可以继承其它类？是否可以实现接口" class="headerlink" title="匿名内部类是否可以继承其它类？是否可以实现接口"></a>匿名内部类是否可以继承其它类？是否可以实现接口</h4><p>可以继承其它类或实现其它接口，在Swing编程和Adroid开发中常用此方式来实现事件监听和回调</p><p>实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">interfance Product</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String  <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anonymous</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">(Product p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      System.out.println(p.getName()+<span class="string">&quot;--------&quot;</span>+p.getPrice());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [ ] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Anonymous as= <span class="keyword">new</span> Anonymous ();</span><br><span class="line">          as.test(<span class="keyword">new</span> Product( )<span class="comment">//此处实现接口并实现抽象方法</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">( )</span><span class="comment">//实现方法</span></span></span><br><span class="line"><span class="function">                 </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">8888</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                 <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">( )</span><span class="comment">//实现方法</span></span></span><br><span class="line"><span class="function">                  </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="string">&quot;I can do it &quot;</span>;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一个内部类可以引用它的外部类的成员吗？有没有什么限制？"><a href="#一个内部类可以引用它的外部类的成员吗？有没有什么限制？" class="headerlink" title="一个内部类可以引用它的外部类的成员吗？有没有什么限制？"></a>一个内部类可以引用它的外部类的成员吗？有没有什么限制？</h4><p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员</p><h4 id="Java中的final关键字有哪些用法"><a href="#Java中的final关键字有哪些用法" class="headerlink" title="Java中的final关键字有哪些用法"></a>Java中的final关键字有哪些用法</h4><p>修饰类：表示该类不能被继承</p><p>修饰方法：表示方法不能被重写</p><p>修饰变量：表示变量只能被赋值一次，且不能修改</p><h4 id="递归实现字符串反转"><a href="#递归实现字符串反转" class="headerlink" title="递归实现字符串反转"></a>递归实现字符串反转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归反转字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseStr</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reverseStr(str.substring(<span class="number">1</span>))+str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Java和JavaScript的比较"><a href="#Java和JavaScript的比较" class="headerlink" title="Java和JavaScript的比较"></a>Java和JavaScript的比较</h4><p><strong>解释和编译不同</strong>：Java的源代码在执行之前必须经过编译。JavaScript是一种解释型编程语言，其源代码不需要经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT：及时编译技术来提升JavaScript的运行效率）。</p><p><strong>基于对象和面向对象</strong>：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象和事件驱动的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用</p><p><strong>代码格式不一样</strong></p><p><strong>强类型变量和类型若变量：</strong>Java采用强类型变量检查，即所有变量在编译之前必须做声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</p><h4 id="什么时候使用断言-assert-？"><a href="#什么时候使用断言-assert-？" class="headerlink" title="什么时候使用断言(assert)？"></a>什么时候使用断言(assert)？</h4><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError.</p><p>要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或禁用断言。</p><h4 id="Error和Exception有什么区别"><a href="#Error和Exception有什么区别" class="headerlink" title="Error和Exception有什么区别"></a>Error和Exception有什么区别</h4><p>Error是系统级的错误和程序不必处理的异常，是恢复很困难的一种严重问题；比如内存溢出，程序无法处理这种异常。Exception是需要程序捕获和处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p><h4 id="运行时异常与受检异常有何异同"><a href="#运行时异常与受检异常有何异同" class="headerlink" title="运行时异常与受检异常有何异同"></a>运行时异常与受检异常有何异同</h4><p>异常是指程序运行过程中出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><p>使用建议：对可以恢复的情况使用受检异常，对程序错误使用运行时异常</p><h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><ul><li>ArithmeticException：算术异常</li><li>ClassCastException：类型转换异常</li><li>IllegalArgumentException：非法参数异常</li><li>IndexOutOfBoundsException：下标越界</li><li>NullPointerException：空指针异常</li><li>SecurityException：安全异常</li></ul><h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h4><p>Object类中定义的方法，Java允许使用finalize()方法在垃圾回收器将对象从内存中清理出去之前做必要的清理工作，这个方法是由垃圾回收器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或执行其它清理工作</p><h4 id="ArrayList、Vector-、LinkedList的存储性能和特性"><a href="#ArrayList、Vector-、LinkedList的存储性能和特性" class="headerlink" title="ArrayList、Vector 、LinkedList的存储性能和特性"></a>ArrayList、Vector 、LinkedList的存储性能和特性</h4><p>ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入对象，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，所以Vector是线程安全的容器，但效率相对于ArrayList较低。LinkedList使用双向链表的方式实现存储(将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高)，按序号索引数据需要进行向前或向后遍历，但插入数据时只需要记录本项的前后项即可，插入速度较快。</p><p>Vector是遗留容器不推荐使用，ArrayList、LinkedList都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过Collections的synchronized方法将其转换为线程安全的容器后再进行操作(这是对装潢模式的使用，将已有对象传入另一个类的构造器中创建新的对象来增强)</p><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><p>进程是操作系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调用和分派的基本单位，是比进程更小的能独立运行的的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时有通常拥有独立的一块内存单元，而线程只占用很少一部分内存(程序计数器、本地方法栈、Java虚拟机栈)，线程之间可以共享内存。使用多线程的编程通常能带来更好的性能和用户体验，但是多线程的程序对其它程序是不友好的，因为它可能会占用更多的CPU资源。当然也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。</p><h4 id="Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？"><a href="#Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别？" class="headerlink" title="Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？"></a>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别？</h4><p>sleep()方法是线程类(Thread)的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会(CPU)让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会回到就绪状态。</p><p>wait()方法是Object类的方法，调用wait()方法会导致当前线程放弃当前的锁(线程暂停执行)，进入对象的等待池(wait pool)，只有调用对象的notify()\notifyAll()方法时才能唤醒等待池中的线程，当线程重新获得锁时就会进入就绪状态。</p><h4 id="线程的sleep-方法和yield-方法有什么区别"><a href="#线程的sleep-方法和yield-方法有什么区别" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别"></a>线程的sleep()方法和yield()方法有什么区别</h4><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会。</li><li>线程执行sleep()方法后转入阻塞状态；而线程执行yield()方法后进入就绪状态</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常</li><li>sleep()方法比yield()方法(跟操作系统CPU调度相关)具有更好的可移植性</li></ul><h4 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B?</h4><p>不能，其他线程只能访问该对象的非同步方法，同步方法则不能进入。因为synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被占用了，试图进入方法B的线程只能在等锁池中等待。</p><h4 id="请说出与线程同步以及线程调度相关的方法"><a href="#请说出与线程同步以及线程调度相关的方法" class="headerlink" title="请说出与线程同步以及线程调度相关的方法"></a>请说出与线程同步以及线程调度相关的方法</h4><p>wait()：使一个线程进入阻塞状态，并释放所持有的对象的锁</p><p>sleep()：是一个线程进入阻塞状态，是一个静态方法，调用此方法需要处理InterruptedException</p><p>notify()：唤醒一个处于等待状态的线程，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关。（是否随机取决于jvm，hospot中notify()是顺序唤醒的）</p><p>notifyAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让所有线程去竞争锁，获取到锁之后才能进入就绪状态。</p><h4 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h4><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因。</p><p>线程池：事先创建若干个可执行的线程放入一个池中，需要的时候从池中获取线程不用自己创建，使用完毕后不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。</p><p>Java 5+中的Excutor接口定义一个执行线程的工具。它的子类型即线程池接口是ExcutorService。要配置一个线程池是比较复杂的，因此在工具类Excutors里面提供了一些静态工厂方法，生成一些常用的线程池：</p><ul><li>newSingleThreadExcutor:创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。若这个线程异常结束，则会有新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程会补充一个新线程。</li><li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务的所需要的线程，那么会回收部分空闲(60秒不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池的大小做限制，线程池的大小完全依赖于操作系统（或JVM）所能创建的线程大小</li><li>newSchduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li><li>newSingleThreadExcutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h4 id="synchronized和java-util-concurrent-locks-Lock的异同"><a href="#synchronized和java-util-concurrent-locks-Lock的异同" class="headerlink" title="synchronized和java.util.concurrent.locks.Lock的异同"></a>synchronized和java.util.concurrent.locks.Lock的异同</h4><p>同：Lock是Java5以后引入的；Lock能够实现synchronized所实现的所有功能</p><p>异：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，Lock需要手动释放锁，并且最好在finally块中释放</p><h4 id="Java中如何实现序列化"><a href="#Java中如何实现序列化" class="headerlink" title="Java中如何实现序列化"></a>Java中如何实现序列化</h4><p>序列化就是一种用来处理对象流的机制，所谓对象流就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态），如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能实现对象的深度克隆、</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">    oos.writeObject(obj);</span><br><span class="line">    ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">    <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">    <span class="comment">// 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义</span></span><br><span class="line">    <span class="comment">// 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java中有几种类型的流"><a href="#Java中有几种类型的流" class="headerlink" title="Java中有几种类型的流"></a>Java中有几种类型的流</h4><p>字节流：继承于InputStream、OutputStream</p><p>字符流：继承于Reader、Writer</p><p>使用到的设计模式：适配器模式和装饰者模式</p><p>面试题：实现文件拷贝</p><p>用到Java 7的TWR，使用TWR后可以不用在finally中释放外部资源 ，从而让代码更加优雅。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现文件拷贝</span></span><br><span class="line">    <span class="comment">// 传统io流</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String source,String target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis=<span class="keyword">new</span> FileInputStream(source))&#123;</span><br><span class="line">            <span class="keyword">try</span>(FileOutputStream out=<span class="keyword">new</span> FileOutputStream(target))&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nio实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String source,String target)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(FileInputStream fis=<span class="keyword">new</span> FileInputStream(source))&#123;</span><br><span class="line">            <span class="keyword">try</span>(FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(target))&#123;</span><br><span class="line">                FileChannel fisChannel = fis.getChannel();</span><br><span class="line">                FileChannel fosChannel = fos.getChannel();</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">2048</span>);</span><br><span class="line">                <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(fisChannel.read(buffer)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    fosChannel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式"><a href="#XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式" class="headerlink" title="XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式"></a>XML文档定义有几种类型？它们之间有何本质区别？解析XML文档有哪几种方式</h4><p>类型：分为DTD和Schema两种形式，二者都是对XML语法的约束</p><p>本质区别：Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更加强大。</p><p>解析XML文档的方式：</p><ul><li><p>DOM(文档对象模型，Document Object Model)</p><p>处理大型文件时性能下降得非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM的解析方式必须在解析文件之前把整个微博大部分装入内存，适合对XML的随机访问（典型的空间换时间）</p></li><li><p>SAX(Simple API for XML)</p><p>事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束、或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问。</p></li><li><p>StAX(Streaming API for XML)</p><p>把重心放在流上，把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖(SAX就是这样)，但不同之处在于StAX允许应用程序代码把这些这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p></li></ul><h4 id="Statement和PrepareStatement有什么区别？哪个性能更好？"><a href="#Statement和PrepareStatement有什么区别？哪个性能更好？" class="headerlink" title="Statement和PrepareStatement有什么区别？哪个性能更好？"></a>Statement和PrepareStatement有什么区别？哪个性能更好？</h4><p>与Statement相比：</p><ul><li>PreparedStatement接口代表预编译的语句，它的主要优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注入问题）</li><li>PreparedStatement中的SQL语句可以带参数，避免了用字符串连接拼接SQL语句的麻烦和不安全</li><li>当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用重新编译和生成执行计划）</li></ul><h4 id="数据库连接池有什么用"><a href="#数据库连接池有什么用" class="headerlink" title="数据库连接池有什么用"></a>数据库连接池有什么用</h4><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要四次挥手，造成的开销是不可忽略的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免了频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略(浪费了空间存储连接，但节省了创建和释放连接的时间)。</p><h4 id="什么是DAO模式"><a href="#什么是DAO模式" class="headerlink" title="什么是DAO模式"></a>什么是DAO模式</h4><p>DAO(Data Access Object)：顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共APP中。用程序语言来说，就算建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。</p><h4 id="事务的ACID是指什么"><a href="#事务的ACID是指什么" class="headerlink" title="事务的ACID是指什么?"></a>事务的ACID是指什么?</h4><p>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败</p><p>一致性(Consistent)：事务结束前后的系统状态是一致的</p><p>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态</p><p>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</p><p>脏读：A事务读取B事务尚未提交的数据，并在此基础上进行操作，而B执行回滚，那么A读到的数据就是脏数据。</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220230331958.png" class title="image-20211220230331958"><p>不可重复读：当事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220231038292.png" class title="image-20211220231038292"><p>幻读：事务A重新执行一个一个查询，返回一系列符合查询条件，发现其中被插入了被提交的事务B的行</p><p>第一类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220232443615.png" class title="image-20211220232443615"><p>第二类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220232623469.png" class title="image-20211220232623469"><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211220233011476.png" class title="image-20211220233011476"> <p>事务隔离级别和数据访问的并发性是相对的，事务隔离级别越高并发性越差。所以要根据具体的应用来确定合适的事务。</p><h4 id="JDBC中如何进行事务处理"><a href="#JDBC中如何进行事务处理" class="headerlink" title="JDBC中如何进行事务处理"></a>JDBC中如何进行事务处理</h4><p>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显示提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC3.0还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p><h4 id="面向对象的“六原则一法则”"><a href="#面向对象的“六原则一法则”" class="headerlink" title="面向对象的“六原则一法则”"></a>面向对象的“六原则一法则”</h4><p>单一职责原则：一个类只做它该做的事情。</p><p>接口隔离原则：接口要小而专，绝不能大而全。一个接口只应该描述一种能力，接口也应该是高内聚的，比如琴棋书画应该分别设计为4个接口，而不应该设计成为一个接口中的四个方法，因为如果设计成一个接口四个方法，那么这个接口很难用，毕竟琴棋书画都精通的人还是少数，会导致实现该接口的类尽管只会一种也必须实现其它方法</p><p>依赖倒转原则：面向接口编程，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型替代</p><p>里氏替换原则：任何时候都可以使用子类型替换掉父类型</p><p>开闭原则：开闭原则是面向对象编程的最基础、最核心的原则。软件实体应该对提供方扩展开放，对使用者的修改关闭。即当想要增加新功能时，尽量增加新的代码，而不是修改原来的代码。</p><p>合成聚合复用原则：优先使用合成或聚合关系复用代码。</p><p>迪米特法则：又叫最少知识原则，一个对象应该对其它对象的了解尽可能的少。简单来说只与直接朋友打交道。</p><h4 id="简述一下你了解的设计模式"><a href="#简述一下你了解的设计模式" class="headerlink" title="简述一下你了解的设计模式"></a>简述一下你了解的设计模式</h4><p>设计模式：就是一套被反复使用的代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被其他人了解，保证代码可靠性。设计模式使人们可以更加简单方便的复用成功的设计和体系结构。</p><p>工厂模式：工厂类可以根据条件不同生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同方法，但是这些方法针对不同的数据进行了不同的操作（多态方法），当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</p><p>代理模式：给一个对象提供一个代理对象，并用代理对象控制原对象的引用。</p><p>适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起使用的类能够一起工作。</p><p>模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态方法），从而实现不同的业务逻辑</p><h4 id="用java写一个冒泡排序"><a href="#用java写一个冒泡排序" class="headerlink" title="用java写一个冒泡排序"></a>用java写一个冒泡排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sorter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> comp 比较器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, Comparator&lt;T&gt; comp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> <span class="keyword">implements</span> <span class="title">Sorter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BubbleSort bubbleSort = <span class="keyword">new</span> BubbleSort();</span><br><span class="line">        Integer[] arr=<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> swapped=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;arr.length&amp;&amp;swapped ; i++) &#123;</span><br><span class="line">            swapped=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j].compareTo(arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                    swapped=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> swapped=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;arr.length&amp;&amp;swapped ; i++) &#123;</span><br><span class="line">            swapped=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(comp.compare(arr[j],arr[j+<span class="number">1</span>])&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                    swapped=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阐述Servlet和CGI"><a href="#阐述Servlet和CGI" class="headerlink" title="阐述Servlet和CGI"></a>阐述Servlet和CGI</h4><p>Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都会创建一个新的进程，服务完成后就销毁，所以效率比servlet慢。</p><p>CGI因为性能开销上的问题被诟病，但Fast CGI已经解决了这一问题</p><p>FastCGI的工作流程</p><p>  1.Web服务器启动时载入FastCGI进程管理，如IIS的ISAPI、Apache的Module…</p><ol><li>FastCGI进程管理器自身初始化，并启动多个CGI解释器进程<code>php-cgi</code>并等待Web服务器的连接。</li><li>当客户端请求到达Web服务器时，FastCGI进程管理器选择并连接一个CGI解释器，Web服务器将CGI环境变量和标准输入发送到FastCGI子进程PHP-CGI。</li><li>FastCGI子进程完成处理后将标准输出和错误信息，从同一连接返回给Web服务器。当FastCGI子进程关闭连接时请求便处理完毕。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在Web服务器中）的下一个连接。在CGI模式中，PHP-CGI在此便退出了。</li></ol><h4 id="Servlet接口中有哪些方法"><a href="#Servlet接口中有哪些方法" class="headerlink" title="Servlet接口中有哪些方法"></a>Servlet接口中有哪些方法</h4><ul><li>void init(ServletConfig config) throws ServletException</li><li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()</li></ul><p>Servlet的生命周期：</p><ul><li>Web容器加载Servlet并将其实例化，Servlet的生命周期开始</li><li>容器运行其init()方法进行Servlet的初始化</li><li>请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost方法</li><li>当服务器关闭或项目被卸载时服务器会将Servlet的实例销毁，此时会调用Servlet的destory()方法。</li></ul><h4 id="转发-forward-和重定向-redirect-的区别"><a href="#转发-forward-和重定向-redirect-的区别" class="headerlink" title="转发(forward)和重定向(redirect)的区别"></a>转发(forward)和重定向(redirect)的区别</h4><p>转发是容器中控制权的转向，是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，浏览器根本不知道服务器发送的内容从哪儿来的，所以它的地址中还是原来的地址。重定向就是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，因此浏览器的地址栏可以看到重新请求的后的URL，重定向无法访问到服务器保护起来的资源，但是可以从一个网站redirect到另一个网站。转发更加高效，所以在满足需要时尽量使用forward(通过调用RequestDispatcher对象的forward()方法，该对象可以通过ServletRequest对象的getRequestDispatcher()方法获得)。在有些情况需要访问一个其他服务器上的资源，则必须使用重定向(通过HttpServletResponse对象调用其sendRedirect()方法实现)；</p><h4 id="JSP有哪些内置对象？作用分别是"><a href="#JSP有哪些内置对象？作用分别是" class="headerlink" title="JSP有哪些内置对象？作用分别是"></a>JSP有哪些内置对象？作用分别是</h4><p>JSP有9个内置对象</p><ul><li><p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</p></li><li><p>response：封装服务器对客户端的响应；</p></li><li><p>pageContext：通过该对象可以获取其他对象；</p></li><li><p>session：封装用户会话的对象；</p></li><li><p>application：封装服务器运行环境的对象；</p></li><li><p>out：输出服务器响应的输出流对象；</p></li><li><p>config：Web应用的配置对象；</p></li><li><p>page：JSP页面本身（相当于Java程序中的this）；</p></li><li><p>exception：封装页面抛出异常的对象。</p></li></ul><h4 id="什么是ORM"><a href="#什么是ORM" class="headerlink" title="什么是ORM"></a>什么是ORM</h4><p>对象关系映射(Object-Relational Mapping)：是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在Java中可以用xml或注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转化为Java对象，其本质上就是将数据从一种形式转换到另一种形式。</p><h4 id="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"><a href="#持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？"></a>持久层设计要考虑的问题有哪些？你用过的持久层框架有哪些？</h4><p>持久：就是将数据保存到可掉电式存储设备中以便以后使用，就是将内存中的数据保存到关系型数据库、文件系统、消息队列等提供持久化支持的设备中。</p><p>持久层：系统中专注于数据持久化的相对独立的层面</p><p>持久层设计的目标：</p><ul><li>数据存储逻辑分离，提供抽象化的数据访问接口</li><li>数据访问底层实现的分离，可以在不修改代码的情况下切换底层实现</li><li>资源管理和调度的分离，在数据访问层实现统一的资源调度(如缓存机制)</li><li>数据抽象，提供面向对象的数据操作</li></ul><p>持久化框架：</p><ul><li><p>Hibernate</p></li><li><p>MyBatis</p></li><li><p>Spring Data</p></li></ul><h4 id="谈一下你对继承映射的理解"><a href="#谈一下你对继承映射的理解" class="headerlink" title="谈一下你对继承映射的理解"></a>谈一下你对继承映射的理解</h4><p>继承关系的映射策略有三种：</p><ul><li>每个继承结构一张表，不管多少个子类都用一张表</li><li>每个子类一张表，公共信息放一张表，特有信息放单独的表</li><li>每个具体类一张表，有多少个子类就有多少张表</li></ul><p>第一种数据单表策略，其优点在于查询子类对象的时候无需表连接，查询速度快，适合多态查询；缺点是可能导致表很大。后两种方式属于多表策略，其优点在于数据存储紧凑，其缺点是需要进行连接查询，不适合多态查询。</p><h4 id="MyBatis中使用-和-书写占位符的区别："><a href="#MyBatis中使用-和-书写占位符的区别：" class="headerlink" title="MyBatis中使用#和$书写占位符的区别："></a>MyBatis中使用#和$书写占位符的区别：</h4><p>#会将传入的数据都当成一个字符串，会对传入的数据自动加上引号(即会进行预编译)；$将传入的参数直接显示在SQL中。使用$会有SQL注入的问题不安全，所以能用#就不要用$，但是在写order by子句时应该使用$而不是#</p><h4 id="MyBatis中命名空间-namespace-的作用"><a href="#MyBatis中命名空间-namespace-的作用" class="headerlink" title="MyBatis中命名空间(namespace)的作用"></a>MyBatis中命名空间(namespace)的作用</h4><p>在项目中，可能存在大量的SQL语句，这时候对每一个SQL语句起一个唯一的标识(ID)并不容易。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p><h4 id="MyBatis中的动态SQL"><a href="#MyBatis中的动态SQL" class="headerlink" title="MyBatis中的动态SQL"></a>MyBatis中的动态SQL</h4><p>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，此时就需要根据指定的条件动态生成SQL，MyBatis提供了动态SQL的功能来解决这个问题</p><p>MyBatis中用于实现动态SQL的元素主要有：</p><ul><li>if</li><li>choose / when / otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach</li></ul><h4 id="什么是IOC和DI-DI是如何实现的"><a href="#什么是IOC和DI-DI是如何实现的" class="headerlink" title="什么是IOC和DI?DI是如何实现的"></a>什么是IOC和DI?DI是如何实现的</h4><p>IOC(Inversion of Controll)称为控制反转：把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓“控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。</p><p>DI(Dependency Injection)依赖注入：依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IOC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>依赖注入可以通过接口注入、setter()方法注入和构造器注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要提供无参的构造器或无参的静态工厂方法来创建对象。</p><h4 id="Spring中Bean的作用域有哪些"><a href="#Spring中Bean的作用域有哪些" class="headerlink" title="Spring中Bean的作用域有哪些"></a>Spring中Bean的作用域有哪些</h4><p>在Spring早期版本中，仅有两个作用域：singleton和prototype，singleton表示Bean以单例的方式存在；prototype表示每次从容器中调用Bean时，都会返回一个新的实例对象。</p><p>Spring2.x针对WebApplicationContext新增了3个作用域，分别是request（每次HTTP请求都会创建一个新的Bean）、session(同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean)和globalSession(同一个全局session共享一个Bean).</p><p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对线程非安全的对象进行了处理。</p><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>简介：ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。ThreadLocal，顾名思义是线程的一个本地化对象，当工作于多线程的对象使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程分配一个独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不影响其它线程所对应的副本，从线程的角度看，这个变量就像是线程的本地变量。</p><p>ThreadLocal类非常简单好用，只有四个方法，能用上的也就是下面三个方法：</p><ul><li>void set(T value)：设置当前线程的线程局部变量的值。</li><li>T get()：获得当前线程所对应的线程局部变量的值。</li><li>void remove()：删除当前线程中线程局部变量的值。</li></ul><p>在ThreadLocal中有一个Map，键为对象，值是其线程对应的变量的副本，从而实现为每个线程保留一个独立的变量副本。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Thread,T&gt; map=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        map.put(Thread.currentThread(),value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(Thread.currentThread()))&#123;</span><br><span class="line">            map.remove(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal类造成OOM</p><p>首先ThreadLocal里面的ThreadLocalMap类里面的Entry类是继承了弱引用类WeakReference，所以在ThreadLocalMap类里面的key值是使用弱引用方式来链接ThreadLocal的</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20220106180749739.png" class title="image-20220106180749739"><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没用外部强引用引用它，那么系统gc时，这个ThreadLocal将会被回收掉，导致ThreadLocal中就会出现key为null的Entry，就无法访问这些key为null的Entry的value.如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链Thread Ref  Thread  ThreadLocalMap Entry value，永远无法回收，造成内存泄漏。</p><h4 id="什么叫AOP-面向切面编程-？"><a href="#什么叫AOP-面向切面编程-？" class="headerlink" title="什么叫AOP(面向切面编程)？"></a>什么叫AOP(面向切面编程)？</h4><p>AOP(Aspect-Oriented Programming)指一种程序设计范型，该范型以一种称为切面(aspect)的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点。</p><h4 id="如何理解横切关注"><a href="#如何理解横切关注" class="headerlink" title="如何理解横切关注"></a>如何理解横切关注</h4><p>“横切关注”是会影响到整个应用程序的关注功能，它跟正常的业务逻辑没有必然的联系，但是几乎所有的业务逻辑都会涉及到这些关注功能。通常，事务、日志、安全性等关注就是应用中的横切关注功能。</p><h4 id="如何理解AOP中的连接点-Joinpoint-、切点-Pointcut-、增强-Advice-、引介-Introduction-、织入-Weaving-、切面-Aspect-这些概念"><a href="#如何理解AOP中的连接点-Joinpoint-、切点-Pointcut-、增强-Advice-、引介-Introduction-、织入-Weaving-、切面-Aspect-这些概念" class="headerlink" title="如何理解AOP中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念"></a>如何理解AOP中的连接点(Joinpoint)、切点(Pointcut)、增强(Advice)、引介(Introduction)、织入(Weaving)、切面(Aspect)这些概念</h4><p>连接点–joinpoint：程序执行的某个特定位置(如某个方法调用前、调用后，方法抛出异常后)。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</p><p>切点–pointcut：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring的AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</p><p>增强–Advice：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等，很多资料上也称为”通知“，但增强是对Advice较为准确的翻译，我们通过AOP将横切关注功能加到原有的业务逻辑上，这就是对原有业务逻辑的一种增强，这种增强可以是前置增强、后置增强、返回后增强、抛异常时增强和包围型增强。</p><p>引介–Introduction：引介是一种特殊的增强，它为类添加一些属性和方法。这样即使一个业务类原本没有实现某个接口，通过引介功能可以动态的为该业务类添加接口的实现逻辑，让业务类成为这个类的实现类。</p><p>织入–Weaving：织入是将增加添加到目标类具体连接点上的过程，AOP有三种织入方式：</p><ul><li>编译期织入：需要特殊的Java编译期(例如AspectJ的ajc)</li><li>装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强</li><li>运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。</li></ul><p>切面–Aspect：切面是由切点和增强(引介)组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;? extends List&gt; clazz = list.getClass();</span><br><span class="line">        MyProxy&lt;String&gt; stringMyProxy = <span class="keyword">new</span> MyProxy&lt;&gt;(list);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; newList = (List&lt;String&gt;)Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), stringMyProxy);</span><br><span class="line"></span><br><span class="line">        newList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        newList.add(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyProxy</span><span class="params">(List&lt;T&gt; target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object res=<span class="keyword">null</span>;</span><br><span class="line">        System.out.println(method.getName()+<span class="string">&quot;:&quot;</span>+args[<span class="number">0</span>]);</span><br><span class="line">        res=method.invoke(target,args);</span><br><span class="line">        System.out.println(target.size());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spring中自动装配的方式有哪些"><a href="#Spring中自动装配的方式有哪些" class="headerlink" title="Spring中自动装配的方式有哪些"></a>Spring中自动装配的方式有哪些</h4><ul><li>no：不进行自动装配，手动设置Bean的依赖关系</li><li>byName：根据Bean的名字进行自动装配</li><li>byType：根据bean的类型进行自动装配</li><li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误</li><li>autodetect：如果有默认构造器，则通过constructor进行自动装配，否则使用byType的方式进行自动装配。</li></ul><h4 id="Spring中如何使用注解来配置Bean"><a href="#Spring中如何使用注解来配置Bean" class="headerlink" title="Spring中如何使用注解来配置Bean"></a>Spring中如何使用注解来配置Bean</h4><p>需要在Spring的配置文件中增加以下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式"><a href="#Spring支持的事务管理类型有哪些？你在项目中使用哪种方式" class="headerlink" title="Spring支持的事务管理类型有哪些？你在项目中使用哪种方式"></a>Spring支持的事务管理类型有哪些？你在项目中使用哪种方式</h4><p>Spring支持编程式事务管理和声明式事务管理。许多Spring用户选择声明式事务管理，因为这种方式和应用程序的关联少，因此更加符合轻量级容器的概念。声明式事务管理优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p><p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持(如WebLogic、WildFly等)。局部事务和底层采用的JDBC有关，例如使用JDBC进行持久化时，需要使用Connection对象来操作事务。</p><h4 id="如何在Web项目中配置Spring的IOC容器"><a href="#如何在Web项目中配置Spring的IOC容器" class="headerlink" title="如何在Web项目中配置Spring的IOC容器"></a>如何在Web项目中配置Spring的IOC容器</h4><p>在Web项目配置文件web.xml中做出如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">        org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何在Web项目中配置SpringMVC"><a href="#如何在Web项目中配置SpringMVC" class="headerlink" title="如何在Web项目中配置SpringMVC"></a>如何在Web项目中配置SpringMVC</h4><p>要在Web项目中使用SpringMVC需要在web.xml中配置前端控制器DispatcherServlet</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>example<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用*.html的好处：</p><ul><li>使用这种后缀映射，使外界不能够通过URL推断采用了何种服务端的服务</li><li>可以欺骗搜索引擎，因为搜索引擎不会搜索动态页面，这种做法称为伪静态化。</li></ul><h4 id="Spring-MVC的工作原理"><a href="#Spring-MVC的工作原理" class="headerlink" title="Spring MVC的工作原理"></a>Spring MVC的工作原理</h4><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211224210540626.png" class title="image-20211224210540626"><p>解释：</p><ul><li>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求</li><li>HanlderMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找handler</li><li>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器。</li><li>HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等</li><li>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</li><li>Handler让具体的Controller执行</li><li>Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView</li><li>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet</li><li>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名</li><li>视图解析器将解析的逻辑视图名给DispatcherServlet</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图</li><li>最终将视图呈现给用户</li></ul><h4 id="如何在Spring-IOC容器中配置数据源"><a href="#如何在Spring-IOC容器中配置数据源" class="headerlink" title="如何在Spring IOC容器中配置数据源"></a>如何在Spring IOC容器中配置数据源</h4><p>DBCP配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure><p>C3P0配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何配置事务增强"><a href="#如何配置事务增强" class="headerlink" title="如何配置事务增强"></a>如何配置事务增强</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">     http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fooService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.service.DefaultFooService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the transactional advice --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- all methods starting with &#x27;get&#x27; are read-only --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">    of an operation defined by the FooService interface --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;fooServiceOperation&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">expression</span>=<span class="string">&quot;execution(* x.y.service.FooService.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;fooServiceOperation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- don&#x27;t forget the DataSource --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scott&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tiger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- similarly, don&#x27;t forget the PlatformTransactionManager --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- other &lt;bean&gt;&lt;/bean&gt; definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring框架为企业级开发带来的好处"><a href="#Spring框架为企业级开发带来的好处" class="headerlink" title="Spring框架为企业级开发带来的好处"></a>Spring框架为企业级开发带来的好处</h4><ul><li>非侵入式：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类</li><li>IOC容器：IOC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件，而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IOC容器，程序员也不需要自己编写工厂、单例。</li><li>AOP（面向切面编程）：将所有的横切关注功能封装到切面(aspect)中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。</li><li>MVC：Spring的MVC框架是非常优秀的，为Web表示层提供了更好的解决方案。</li><li>事务管理：Spring支持多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。</li><li>其他：Spring为Java企业级开发提供了一站式选择，你可以在需要的时候使用它的部分和全部。</li></ul><h4 id="Spring-IOC容器配置Bean的方式"><a href="#Spring-IOC容器配置Bean的方式" class="headerlink" title="Spring IOC容器配置Bean的方式"></a>Spring IOC容器配置Bean的方式</h4><ul><li>基于XML文件进行配置</li><li>基于注解进行配置</li><li>基于Java程序进行配置</li></ul><h4 id="阐述Spring中Bean的生命周期"><a href="#阐述Spring中Bean的生命周期" class="headerlink" title="阐述Spring中Bean的生命周期"></a>阐述Spring中Bean的生命周期</h4><ul><li>Spring IOC容器找到关于Bean的定义并实例化Bean</li><li>Spring IOC容器对Bean进行依赖注入</li><li>如果Bean实现了BeanNameAware接口，则将该Bean的id传给setBeanName方法</li><li>若Bean实现了BeanFactoryAware接口，则将BeanFactory对象传给setBeanFactory方法</li><li>若Bean实现了BeanPostProcessor接口，则调用其postProcessBeforeInitialization方法。</li><li>若Bean实现了InitializingBean接口，则调用其afterPropertySet方法</li><li>如果有和Bean关联的BeanPostProcessors对象，则这些对象的postProcessAfterInitialization方法被调用</li><li>当销毁Bean实例时，如果Bean实现了DisposableBean接口，则调用destory方法</li></ul><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211225174110619.png" class title="image-20211225174110619"><h4 id="依赖注入时如何注入集合属性"><a href="#依赖注入时如何注入集合属性" class="headerlink" title="依赖注入时如何注入集合属性"></a>依赖注入时如何注入集合属性</h4><p>可以在定义Bean属性时，通过&lt;list&gt;/&lt;set&gt;/&lt;map&gt;/&lt;props&gt;分别为其注入列表、集合、映射和键值都是字符串的映射属性。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanFactoryPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.spring.beanlife.entity.MyBeanFactoryPostProcessor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Spring的自动装配有哪些限制"><a href="#Spring的自动装配有哪些限制" class="headerlink" title="Spring的自动装配有哪些限制"></a>Spring的自动装配有哪些限制</h4><ul><li>使用了构造器注入或者setter注入，那么将覆盖自动装配的依赖关系</li><li>基本数据类型的值、字符串字面量、类字面量无法使用自动装配来注入</li><li>优先考虑使用显式的装配来进行更精确的依赖注入而不是使用自动装配</li></ul><h4 id="在Web项目中如何获得Spring的IOC容器"><a href="#在Web项目中如何获得Spring的IOC容器" class="headerlink" title="在Web项目中如何获得Spring的IOC容器"></a>在Web项目中如何获得Spring的IOC容器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebApplicationContext ctx = </span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br></pre></td></tr></table></figure><h4 id="大型网站在架构上应当考虑哪些问题"><a href="#大型网站在架构上应当考虑哪些问题" class="headerlink" title="大型网站在架构上应当考虑哪些问题"></a>大型网站在架构上应当考虑哪些问题</h4><p><strong>分层：</strong>分层是处理任何复杂系统最常见的手段，将系统横向切分成若干个层面，每个层面只承担单一的职责，然后通过下层为上层提供的基础设施和服务以及上层对下层的调用来形成一个完整的复杂的系统。计算机网络的开放系统互联参考模型(OSI/RM)和Internet的TCP/IP模型都是分层结构，大型网站的软件系统也可以使用分层的理念将其分为持久层(提供数据存储和访问服务)、业务层(处理业务逻辑，系统中最核心的部分)和表示层(系统交互、视图展示)。需要指出的是：分层是逻辑上的划分，在物理上可以位于同一设备上也可以在不同的设备上部署不同的功能模块，这样可以使用更多的计算资源来应对用户的并发访问；层与层之间应该有清晰的边界，这样分层才有意义，才更利于软件的开发和维护。</p><p>**分割:**分割是对软件的纵向切分。我们可以将大型网站的不同功能和服务分割开形成高内聚低耦合的功能模块(单元)。在设计初期可以做一个粗粒度的分割，将网站分割成若干个功能模块，后期还可以进一步对每个模块进行细粒度的分割，这样一方面有助于软件的开发和维护，另一方面有助于分布式的部署，提供网站的并发处理能力和功能的扩展。</p><p><strong>分布式：</strong>网站的静态资源(JavaScript、CSS、图片等)也可以采用独立分布式部署并采用独立的域名，这样可以减轻应用服务器的负载压力，也使得浏览器对资源的加载更快。数据的存取也应该是分布式的，传统的商业级关系型数据库产品基本上都支持分布式部署，而新生的NoSQL几乎都是分布式的。当然，网站后台的业务处理也要使用分布式技术，例如查询索引的构建、数据分析等，这些业务计算规模庞大，可以使用Hadoop以及MapReduce分布式计算框架来处理。</p><p><strong>集群：</strong>集群使得有更多的服务器提供相同的服务，可以更好的提供并发支持</p><p><strong>缓存：</strong>所谓缓存就是用空间换时间的技术，将数据尽可能放在距离计算最近的位置。使用缓存是网站优化的第一定律。我们通常说的CDN、反向代理、热点数据都是对缓存技术的应用。</p><p><strong>异步：</strong>异步是实现软件实体之间解耦的又一重要手段。异步架构是典型的生产者消费者模式，二者没有直接的调用关系，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站的扩展非常有利。使用异步处理还可以提高系统可用性，加快网站的响应速度，同时还可以起到削峰的作用(应对瞬时高并发)。能推迟处理的都要推迟处理，是网站优化的第二定律</p><p><strong>冗余：</strong>各种服务器都要提供相应的冗余服务器以便在某台或者某些服务器宕机时还能保证网站可以正常工作，同时也提供了灾难恢复的可能性。</p><h4 id="你使用过的网站前端优化的技术有哪些"><a href="#你使用过的网站前端优化的技术有哪些" class="headerlink" title="你使用过的网站前端优化的技术有哪些"></a>你使用过的网站前端优化的技术有哪些</h4><ul><li>浏览器优化<ul><li>减少HTTP请求数量：合并CSS、合并JavaScript、合并图片(CSS Sprite)</li><li>使用浏览器缓存：通过设置HTTP响应头中的Cache-Controll和Expires属性，将CSS、JavaScript、图片等在浏览器中缓存，这些静态资源需要更新时，可以更新HTML文件中的引用来让浏览器重新请求新的资源</li><li>启用压缩</li><li>CSS前置，JavaScript后置</li><li>减少Cookie传输</li></ul></li><li>CDN加速：CDN（Content Distribute Network）的本质仍然是缓存，将数据缓存在离用户最近的地方，CDN通常部署在网络运营商的机房，不仅可以提高响应速度，还可以减少应用服务器的压力。CDN缓存的通常是静态资源</li><li>反向代理：反向代理相当于服务器的一个门面，可以保护网站的安全性，也可以实现负载均衡的功能，当然最重要的是它缓存了用户访问的热点资源，可以直接从反向代理将某些内容返回给用户浏览器。</li></ul><h4 id="应用服务器优化技术有哪些"><a href="#应用服务器优化技术有哪些" class="headerlink" title="应用服务器优化技术有哪些"></a>应用服务器优化技术有哪些</h4><ol><li>分布式缓存：缓存的本质就是内存中的哈希表，如果设计一个优质的哈希函数，那么理论上哈希表读写的时间复杂度为O(1)。缓存主要用来存放那些读写比很高、变化很少的数据，这样应用程序读取数据时先到缓存中读取，若缓存中没有需要的数据，再去访问数据库或文件系统，并将得到的数据写入缓存。对网站数据的访问也符合二八定律(Pareto分布，幂律分布)，即80%的访问都集中在20%的数据上，如果能够将这20%的数据缓存起来，那么系统的性能将得到显著的改善。当然使用缓存需要解决以下几个问题：<ul><li>频繁修改的数据不适合做缓存</li><li>数据不一致与脏读(缓存的更新问题)</li><li>缓存雪崩(可以采用分布式缓存服务器集群加以解决)</li><li>缓存击穿(某个热点缓存失效)</li><li>缓存穿透（恶意请求不存在的数据）</li></ul></li><li>异步操作：可以使用消息队列将调用异步化，通过异步处理将短时间高并发产生的事件消息存储在消息队列中，从而起到削峰的作用。电商网站在进行促销活动时，可以将用户的订单请求存入消息队列。这样可以抵御大量的并发订单请求对系统的和数据库的冲击。目前绝大多数的电商网站即便不进行促销活动，订单系统都采用了消息队列来处理。</li><li>使用集群</li><li>代码优化<ul><li>多线程</li><li>非阻塞I/O：使用单线程和非阻塞I/O是目前公认的比多线程的方式更能充分发挥服务器性能的应用模式。</li><li>资源复用：资源复用主要有两种方式，一是单例，二是对象池</li></ul></li></ol><h4 id="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击"><a href="#什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击" class="headerlink" title="什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击"></a>什么是XSS攻击？什么是SQL注入攻击？什么是CSRF攻击</h4><p>XSS（Cross Site Script,跨站脚本攻击）：是向网页中注入恶意脚本在用户浏览网页时在用户浏览器中执行恶意脚本的攻击方式。跨站脚本攻击分为两种形式：反射性攻击（诱使用户点击一个嵌入恶意脚本的链接以达到攻击的目标，目前有很多攻击者利用论坛、微博发布含有恶意脚本的URL）和持久性攻击（将恶意脚本提交到被攻击的网站的数据库中，用户浏览网页时，恶意脚本从数据库中被加载到页面执行）。防范XSS主要有两方面：对危险字符进行转义和HttpOnly（防范XSS攻击者窃取Cookie数据）</p><p>CSRF攻击(Cross Site Request Forgery，跨站请求伪造)：是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。CSRF的原理是利用浏览器的Cookie或服务器的Session，盗取用户身份。防范CSRF的主要手段是识别请求者的身份</p><img src="/2021/11/27/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/image-20211226161400108.png" class title="image-20211226161400108">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面试准备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树转循环链表</title>
      <link href="/2021/11/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/11/16/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-36-二叉搜索树与双向链表"><a href="#剑指-Offer-36-二叉搜索树与双向链表" class="headerlink" title="剑指 Offer 36. 二叉搜索树与双向链表"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/">剑指 Offer 36. 二叉搜索树与双向链表</a></h4><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p><strong>提示：</strong></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>提到二叉搜索树，我们第一时间想到的应该就是中序遍历能得到一个有序的序列，而本题的要求正是有序的所以解题的方法很显然就是使用中序遍历了。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p><strong>迭代：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归解法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       Deque&lt;Node&gt; stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       Node cur=root;</span><br><span class="line">       Node pre=<span class="keyword">null</span>;</span><br><span class="line">       Node head=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               cur=stack.pop();</span><br><span class="line">               <span class="keyword">if</span>(pre==<span class="keyword">null</span>)&#123;</span><br><span class="line">                   pre=cur;</span><br><span class="line">                   head=cur;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   pre.right=cur;</span><br><span class="line">                   cur.left=pre;</span><br><span class="line">               &#125;</span><br><span class="line">               cur=cur.right;</span><br><span class="line">           &#125;</span><br><span class="line">           head.left=pre;</span><br><span class="line">           pre.right=head;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>递归：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node pre,head;</span><br><span class="line">    <span class="comment">// 递归解法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList1</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left=pre;</span><br><span class="line">        pre.right=head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre=root;</span><br><span class="line">            head=root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.right=root;</span><br><span class="line">            root.left=pre;</span><br><span class="line">            pre=root;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数</title>
      <link href="/2021/11/03/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2021/11/03/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 <a href="http://en.wikipedia.org/wiki/Hamming_weight">汉明重量</a>).）。</p><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 11 (控制台输入 00000000000000000000000000001011)</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 128 (控制台输入 00000000000000000000000010000000)</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。</li></ul><p> 记录这个题目不是因为不会做，只是自己碰到的二进制计算相关的题目较少，一时感到很懵，特此记录一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            n=n&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Mybatis出现的问题</title>
      <link href="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>问题一：</p><p>application.yml</p><img src="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20211103005005930.png" class title="image-20211103005005930"><p>在正确配置了数据库配置后，报错</p><img src="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20211103004921745.png" class title="image-20211103004921745"><p>在网上搜索解决办法，但并不适用</p><p>后面在博客评论区看到是因为target中未生成application.yml文件导致报错，仔细查看target文件，发现果然没有生成application.yml文件，</p><img src="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20211103005218217.png" class title="image-20211103005218217"><p>在pom文件中加入后解决问题</p><img src="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20211103005253301.png" class title="image-20211103005253301"><p>问题二：</p><p>Invalid bound statement (not found): com.mjy.chatroom.mapper.UsersMapper.selectByPrimaryKey</p><p>找了很久，以为是写的mapper,xml和接口的映射搞错了，结果是忘记配置mapper-location了。。。。我是傻子</p><img src="/2021/11/03/SpringBoot%E6%95%B4%E5%90%88Mybatis%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/image-20211103010248630.png" class title="image-20211103010248630">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis逆向生成表信息</title>
      <link href="/2021/11/02/mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E8%A1%A8%E4%BF%A1%E6%81%AF/"/>
      <url>/2021/11/02/mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E8%A1%A8%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>首先在idea中下载idea-mybatis-generator插件</p><img src="/2021/11/02/mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E8%A1%A8%E4%BF%A1%E6%81%AF/image-20211102223850537.png" class title="image-20211102223850537"><p>或者导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<a href="http://mybatis.org/generator/configreference/xmlconfig.html">MyBatis Generator Core – MyBatis Generator XML Configuration File Reference</a>复制配置文件代码，稍作修改即可</p><p>文件名称：genertorConfig.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span>    <span class="attr">location</span>=<span class="string">&quot;D:\maven\apache-maven-3.6.3\warehouse\mysql\mysql-connector-java\8.0.21\mysql-connector-java-8.0.21.jar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/im_bird?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;mjy600811&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--避免生成其它库的同名表--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 默认为false，把JDBC DECIMAL 和NUMERIC类型解析为Integer，为true时 把JDBC DECIMAL 和NUMERIC类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--targetProject生成entity的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mjy.chatroom.entity&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：mapper映射文件生成的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mjy.chatroom.mapper.xml&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- targetProject：mapper接口生成的的位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.mjy.chatroom.mapper&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;users&quot;</span> <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span> <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在pom文件中引入依赖并加入插件(SpringBoot项目中)：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis逆向工程--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--配置文件的位置--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generateConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后使用maven工具生成代码即可</p><img src="/2021/11/02/mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E8%A1%A8%E4%BF%A1%E6%81%AF/image-20211102233354057.png" class title="image-20211102233354057"><img src="/2021/11/02/mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90%E8%A1%A8%E4%BF%A1%E6%81%AF/image-20211102233413206.png" class title="image-20211102233413206">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转化数字的最小运算数</title>
      <link href="/2021/10/31/%E8%BD%AC%E5%8C%96%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BF%90%E7%AE%97%E6%95%B0/"/>
      <url>/2021/10/31/%E8%BD%AC%E5%8C%96%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BF%90%E7%AE%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，该数组由 <strong>互不相同</strong> 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p><p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p><p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i</code>（<code>0 &lt;= i &lt; nums.length</code>），可以将 <code>x</code> 设为下述任一值：</p><ul><li><code>x + nums[i]</code></li><li><code>x - nums[i]</code></li><li><code>x ^ nums[i]</code>（按位异或 XOR）</li></ul><p>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</p><p>返回将 <code>x = start</code> 转化为 <code>goal</code> 的最小操作数；如果无法完成转化，则返回 <code>-1</code> 。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3], start = 6, goal = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以按 6 → 7 → 4 的转化路径进行，只需执行下述 2 次运算：</span><br><span class="line">- 6 ^ 1 = 7</span><br><span class="line">- 7 ^ 3 = 4</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,12], start = 2, goal = 12</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算：</span><br><span class="line">- 2 + 12 = 14</span><br><span class="line">- 14 - 2 = 12</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,5,7], start = 0, goal = -4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算：</span><br><span class="line">- 0 + 3 = 3</span><br><span class="line">- 3 - 7 = -4</span><br><span class="line">注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,8,16], start = 0, goal = 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">无法将 0 转化为 1</span><br></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], start = 0, goal = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以按 0 → 1 → 2 → 3 的转化路径进行，只需执行下述 3 次运算：</span><br><span class="line">- 0 + 1 = 1 </span><br><span class="line">- 1 + 1 = 2</span><br><span class="line">- 2 + 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-109 &lt;= nums[i], goal &lt;= 109</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>start != goal</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><p><strong>解题思路：</strong></p><p>这道题题目的意思很明显是一道BFS的题目，但是我开始认为直接暴力肯定会错，所以一直不敢下手，后面看了别人写的代码之后，发现我的思路并没有错，但是也有没有考虑到的地方。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bfs</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 很关键的一步，进行剪枝，若已经访问过该数，则后面再碰到该数直接跳过就行，否则可能进入死循环</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1001</span>];</span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(start);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp==goal)&#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;<span class="number">0</span>||temp&gt;<span class="number">1000</span>||visited[temp])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                    queue.offer(temp+num);</span><br><span class="line">                    queue.offer(temp-num);</span><br><span class="line">                    queue.offer(temp^num);</span><br><span class="line">                &#125;</span><br><span class="line">                visited[temp]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/2021/10/27/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2021/10/27/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>示例:</p><p>现有矩阵 matrix 如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>给定 target = 5，返回 true。</code></p><p><code>给定 target = 20，返回 false。</code></p><p>限制：</p><p><code>0 &lt;= n &lt;= 1000</code></p><p><code>0 &lt;= m &lt;= 1000</code></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先分析题目，大体意思就是判断该二维数组中是否存在所给的target，但很显然题目并不是直接遍历就能AC的，直接遍历很明显会超时。</p><p>那么再来看看所给条件，看是否可以优化查找。题目中指出<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong>，再通过观察，可以发现我们可以找到右上角和左下角的元素是有两个不同的路径的，一边大于当前值一边小于当前值，所以选定其中一点进行遍历，可以以O(max{n,m})的时间复杂度解决问题。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindNumberIn2DArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FindNumberIn2DArray test = <span class="keyword">new</span> FindNumberIn2DArray();</span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#125;;</span><br><span class="line">        System.out.println(test.findNumberIn2DArray(arr, <span class="number">5</span>));</span><br><span class="line">        System.out.println(test.findNumberIn2DArray(arr, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> m=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]&lt;target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&gt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络的空闲时刻</title>
      <link href="/2021/10/17/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB/"/>
      <url>/2021/10/17/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="网络空闲的时刻"><a href="#网络空闲的时刻" class="headerlink" title="网络空闲的时刻"></a>网络空闲的时刻</h2><p><strong>题目：</strong></p><p>给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。</p><p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。</p><p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><p>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。<br>否则，该数据服务器 不会重发 信息。<br>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</p><p>请返回计算机网络变为 空闲 状态的 最早秒数 。</p><p><strong>示例1：</strong></p><img src="/2021/10/17/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB/quiet-place-example1.png" class title="example 1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2]], patience = [0,2,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">0 秒最开始时，</span><br><span class="line">- 数据服务器 1 给主服务器发出信息（用 1A 表示）。</span><br><span class="line">- 数据服务器 2 给主服务器发出信息（用 2A 表示）。</span><br><span class="line"></span><br><span class="line">1 秒时，</span><br><span class="line">- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。</span><br><span class="line">- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。</span><br><span class="line">- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。</span><br><span class="line"></span><br><span class="line">2 秒时，</span><br><span class="line">- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。</span><br><span class="line">- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。</span><br><span class="line">- 服务器 2 重发一条信息（用 2C 表示）。</span><br><span class="line">...</span><br><span class="line">4 秒时，</span><br><span class="line">- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。</span><br><span class="line">...</span><br><span class="line">7 秒时，回复信息 2D 到达服务器 2 。</span><br><span class="line"></span><br><span class="line">从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 8 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure><p><strong>实例2:</strong></p><img src="/2021/10/17/%E7%BD%91%E7%BB%9C%E7%9A%84%E7%A9%BA%E9%97%B2%E6%97%B6%E5%88%BB/network_a_quiet_place_2.png" class title="example 2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：数据服务器 1 和 2 第 2 秒初收到回复信息。</span><br><span class="line">从第 3 秒开始，网络变空闲。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>n == patience.length</li><li>2 &lt;= n &lt;= 105</li><li>patience[0] == 0</li><li>对于 1 &lt;= i &lt; n ，满足 1 &lt;= patience[i] &lt;= 105<br>1 &lt;= edges.length &lt;= min(105, n * (n - 1) / 2)</li><li>edges[i].length == 2</li><li>0 &lt;= ui, vi &lt; n</li><li>ui != vi</li><li>不会有重边。</li><li>每个服务器都直接或间接与别的服务器相连。</li></ul><p><strong>解题思路：</strong></p><p>除开0服务器之外，所有的数据服务器在第一秒都会发送数据，然后等待服务器的响应，若达到patience[i]秒还未接收到响应的信息则需重新发送。</p><p>因此想找到网络变空闲的最早时刻，即找到所有数据服务器中耗费时间最长的那个数据服务器的耗费时间即可解决。</p><p>那么如何求每个服务器耗费的时间呢？</p><p>首先我们需要找到，每个服务器到0服务器的最短路径</p><p>构建邻接表，通过bfs获取最短路径</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n=patience.length;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; graph=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x=edges[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> y=edges[i][<span class="number">1</span>];</span><br><span class="line">    graph.get(x).add(y);</span><br><span class="line">    graph.get(y).add(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] dist=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">visited[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">Deque&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 利用队列实现bfs</span></span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">    List&lt;Integer&gt; subNodes = graph.get(cur);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> subNode : subNodes) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[subNode])&#123;</span><br><span class="line">            dist[subNode]=dist[cur]+<span class="number">1</span>;</span><br><span class="line">            queue.offer(subNode);</span><br><span class="line">            visited[subNode]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到最短距离后，只需要得到最后发送的消息得到响应的时间即可，即</p><p>time=dist[i]×2+(dist[i]×2-1)/patience[i]×patience[i]</p><p><strong>完整代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetrace.race5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 23:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo3 test=<span class="keyword">new</span> Demo3();</span><br><span class="line">        <span class="keyword">int</span>[][] edges=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(test.networkBecomesIdle(edges, arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先使用邻接矩阵，找到0到各个点的最短距离，然后再根据公式计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patience</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkBecomesIdle</span><span class="params">(<span class="keyword">int</span>[][] edges, <span class="keyword">int</span>[] patience)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=patience.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; graph=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x=edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y=edges[i][<span class="number">1</span>];</span><br><span class="line">            graph.get(x).add(y);</span><br><span class="line">            graph.get(y).add(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] dist=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        visited[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        dist[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 利用队列实现bfs</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            List&lt;Integer&gt; subNodes = graph.get(cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> subNode : subNodes) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[subNode])&#123;</span><br><span class="line">                    dist[subNode]=dist[cur]+<span class="number">1</span>;</span><br><span class="line">                    queue.offer(subNode);</span><br><span class="line">                    visited[subNode]=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到从0到个点的最短距离后，通过公式计算</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">            ans=Math.max(ans,dist[i]*<span class="number">2</span>+(dist[i]*<span class="number">2</span>-<span class="number">1</span>)/patience[i]*patience[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bfs,邻接矩阵,最短距离 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习</title>
      <link href="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/10/15/netty%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty学习"><a href="#Netty学习" class="headerlink" title="Netty学习"></a>Netty学习</h1><p><strong>Netty的介绍</strong>：</p><p>Netty是由JBoss提供的一个Java开源框架，现为Github上的独立项目</p><p>Netty是一个<strong>异步的、基于事件驱动的网络</strong>应用框架，用以快速开发高性能、高可靠性的网络IO程序</p><p>Netty主要针对在TCP协议下，面向Clients端的高并发应用或者Peer-to-Peer场景下的大量数据持续传输的应用</p><p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015152755908.png" class title="image-20211015152755908"><p><strong>Netty的应用场景</strong></p><p>互联网行业：</p><p>在分布式系统中，各个节点之间需要远程服务调用，高性能的RPC框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用。</p><p>典型的应用有：阿里分布式服务框架Dubbo的RPC框架使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p><h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p>I/O模型的简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能</p><p>Java共支持三种网络编程模型：BIO、NIO、AIO</p><p><strong>Java BIO：</strong>同步并阻塞（传统阻塞型），服务器实现模式为一个连接为一个线程，及客户端有连接请求时服务器端就需要启动一个线程进行处理，若连接过多且大多线程不进行操作，会造成大量的不必要的开销</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015155749046.png" class title="image-20211015155749046"><p>**Java NIO:**同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接发送的连接请求都会注册到多路复用器上，多路复用器轮询到有I/O请求就进行处理。</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015164215493.png" class title="image-20211015164215493"><p><strong>Java AIO(NIO.2)：</strong>异步非阻塞，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的的应用。</p><p><strong>BIO、NIO、AIO适用场景分析</strong></p><ul><li>BIO方式适用于连接数目比较少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序比较简单易懂</li><li>NIO方式适合<strong>连接数目多且连接比较短的架构</strong>，比如聊天服务器，弹幕系统，服务器间通讯等，编程比较复杂，JDK1.4开始支持</li><li>AIO方式适用于<strong>连接数目多且连接比较长（重操作）</strong>的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li></ul><h3 id="Java-BIO"><a href="#Java-BIO" class="headerlink" title="Java BIO"></a>Java BIO</h3><h4 id="Java-BIO基本介绍"><a href="#Java-BIO基本介绍" class="headerlink" title="Java BIO基本介绍"></a>Java BIO基本介绍</h4><p>Java BIO就是传统的java.io编程，其相关的类和接口在java.io中</p><h4 id="Java-BIO工作机制"><a href="#Java-BIO工作机制" class="headerlink" title="Java BIO工作机制"></a>Java BIO工作机制</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211015171510323.png" class title="image-20211015171510323"><h4 id="BIO实例"><a href="#BIO实例" class="headerlink" title="BIO实例"></a>BIO实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-15 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个线程池</span></span><br><span class="line">            ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                Socket accept = serverSocket.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;连接到一个客户端&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个线程，与客户端进行通信</span></span><br><span class="line">                executorService.execute(()-&gt;&#123;</span><br><span class="line">                    receiveMsg(accept);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            StringBuilder sbl=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span>((len=is.read(arr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程信息：id=&quot;</span>+Thread.currentThread().getId()+<span class="string">&quot;,name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                String s = <span class="keyword">new</span> String(arr, <span class="number">0</span>, len, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                sbl.append(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;关闭和client的连接&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用telnet进行发送消息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet ip port+ctrl+]</span><br></pre></td></tr></table></figure><h4 id="Java-BIO问题分析"><a href="#Java-BIO问题分析" class="headerlink" title="Java BIO问题分析"></a>Java BIO问题分析</h4><ul><li>每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据write</li><li>当并发数较大时，需要<strong>创建大量线程来处理连接，</strong>系统资源占用较大</li><li>连接建立后，如果当前线程没有数据可读，则线程就阻塞在Read操作上，造成线程资源浪费</li></ul><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><h4 id="Java-NIO的基本介绍"><a href="#Java-NIO的基本介绍" class="headerlink" title="Java NIO的基本介绍"></a>Java NIO的基本介绍</h4><p>Java NIO全称 java non-blocking IO，是指JDK提供的新API。从JDK1.4开始，Java提供了一系列改进的输入/输出的新特性，被统称为NIO，是同步非阻塞的。</p><p>NIO相关类都被放在java.nio包及子包下，并且对原Java.io包中的很多类进行改写</p><p>NIO有三大核心部分：Channel(通道)，Buffer(缓冲区)、Selector（选择器）</p><p>NIO是面向缓冲区、面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</p><h4 id="NIO-Buffer的使用"><a href="#NIO-Buffer的使用" class="headerlink" title="NIO Buffer的使用"></a>NIO Buffer的使用</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016112835315.png" class title="image-20211016112835315"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016113403199.png" class title="image-20211016113403199"><h4 id="Buffer的简单操作"><a href="#Buffer的简单操作" class="headerlink" title="Buffer的简单操作"></a>Buffer的简单操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.IntBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Buffer,容量为5</span></span><br><span class="line">        IntBuffer intBuffer=IntBuffer.allocate(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Buffer中存放数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intBuffer.capacity(); i++) &#123;</span><br><span class="line">            intBuffer.put(i*<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将Buffer转换，读写切换</span></span><br><span class="line">        intBuffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(intBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(intBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="NIO与BIO的比较"><a href="#NIO与BIO的比较" class="headerlink" title="NIO与BIO的比较"></a>NIO与BIO的比较</h4><p>BIO是以流的方式进行处理的，NIO是以块的方式进行处理数据，块I/O效率比流I/O方式快很多。</p><p>BIO是阻塞的，NIO是非阻塞的</p><p>BIO基于字节流和字符流进行操作，而NIO基于Channel(通道)和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中，selector(选择器)用于监听多个通道的时间，使单个线程能够监听多个客户端通道。</p><h4 id="Channel、Buffer、Selector之间的关系"><a href="#Channel、Buffer、Selector之间的关系" class="headerlink" title="Channel、Buffer、Selector之间的关系"></a>Channel、Buffer、Selector之间的关系</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016114804608.png" class title="image-20211016114804608"><ul><li>每个Channel都会对应一个Buffer</li><li>Selector对应一个线程，一个Selector可以对应多个Channel</li><li>Selector选择处理哪个Channel是由事件决定的，Even就是一个重要的概念。</li><li>Selector会根据不同的事件，在各个通道上切换</li><li>数据的读取写入是通过Buffer,BIO中要么是输入流，要么是输出流，不能双向，但是NIO的Buffer是可以读也可以写的，但是需要flip方法切换</li><li>Channel是双向的，可以返回底层操作系统的情况，比如Linux,底层的操作系统通道就是双向的</li></ul><h4 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer:缓冲区"></a>Buffer:缓冲区</h4><p>概念：本质上是一个可以读写数据的内存块，可以理解为一个容器对象（含数组），该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够追踪和记录缓冲区的状态变化情况。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。</p><p><strong>api:</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016122029263.png" class title="image-20211016122029263"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016122204266.png" class title="image-20211016122204266"><h4 id="Channel：通道"><a href="#Channel：通道" class="headerlink" title="Channel：通道"></a>Channel：通道</h4><p><strong>基本介绍：</strong></p><p>通道可以同时进行读写，而流只能读或者只能写</p><p>通道可以实现异步读写数据</p><p>通道可以从缓冲中读数据，也可以写数据到缓冲中</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016154019924.png" class title="image-20211016154019924"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016154339505.png" class title="image-20211016154339505"><p><strong>案例一：</strong></p><p>将文字写入到buffer中，再从buffer中读取内容写入到Chanel中，最后将内容写入文件中</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211016160655390.png" class title="image-20211016160655390"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 15:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;hello,尚硅谷&quot;</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个文件输出流</span></span><br><span class="line">            fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取FileChannel</span></span><br><span class="line">            FileChannel channel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个buffer</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将文字内容写入buffer中</span></span><br><span class="line">            byteBuffer.put(str.getBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 切换为读</span></span><br><span class="line">            byteBuffer.flip();</span><br><span class="line"></span><br><span class="line">            channel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>案例二：</strong></p><p>通过buffer读取文件的内容，并打印到控制台上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            FileChannel channel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向缓冲区中写入数据</span></span><br><span class="line">            channel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从缓冲区中获取byte[]</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(byteBuffer.array(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>案例三：</strong></p><p>使用一个buffer实现文件的拷贝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 文件输出流</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取读取的channel</span></span><br><span class="line">            FileChannel inputChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取写的channel</span></span><br><span class="line">            FileChannel outputChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 重要的操作：清空buffer</span></span><br><span class="line">                byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回一个值</span></span><br><span class="line">                <span class="keyword">int</span> read=inputChannel.read(byteBuffer);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(read==-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">                outputChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例四：</strong></p><p>使用FileChannel的transForm方法拷贝文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 利用fileChannel的transform方法拷贝文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 16:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel sourceChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel destChannel=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 文件输出流</span></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel01.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取读取的channel</span></span><br><span class="line">            sourceChannel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取写的channel</span></span><br><span class="line">            destChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            destChannel.transferFrom(sourceChannel,<span class="number">0</span>,sourceChannel.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(destChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    destChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sourceChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sourceChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于Buffer和Channel的注意事项和细节</p><p>Buffer支持类型的put和get,put放入的是数目数据类型，get就应该使用相应的数据类型来取出，否则可能会报<strong>BufferUnderflowException</strong></p><p>可以将一个普通Buffer转换为只读Buffer</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferReadOnly</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        IntBuffer allocate = IntBuffer.allocate(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            allocate.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        allocate.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个只读buffer</span></span><br><span class="line">        IntBuffer rBuffer = allocate.asReadOnlyBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rBuffer.hasRemaining())&#123;</span><br><span class="line">            System.out.println(rBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rBuffer.put(<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NIO还提供了MapperdByteBuffer，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由NIO完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.MappedByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> MappedByteBuffer可让文件直接在内存（堆外内存修改），操作系统不用再拷贝一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-16 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RandomAccessFile randomAccessFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;D:\\JavaLearn\\project\\netty\\netty-demo\\src\\main\\java\\com\\mjy\\file\\channel.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取对应的Channel</span></span><br><span class="line">            FileChannel channel = randomAccessFile.getChannel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第一个参数：FileChannel.MapMode.READ_WRITE：读写模式</span></span><br><span class="line"><span class="comment">             * 第二个参数：起始位置</span></span><br><span class="line"><span class="comment">             * 第三个参数：可修改的byte大小（不能取5）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            map.put(<span class="number">0</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">            map.put(<span class="number">4</span>,(<span class="keyword">byte</span>)<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            randomAccessFile.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功！！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO支持通过多个Buffer完成读写操作</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScatteringAndGatheringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel=<span class="keyword">null</span>;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用ServerSocketChannel和SocketChannel</span></span><br><span class="line">            serverChannel = ServerSocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口到socket并启动</span></span><br><span class="line">            serverChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建buffer数组</span></span><br><span class="line">            ByteBuffer[] buffers=<span class="keyword">new</span> ByteBuffer[<span class="number">2</span>];</span><br><span class="line">            buffers[<span class="number">0</span>]=ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            buffers[<span class="number">1</span>]=ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待客户端连接</span></span><br><span class="line">            socketChannel = serverChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> messageLength=<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环读取</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> byteRead=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(byteRead&lt;messageLength)&#123;</span><br><span class="line">                    <span class="keyword">long</span> read = socketChannel.read(buffers);</span><br><span class="line">                    byteRead+=read;</span><br><span class="line">                    Arrays.asList(buffers).stream().map(buffer-&gt;<span class="string">&quot;position:&quot;</span>+buffer.position()+<span class="string">&quot;,limit：&quot;</span>+buffer.limit())</span><br><span class="line">                            .forEach(System.out::println);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将所有的buffer,进行flip()</span></span><br><span class="line">                Arrays.asList(buffers).forEach(buffer-&gt;buffer.flip());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将数据读出</span></span><br><span class="line">                <span class="keyword">int</span> byteWrite=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(byteWrite&lt;messageLength)&#123;</span><br><span class="line">                    <span class="keyword">long</span> write = socketChannel.write(buffers);</span><br><span class="line">                    byteWrite+=write;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将所有的buffer进行clear</span></span><br><span class="line">                Arrays.asList(buffers).forEach(buffer-&gt;buffer.clear());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;byteWrite=&quot;</span>+byteWrite+<span class="string">&quot;,byteRead=&quot;</span>+byteRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(serverChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Selector：选择器"><a href="#Selector：选择器" class="headerlink" title="Selector：选择器"></a>Selector：选择器</h4><p><strong>基本介绍</strong></p><p>Java的NIO采用的是同步非阻塞的方式，可以用一个线程，处理多个客户端连接，就会使用到Selector(选择器)</p><p>Selector能够检测多个注册通道上是否有事件发生（注意：多个Channel以事件的方式可以注册到同一个Selector）,如果有事件发生，便获取事件然后针对每个事件进行响应的处理。这样就可以只用一个线程管理多个通道，也就是管理多个连接和请求。</p><p>只有在连接/通道真正有读写事件发生时，才会进行读写，这样就大大地减少了系统开销，并且不必为每个连接都创建一个线程。</p><p>避免多线程之间切换的开销</p><p><strong>Selector的方法</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017160455022.png" class title="image-20211017160455022"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017162622361.png" class title="image-20211017162622361"><p>对上面流程图的说明：</p><ul><li>当客户端连接时，会通过ServerSocketChannel获取到SocketChannel</li><li>然后将该SocketChannel注册到Selector中register(Selector sel, int ops)，一个selector可以注册多个Channel</li><li>注册之后会返回一个SelectionKey，会和该Selector关联起来</li><li>Selector进行监听,使用select方法，返回有事件发生的通道个数</li><li>进一步得到各个SelectionKey(有事件发生)</li><li>通过selectionKey获取到对应的Channel</li><li>通过得到的Channel完成业务处理</li></ul><p><strong>示例：</strong></p><p>实现服务器端和客户端之间的数据简单通信（非阻塞）</p><p>NIOClient.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-17 20:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">            <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">                <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接需要时间，客户端不会堵塞，可以做其它工作&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String str=<span class="string">&quot;hello,摸鱼King&quot;</span>;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(str.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line"></span><br><span class="line">            System.in.read();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIOServer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-17 16:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个serverSocketChannel</span></span><br><span class="line">            serverSocketChannel =ServerSocketChannel.open();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个selector</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将serverSocketChannel设置为非阻塞的</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将serverSocketChannel在selector中注册</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 等待1秒，若没有需要处理的事件就继续</span></span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待1秒，未连接&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取需要处理的事件的selectionKeys</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span>(keyIterator.hasNext())&#123;</span><br><span class="line">                    <span class="comment">// 获取selectionKeys</span></span><br><span class="line">                    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                    System.out.println(serverSocketChannel.hashCode());</span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                        <span class="comment">// 获取Channel</span></span><br><span class="line">                        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;客户端连接成功，socketChannel=&quot;</span>+socketChannel.hashCode());</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 设置为非阻塞</span></span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将socketChannel注册到selector，关注事件为OP_READ,同时给socketChannel关联一个buffer</span></span><br><span class="line">                        socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        <span class="comment">// 通过key获取socketChannel</span></span><br><span class="line">                        SocketChannel  channel = (SocketChannel)key.channel();</span><br><span class="line">                        <span class="comment">// 获取到该channel关联的buffer</span></span><br><span class="line">                        ByteBuffer buffer=(ByteBuffer)key.attachment();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 读取数据</span></span><br><span class="line">                        channel.read(buffer);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;from 客户端：&quot;</span>+<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 手动从集合中移除当前的selectionKey，防止重复操作</span></span><br><span class="line">                    keyIterator.remove();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(serverSocketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SelectionKey</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224144733.png" class title="image-20211017224144733"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224251357.png" class title="image-20211017224251357"><p><strong>ServerSocketChannel</strong></p><p>ServerSocketChannel在服务器端监听新的客户端socket连接</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224444616.png" class title="image-20211017224444616"><p><strong>SocketChannel</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211017224728037.png" class title="image-20211017224728037"><h4 id="小Demo"><a href="#小Demo" class="headerlink" title="小Demo"></a>小Demo</h4><p>实现一个非阻塞的多人聊天室</p><p>server端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_ADDRESS=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT=<span class="number">9000</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel=SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST_ADDRESS,PORT));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建selector</span></span><br><span class="line">            selector=Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册到selector中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 得到username</span></span><br><span class="line">            username=socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg=username+<span class="string">&quot;:&quot;</span>+msg;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 得到相关的通道</span></span><br><span class="line">                            SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="comment">// 将数据写入buffer</span></span><br><span class="line">                            sc.read(buffer);</span><br><span class="line">                            <span class="comment">// 读模式</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            chatClient.receiveMsg();</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">            String msg = scan.next();</span><br><span class="line">            chatClient.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 10:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_ADDRESS=<span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> PORT=<span class="number">9000</span>;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChatClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel=SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST_ADDRESS,PORT));</span><br><span class="line">            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建selector</span></span><br><span class="line">            selector=Selector.open();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册到selector中</span></span><br><span class="line">            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            <span class="comment">// 得到username</span></span><br><span class="line">            username=socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg=username+<span class="string">&quot;:&quot;</span>+msg;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                            <span class="comment">// 得到相关的通道</span></span><br><span class="line">                            SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="comment">// 将数据写入buffer</span></span><br><span class="line">                            sc.read(buffer);</span><br><span class="line">                            <span class="comment">// 读模式</span></span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChatClient chatClient = <span class="keyword">new</span> ChatClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端发送的消息</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            chatClient.receiveMsg();</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">            String msg = scan.next();</span><br><span class="line">            chatClient.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h4><p><strong>零拷贝基本介绍：</strong></p><p>零拷贝（指没有CPU拷贝，DMA拷贝无法避免）是网络编程的关键，很多性能优化都离不开</p><p>在Java中常用的零拷贝有mmap(内存映射)和sendFile.</p><p><strong>mmap优化</strong></p><p>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211018120743818.png" class title="image-20211018120743818"><p><strong>sendFile优化</strong></p><p>Linux2.1版本提供了sendFile函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换。</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211018121023667.png" class title="image-20211018121023667"><p>linux在2.4版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer的操作，直接拷贝到协议栈，从而再减少一次数据拷贝。</p><p>但并不是真正意义上的零拷贝，因为其实从内核缓冲区拷贝到Socket buffer的cpu拷贝仍然存在，只是拷贝的信息很少，可以忽略。</p><p><strong>mmap和sendFile的区别</strong></p><ul><li>mmap适合小数据量读写，sendFile适合大文件传输</li><li>mmap需要4次上下文，3次数据拷贝；sendFile需要三次上下文，至少两次数据拷贝。</li><li>sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能</li></ul><p><strong>NIO与零拷贝案例</strong></p><p>上传一个文件</p><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.nio.zerocopy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取socketChannel</span></span><br><span class="line">            socketChannel = SocketChannel.open();</span><br><span class="line"></span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取一个文件输入流</span></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\main\\java\\com\\mjy\\file\\a.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取fileChannel</span></span><br><span class="line">            channel = fis.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接到serverSocketChannel</span></span><br><span class="line">            <span class="keyword">if</span>(socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">                <span class="keyword">long</span> size = channel.size();</span><br><span class="line">                <span class="keyword">double</span> num = Math.ceil((<span class="keyword">double</span>)size / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                System.out.println(num);</span><br><span class="line">                <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">long</span> start=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                    <span class="comment">// 在linux下一个transferTo方法就可以完成传输</span></span><br><span class="line">                    <span class="comment">// 在windows下 一次调用transferTo只能发送8M,就需要分段传输文件，需要注意文件传输的起始位置</span></span><br><span class="line">                    <span class="comment">// transferTo 底层使用零拷贝</span></span><br><span class="line">                    <span class="keyword">long</span> readCount = channel.transferTo(start, <span class="number">1024</span> * <span class="number">1024</span>, socketChannel);</span><br><span class="line">                    total+=readCount;</span><br><span class="line">                    start=total;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">&quot;上传字节数：&quot;</span>+total+<span class="string">&quot;,耗时：&quot;</span>+(end-begin)+<span class="string">&quot;,文件总大小：&quot;</span>+size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-18 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        ServerSocketChannel serverSocketChannel=<span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel=<span class="keyword">null</span>;</span><br><span class="line">        SocketChannel socketChannel=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            serverSocketChannel.socket().bind(inetSocketAddress);</span><br><span class="line"></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\main\\java\\com\\mjy\\file\\video.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">            channel = fos.getChannel();</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line">            <span class="keyword">int</span> read=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                socketChannel = serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>((read=socketChannel.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                    total=total+read;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    channel.write(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(total);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(socketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    channel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(serverSocketChannel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocketChannel.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="原生NIO存在的问题"><a href="#原生NIO存在的问题" class="headerlink" title="原生NIO存在的问题"></a>原生NIO存在的问题</h4><ul><li>NIO的类库和API繁杂，使用比较麻烦</li><li>需要具备其它的额外技能：要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉。</li><li>开发工作量和难度都比较大</li><li>JDK NIO存在一些Bug，例如：Epoll Bug，它会导致Selector空轮询，最终导致CPU100%。直到JDK1.7版本该问题仍然存在。</li></ul><h3 id="Java-AIO"><a href="#Java-AIO" class="headerlink" title="Java AIO"></a>Java AIO</h3><p><strong>基本介绍</strong></p><p>JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程中，常用到两种模式，Reactor和Proactor。Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。</p><p>AIO即NIO2.0，叫做异步不阻塞的I/O.AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty是由JBOSS提供的一个Java开源框架。Netty提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠的网络I/O程序</p><h4 id="线程模型基本介绍"><a href="#线程模型基本介绍" class="headerlink" title="线程模型基本介绍"></a>线程模型基本介绍</h4><p><strong>现存的线程模型：</strong></p><ul><li>传统阻塞I/O服务模型</li><li>Reactor模式<ul><li>单Reactor单线程</li><li>单Reactor多线程</li><li>主从Reactor多线程</li></ul></li><li>Netty线程模式（Netty主要基于主从Reactor对线程模型做了一定的改进，其中主从多线程模型有多个Reactor</li></ul><p><strong>Reactor模式</strong></p><p>又称为：反应器模式、分发者模式、通知者模式</p><p><strong>针对传统阻塞I/O服务模型的缺点，解决方案：</strong></p><p>基于I/O复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无须阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。</p><p>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</p><p><strong>架构图</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019164310180.png" class title="image-20211019164310180"><p><strong>说明：</strong></p><ul><li>Reactor模式，通过一个或多个输入同时传递给服务器处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求，并将它们同步分派到相应的处理线程，因此也称为Dispatcher模式</li><li>Reactor模式使用IO复用监听事件，收到事件后，分发给各个线程（进程）</li></ul><h4 id="单Reactor单线程"><a href="#单Reactor单线程" class="headerlink" title="单Reactor单线程"></a><strong>单Reactor单线程</strong></h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019165718634.png" class title="image-20211019165718634"><p>优点：</p><ul><li>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li></ul><p>缺点：</p><ul><li>性能问题，只有一个线程，无法完全发挥多核CPU的性能。Handler在处理某个连接上的业务时，整个进程无法处理其它连接事件，很容易导致性能瓶颈</li><li>可靠性问题，线程意外终止，或者进入死循环，会导致整个通信模块不可用，不能接收和处理外部消息，造成节点故障。</li></ul><p><strong>使用场景：</strong>客户端的数量有限，业务处理非常快速。</p><h4 id="单Reactor多线程"><a href="#单Reactor多线程" class="headerlink" title="单Reactor多线程"></a>单Reactor多线程</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019171713292.png" class title="image-20211019171713292"><p><strong>说明：</strong></p><ul><li>Reactor对象通过select监控客户端请求事件，收到事件之后，通过dispatcher进行分发</li><li>若是建立连接请求，则Acceptor通过accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由Reactor分发到对应的handler进行处理</li><li>handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的woker线程池的某个线程处理业务</li><li>woker线程池会分配独立线程完成真正的业务，并将结果返回给handler</li><li>handler收到响应后，通过send将结果返回给client </li></ul><p><strong>优点：</strong></p><ul><li>可以充分利用多核cpu的处理能力</li></ul><p><strong>缺点：</strong></p><p>多线程数据共享和访问比较复杂，reactor处理所有事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</p><h4 id="主从Reactor多线程"><a href="#主从Reactor多线程" class="headerlink" title="主从Reactor多线程"></a>主从Reactor多线程</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019174355071.png" class title="image-20211019174355071"><p><strong>说明：</strong></p><ul><li>Reactorz主线程MainReactor对象通过selector监听连接事件，收到事件后，通过Acceptor处理连接事件</li><li>当Acceptor处理连接事件后，MainReactor会将连接分发给subReactor</li><li>subReactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理</li><li>当有新事件发生时，subReactor就会调用对应的handler进行处理</li><li>handler通过read读取数据，分发给后面的woker线程池的某个线程进行业务处理</li><li>woker线程池的某个线程处理完毕后，将结果返回给handler</li><li>handler收到响应的结果后，再通过send将结果返回给client</li><li>Reactor主线程可以对应多个subReactor</li></ul><p><strong>优点：</strong></p><ul><li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li><li>Reactor主线程只需要把新连接传给子线程，之后就不会再有数据交互</li></ul><p><strong>缺点：</strong></p><p>编程复杂度较高</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211019180929888.png" class title="image-20211019180929888"><h4 id="Netty详细模型"><a href="#Netty详细模型" class="headerlink" title="Netty详细模型"></a>Netty详细模型</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211021141306537.png" class title="image-20211021141306537"><p><strong>简单示例-TCP服务</strong>：</p><p>导入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.1</span><span class="number">.63</span>.Final&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 15:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端只需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 添加自定义的handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;客户端准备好了.....&quot;</span>);</span><br><span class="line">            <span class="comment">// 启动客户端</span></span><br><span class="line">            ChannelFuture connect = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭通道事件</span></span><br><span class="line">            connect.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NettyClientHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 15:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 客户端handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪就会触发该方法,向服务端发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client ctx：&quot;</span>+ctx);</span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,服务端&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时读取服务端发送的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf=(ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器回复的消息&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务器地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建BossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">// 创建两个线程组bossGroup和workerGroup</span></span><br><span class="line">        <span class="comment">// bossGroup负责处理连接请求，workerGroup处理客户端的业务请求</span></span><br><span class="line">        <span class="comment">// bossGroup下的NioEventLoop的数量默认为电脑核数*2，可以自己设定</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的启动对象,配置参数</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 设置NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端准备好了.....&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">// 启动服务器并绑定端口</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>NettyServerHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.simple;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义handler 需要继承netty规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-21 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx ：上下文对象，含有管道pipline,通道channel，地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg：就是客户端发送的数据，默认为Object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器线程：&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx：&quot;</span>+ctx);</span><br><span class="line">        <span class="comment">// 将msg转换成一个ByteBuf</span></span><br><span class="line">        <span class="comment">// ByteBuf是netty提供的，不是NIO的ByteBuffer</span></span><br><span class="line">        ByteBuf buf=(ByteBuf)msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送的消息是：&quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端的地址为：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将数据写入到缓存，并刷新（刷新到管道中）</span></span><br><span class="line">        <span class="comment">// 一般需要对发送的消息进行编码</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,客户端！&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，一般是关闭通道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="TaskQueue"><a href="#TaskQueue" class="headerlink" title="TaskQueue"></a>TaskQueue</h4><p><strong>任务队列中的Task有三种典型使用场景</strong></p><ul><li><p>用户程序自定义的普通任务</p><p>示例：</p><p>NettyServerHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若我们有一个非常耗时的业务，就需要异步执行，将该操作提交到该Channel对应的NioEventLoop的TaskQueue中去</span></span><br><span class="line">        <span class="comment">// 若不异步执行，会发生阻塞</span></span><br><span class="line">        <span class="comment">// 解决办法1：用户自定义的普通任务</span></span><br><span class="line">        ctx.channel().eventLoop().execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;异步处理的业务&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>注：当需要处理异步任务时，可以将需要处理的任务放到Channel中的eventLoop中的TaskQueue中，可以添加多个异步任务，但因为使用的是同一个线程添加异步任务，所以执行的异步任务在TaskQueue中执行是同步的。</p></li><li><p>用户自定义的定时任务</p><p>示例：</p><p>NettyServerHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户自定义定时服务</span></span><br><span class="line">        ctx.channel().eventLoop().schedule(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;异步处理的业务1&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li><li><p>非当前Reactor线程调用Channel的各种方法</p><p>例如：在推送系统的业务线程里面，根据用户的标识找到对应的Channel引用，然后调用Write类方法向该用户推送消息，就会进入到这种场景。最终的Write会提交到任务队列终被异步消费</p><p>示例：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup) <span class="comment">// 设置两个线程组</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class) <span class="comment">// 设置NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 设置线程队列得到连接个数</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>) <span class="comment">// 设置保持活动连接状态</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">// 给pipeline设置处理器</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 可以使用一个集合管理SocketChannel,再推送消息的时，将推送业务加入到channel的eventLoop中的taskQueue或ScheduledTaskQueue</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure></li></ul><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022181516402.png" class title="image-20211022181516402"><h4 id="异步模型"><a href="#异步模型" class="headerlink" title="异步模型"></a>异步模型</h4><p><strong>基本介绍</strong></p><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p><p>Netty中的I/O操作是异步的，包括Bind、write、connect等操作会简单的返回一个ChannelFuture</p><p>调用者并不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果</p><p>Netty的异步模型是建立在future和callback的之上的。callback就是回调。重点说Future，它的核心思想：假设一个方法fun,计算过程可能很耗时，等待fun返回结果显然不合适。那么可以在调用fun的时候，立马返回一个future，或许可以通过Future去监控方法fun的处理过程</p><p><strong>Future说明</strong></p><ul><li>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成，比如检索计算等</li><li>ChannelFuture是一个接口，我们可以添加监听器，当监听的事件发生时，就会通知到监听器</li></ul><p><strong>Future-Listener机制</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022232452807.png" class title="image-20211022232452807"><p>例子：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">           <span class="comment">// 启动服务器并绑定端口</span></span><br><span class="line">           ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 添加监听器</span></span><br><span class="line">           channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line"></span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span>(channelFuture.isSuccess())&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务器绑定 6668成功&quot;</span>);</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;服务器绑定 6668失败&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>异步好处：</p><p>相比传统阻塞I/O,执行I/O操作后线程会被阻塞，直到操作完成；异步处理的好处是不会造成阻塞，线程在I/O操作期间可以执行别的程序，在高并发清醒下会更稳定和更高的吞吐量。</p><h4 id="快速入门示例-HTTP服务"><a href="#快速入门示例-HTTP服务" class="headerlink" title="快速入门示例-HTTP服务"></a>快速入门示例-HTTP服务</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211022233711808.png" class title="image-20211022233711808"><p>客户端：浏览器，不用写</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-22 23:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup=<span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 配置启动类对象</span></span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestHttpServerInitializer());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            ChannelFuture cf = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对关闭通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>handler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.Unpooled;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.CharsetUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-22 23:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// SimpleChannelInboundHandler是ChannelInboundHandler的子类</span></span><br><span class="line"><span class="comment">// HttpObject:客户端与服务端通信的数据被封装为HttpObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断msg是否是HttpRequest</span></span><br><span class="line">        <span class="keyword">if</span>(msg <span class="keyword">instanceof</span> HttpRequest)&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;msg 类型：&quot;</span>+msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;客户端地址：&quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 服务器会接收到两次请求，需要过滤掉http://localhost:9000/favicon.ico</span></span><br><span class="line">            HttpRequest request =(HttpRequest)msg;</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(request.uri());</span><br><span class="line">            System.out.println(uri);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath()))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;服务器接受到/favicon.ico的请求，不响应&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回复信息给浏览器</span></span><br><span class="line">            ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello,我是服务器&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造一个http的响应，即httpResponse</span></span><br><span class="line">            DefaultHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, byteBuf);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE,<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH,byteBuf.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息给客户端</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.mjy.netty.http;</span><br><span class="line"></span><br><span class="line">import io.netty.channel.ChannelInitializer;</span><br><span class="line">import io.netty.channel.ChannelPipeline;</span><br><span class="line">import io.netty.channel.socket.SocketChannel;</span><br><span class="line">import io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author</span><br><span class="line"> * @description</span><br><span class="line"> * @create 2021-10-22 23:44</span><br><span class="line"> */</span><br><span class="line">public class TestHttpServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        // 向管道中加入handler</span><br><span class="line">        // 得到管道</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        // 加入一个netty提供的httpServerCodec codec -&gt; coder decoder</span><br><span class="line">        // HttpServerCodec：netty提供的编-解码器</span><br><span class="line">        pipeline.addLast(&quot;MyHttpServerCodec&quot;,new HttpServerCodec());</span><br><span class="line"></span><br><span class="line">        // 增加一个自定义handler</span><br><span class="line">        pipeline.addLast(&quot;myHttpServerHandler&quot;,new TestHttpServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024134309376.png" class title="image-20211024134309376"><h4 id="Pipeline和ChannelPipeline"><a href="#Pipeline和ChannelPipeline" class="headerlink" title="Pipeline和ChannelPipeline"></a>Pipeline和ChannelPipeline</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024140557169.png" class title="image-20211024140557169"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024141225689.png" class title="image-20211024141225689"> <h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024143115758.png" class title="image-20211024143115758"><h4 id="ChannelOption"><a href="#ChannelOption" class="headerlink" title="ChannelOption"></a>ChannelOption</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024143326063.png" class title="image-20211024143326063"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024144323040.png" class title="image-20211024144323040"><h4 id="Unpooled类"><a href="#Unpooled类" class="headerlink" title="Unpooled类"></a>Unpooled类</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211024144752282.png" class title="image-20211024144752282"><p><strong>基本使用：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBuf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ByteBuf</span></span><br><span class="line">        <span class="comment">// 创建 对象：该对象包含一个数组arr，是一个byte[10]</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            buffer.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// netty的buffer中，不需要使用flip进行反转</span></span><br><span class="line">        <span class="comment">// 原因：netty的buffer底层维护了readerIndex和writerIndex</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;</span><br><span class="line">            System.out.println(buffer.readByte());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyBuf1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">&quot;my dear friends&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buf.hasArray())&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] array = buf.array();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(array,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从哪个下标开始读</span></span><br><span class="line">            System.out.println(buf.readerIndex());</span><br><span class="line">            <span class="comment">// 从哪个下标开始写</span></span><br><span class="line">            System.out.println(buf.writerIndex());</span><br><span class="line">            <span class="comment">// 可以读取的元素的长度</span></span><br><span class="line">            System.out.println(buf.readableBytes());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="netty实现多人聊天室"><a href="#netty实现多人聊天室" class="headerlink" title="netty实现多人聊天室"></a>netty实现多人聊天室</h4><p>功能：能够实现多人聊天、上下线提示以及加入群聊提示和离开群聊提示</p><p><strong>服务器端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 15:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverStrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverStrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 向pipeline中添加解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 向pipeline中添加编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;serverHandler&quot;</span>,<span class="keyword">new</span> GroupChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务器</span></span><br><span class="line">            ChannelFuture channelFuture = serverStrap.bind(port).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer(<span class="number">9000</span>);</span><br><span class="line">        groupChatServer.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器端的handler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.mjy.netty.groupchat.entity.User;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.ChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.group.DefaultChannelGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个Channel组，管理所有的channel</span></span><br><span class="line">    <span class="comment">// GlobalEventExecutor.INSTANCE：全局的事件执行器，是一个单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup=<span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;User,Channel&gt; channelMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// handlerAdded表示连接建立，一旦连接，第一个被执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入QQ号：&quot;</span>);</span><br><span class="line">        String id=scan.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入姓名：&quot;</span>);</span><br><span class="line">        String name=scan.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入昵称：&quot;</span>);</span><br><span class="line">        String nickname=scan.next();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setNickname(nickname);</span><br><span class="line"></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelMap.put(user,channel);</span><br><span class="line">        <span class="comment">// 将该客户加入聊天的信息推送给其它在线的客户</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;【客户端】&quot;</span>+channel.remoteAddress()+<span class="string">&quot;加入聊天~&quot;</span>);</span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示断开连接，将客户离开的信息推送给当前在线的客户</span></span><br><span class="line">    <span class="comment">// 执行该方法，会自动将channel从channelGroup中移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;离开\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel处于活动状态，提示上线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;：&quot;</span>+sdf.format(<span class="keyword">new</span> Date())+<span class="string">&quot;上线~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示channel处于非活动状态，提示下线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;：&quot;</span>+sdf.format(<span class="keyword">new</span> Date())+<span class="string">&quot;下线~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;[客户端]&quot;</span>+channel.remoteAddress()+<span class="string">&quot;发送消息：&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将所发消息发送给其它客户</span></span><br><span class="line">        channelGroup.forEach(ch-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(channel!=ch)&#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">&quot;[客户]&quot;</span>+channel.remoteAddress()+msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-24 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">(String host,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host=host;</span><br><span class="line">        <span class="keyword">this</span>.port=port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>,<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>,<span class="keyword">new</span> StringEncoder());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务的handler</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;clientHandler&quot;</span>,<span class="keyword">new</span> GroupChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            ChannelFuture channelFutrue = bootstrap.connect(host, port).sync();</span><br><span class="line">            Channel channel = channelFutrue.channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;-----------&quot;</span>+channel.localAddress()+<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">                String message = scanner.next();</span><br><span class="line">                channel.writeAndFlush(message);</span><br><span class="line">            &#125;</span><br><span class="line">            scanner.close();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFutrue.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatClient groupChatClient = <span class="keyword">new</span> GroupChatClient(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        groupChatClient.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端handler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h4><p>通过添加IdleStateHandler实现每隔一段时间（若服务器无相应操作）发送心跳检测包检测当前连接是否断开</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入netty提供的IdleStateHandler</span></span><br><span class="line">                            <span class="comment">// IdleStateHandler是netty提供的处理空闲状态的处理器</span></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            long readerIdleTime：表示多长时间没读，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                            long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否连接</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 加入一个对空闲处理的handler</span></span><br><span class="line">                            <span class="comment">// 当IdleStateEvent触发后，就会传递给管道的下一个handler去处理，通过调用下一个handler的userEventTiggered方法</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HeartServerHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handler：处理空闲检测</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *处理空闲检测</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evt：事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(evt <span class="keyword">instanceof</span> IdleStateEvent)&#123;</span><br><span class="line">            IdleStateEvent event = (IdleStateEvent)evt;</span><br><span class="line">            String tips=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">switch</span>(event.state())&#123;</span><br><span class="line">                <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;读空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                    tips=<span class="string">&quot;读写空闲&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ctx.channel().remoteAddress()+<span class="string">&quot;---超时---：&quot;</span>+tips);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211025112119832.png" class title="image-20211025112119832"><p><strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG,<span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE,<span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 基于http协议，使用http的编码和解码</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 是以块方式写，添加ChunkedWriteHandler处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// http数据在传输过程中是分段的，HttpObjectAggregator可以将多个段聚合</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            对应webSocket，它的数据是以帧进行传递的</span></span><br><span class="line"><span class="comment">                            浏览器请求时：ws://localhost:9000/hello 表示请求的url</span></span><br><span class="line"><span class="comment">                            WebSocketServerProtocolHandler 核心功能是将http请求升级为ws请求，保持长连接</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/hello&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 处理业务逻辑，自定义handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> TextWebSocketFrameHandler());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>实现业务的自定义handler</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器收到消息：&quot;</span>+msg.text());</span><br><span class="line">        <span class="comment">// 服务器回复消息</span></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">&quot;当前时间：&quot;</span>+ LocalDateTime.now()+msg.text()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户端连接后触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// LongText：是唯一的，shortText不是唯一的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用：&quot;</span>+ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerAdded被调用：&quot;</span>+ctx.channel().id().asShortText());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当web客户段断开连接后触发方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved被调用：&quot;</span>+ctx.channel().id().asLongText());</span><br><span class="line">        System.out.println(<span class="string">&quot;handlerRemoved被调用：&quot;</span>+ctx.channel().id().asShortText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>聊天框：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> socket;</span><br><span class="line">    <span class="comment">// 判断当前浏览器是否支持webSocket</span></span><br><span class="line">    <span class="keyword">if</span>(window.WebSocket)&#123;</span><br><span class="line">        socket=<span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9000/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于channelReado,ev收到服务器端回送的消息</span></span><br><span class="line">        socket.onmessage=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=content.value+ev.data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于连接开启</span></span><br><span class="line">        socket.onopen=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=<span class="string">&quot;连接开启~&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 相当于连接关闭</span></span><br><span class="line">        socket.onclose=function(ev)&#123;</span><br><span class="line">            <span class="keyword">var</span> content=document.getElementById(<span class="string">&quot;responseText&quot;</span>);</span><br><span class="line">            content.value=content.value+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;连接关闭了&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;当前浏览器不支持webSocket&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">send</span><span class="params">(message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!window.socket)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(socket.readyState==WebSocket.OPEN)&#123;</span><br><span class="line">            <span class="comment">// 通过socket发送消息</span></span><br><span class="line">            socket.send(message);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&quot;连接没有开启&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">function <span class="title">clearContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        document.getElementById(<span class="string">&quot;responseText&quot;</span>).value=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;form onsubmit=<span class="string">&quot;return false&quot;</span>&gt;</span><br><span class="line">    &lt;textarea name=<span class="string">&quot;message&quot;</span> style=<span class="string">&quot;width:300px;height:100px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;发送消息&quot;</span> onclick=<span class="string">&quot;send(this.form.message.value)&quot;</span>&gt;</span><br><span class="line">    &lt;textarea id=<span class="string">&quot;responseText&quot;</span> style=<span class="string">&quot;width:300px;height:100px&quot;</span>&gt;&lt;/textarea&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;清空内容&quot;</span> onclick=<span class="string">&quot;clearContent()&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="netty编码和解码的基本介绍"><a href="#netty编码和解码的基本介绍" class="headerlink" title="netty编码和解码的基本介绍"></a>netty编码和解码的基本介绍</h4><p>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时便需要解码</p><p>codec（编码器）的组成：decoder(解码器)和encoder(编码器)</p><p>netty本身自带的ObjectDecoder和ObjectEncoder可以用来实现对象的编码和解码，底层使用的仍是Java序列化操作，而Java序列化操作技术本身效率并不高，存在以下问题：</p><ul><li>无法跨语言</li><li>序列化后体积太大，是二进制编码的5倍多</li><li>序列化效率太低</li></ul><p><strong>解决方案：Google的protobuf</strong></p><p>protobuf是Google发布的开源项目，全称Google Protocol Buffers，是一种轻便高效的结构化数据存出格式，开源用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC[远程过程调用 remote proceduce call] 数据交换格式。</p><p>Protobuf是以message的方式来管理数据的</p><p>支持跨平台、跨语言</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211025234656688.png" class title="image-20211025234656688"><p>使用示例：</p><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> optimize_for=SPEED; <span class="comment">// 加快解析</span></span><br><span class="line"><span class="keyword">option</span> java_package=<span class="string">&quot;com.mjy.netty.codec1&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname=<span class="string">&quot;MyDataInfo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// protobuf 可以使用message 管理其他的message</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span></span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个枚举类型</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">DataType</span></span>&#123;</span><br><span class="line">    StudentType=<span class="number">0</span>; <span class="comment">// 在proto3要求enum编号从0开始</span></span><br><span class="line">    WorkerType=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用data_type来标识传的是哪一个枚举类型</span></span><br><span class="line">  DataType data_type=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示每次枚举类型最多只能出现其中的一个，节省空间</span></span><br><span class="line">  <span class="keyword">oneof</span> dataBody&#123;</span><br><span class="line">    Student student=<span class="number">2</span>;</span><br><span class="line">    Worker worker=<span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Worker</span></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> name=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> age=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用protoc.exe进行编译生成Java文件</p><h4 id="netty的入站和出站"><a href="#netty的入站和出站" class="headerlink" title="netty的入站和出站"></a>netty的入站和出站</h4><p>示例：</p><p><strong>Netty的handler的调用机制</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211027105623769.png" class title="image-20211027105623769"><p><strong>服务器端：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> InAndOutChannelInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取pipeline</span></span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入入站的自定义解码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyByteToLongDecoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入出站的自定义编码器</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyLongToByteEncoder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加入自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> InAndOutServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InAndOutServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Long msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;从客户端发送过来的Long类型的数据：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编码器和解码器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *decode 会根据接收的数据，被调用多次，直到确定没有新的元素被添加到List，或是ByteBuf没有更多的可读字节为止</span></span><br><span class="line"><span class="comment">     * 如果list out不为空，就会将该list的内容传递给下一个channelinboundhandler处理，该处理器的方法也会被调用多次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> in 入站的ByteBuf</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out List集合，将解码后的数据传递给下一个handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否可读的有8个字节，若有8个字节，读取为long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes()&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyLongToByteEncoder被调用：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;编码信息：&quot;</span>+msg);</span><br><span class="line">        <span class="comment">// 将long类型编码成为ByteBuf</span></span><br><span class="line">        <span class="comment">// 要注意传入的数据类型，若不是我们定义的类型，那么这个方法不会执行</span></span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>客户端与服务器端代码类似，略</p><p><strong>结论：</strong></p><ul><li>不论解码器handler还是编码器handler接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行</li><li>在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够，否则接收到的信息可能会与期望的结果不一样</li></ul><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029145159607.png" class title="image-20211029145159607"><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029145240654.png" class title="image-20211029145240654"><p><strong>LengthFieldBasedFrameDecoder解码器</strong></p><p>几个重要的属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 长度字段偏移量</span><br><span class="line">private final int lengthFieldOffset;</span><br><span class="line">// 长度字段长度</span><br><span class="line">private final int lengthFieldLength;</span><br><span class="line">// 长度字段为基准，还有几个字节是内容</span><br><span class="line">private final int lengthFieldEndOffset;</span><br><span class="line">// 从头剥离几个字节</span><br><span class="line">private final int lengthAdjustment;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLengthFieldDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">                <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        send(buffer, <span class="string">&quot;hi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        embeddedChannel.writeInbound(buffer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ByteBuf buffer, String content)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = content.getBytes();</span><br><span class="line">        <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">        buffer.writeInt(length);</span><br><span class="line">        <span class="comment">// 若还加入其它信息，需要设置lengthFieldEndOffset参数</span></span><br><span class="line">        buffer.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Log4j整合到Netty"><a href="#Log4j整合到Netty" class="headerlink" title="Log4j整合到Netty"></a>Log4j整合到Netty</h4><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写log4j.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,stdout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">[%P] %C&#123;1&#125; - %m%n</span></span><br></pre></td></tr></table></figure><p><strong>输出格式的参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%m   输出代码中指定的消息</span><br><span class="line">%p   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL </span><br><span class="line">%r   输出自应用启动到输出该log信息耗费的毫秒数 </span><br><span class="line">%c   输出所属的类目，通常就是所在类的全名 </span><br><span class="line">%t   输出产生该日志事件的线程名 </span><br><span class="line">%n   输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” </span><br><span class="line">%d   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss , SSS&#125;，输出类似：<span class="number">2002</span>年<span class="number">10</span>月<span class="number">18</span>日  <span class="number">22</span> ： <span class="number">10</span> ： <span class="number">28</span> ， <span class="number">921</span>  </span><br><span class="line">%l   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: <span class="number">10</span> ) </span><br></pre></td></tr></table></figure><h4 id="TCP粘包和拆包的基本介绍"><a href="#TCP粘包和拆包的基本介绍" class="headerlink" title="TCP粘包和拆包的基本介绍"></a>TCP粘包和拆包的基本介绍</h4><p>TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务端）都要有一一成对的socket，因此发送端为了将多个发给接收端的包，更有效的发送给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量较少的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就很难分辨出完整的数据包了，因为面向流的通信是无消息保护边界的。</p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211029155828671.png" class title="image-20211029155828671"><p><strong>粘包和拆包-滑动窗口</strong></p><p>TCP以一个端为单位，每发送一个段就需要进行一次确认应答（ack处理），但如果这么做，缺点是包的往返时间越长性能就越差。</p><p>为了解决此问题，引入了窗口的概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值。</p><p><strong>窗口实际上就起到了一个缓冲区的作用，同时也能起到流量控制的作用</strong></p><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211030172645841.png" class title="image-20211030172645841"><ul><li>窗口内的数据，不需要应答就能发送</li><li>若窗口这个段的数据的ack回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收。</li></ul><p><strong>TCP粘包和拆包实例演示</strong></p><p>MyClient.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> MyClientInitializer());</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyInitializer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyClientHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyClientHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ByteBuf byteBuf = Unpooled.copiedBuffer(<span class="string">&quot;hello server_&quot;</span> + i, CharsetUtil.UTF_8);</span><br><span class="line">            ctx.writeAndFlush(byteBuf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(arr);</span><br><span class="line">        String s = <span class="keyword">new</span> String(arr, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到来自服务端的消息：&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的数据量为：&quot;</span>+(++<span class="keyword">this</span>.count));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyServer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> MyServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 监听关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyServerHandler.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[msg.readableBytes()];</span><br><span class="line">        msg.readBytes(arr);</span><br><span class="line">        String s = <span class="keyword">new</span> String(arr, CharsetUtil.UTF_8);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端接收到了客户端的信息：&quot;</span>+s);</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息量：&quot;</span>+(++<span class="keyword">this</span>.count));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务器回送数据给客户端</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + <span class="string">&quot; &quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line">        ctx.writeAndFlush(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyServerInitializer.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> MyServerHandler());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/15/netty%E5%AD%A6%E4%B9%A0/image-20211030111255728.png" class title="image-20211030111255728"><p>服务器接收数据时，不一定每一次的接收都相同。</p><p><strong>解决方案：</strong></p><ul><li><p>使用自定义协议包+编解码</p><p>自定义协议包：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MessageProtocol &#123;</span><br><span class="line">    private int len;</span><br><span class="line">    private byte[] content;</span><br><span class="line"></span><br><span class="line">    public int getLen() &#123;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLen(int len) &#123;</span><br><span class="line">        this.len = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public byte[] getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(byte[] content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyMessageEncoder被调用&quot;</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解码器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = in.readInt();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        MessageProtocol messageProtocol = <span class="keyword">new</span> MessageProtocol();</span><br><span class="line">        messageProtocol.setLen(len);</span><br><span class="line">        messageProtocol.setContent(bytes);</span><br><span class="line">        out.add(messageProtocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决粘包和拆包的关键在于每次读取数据长度的问题，解决了数据长度的问题就不会出现服务器多读和少读的问题，就不会出现粘包和拆包的问题。</p></li></ul><h4 id="协议设计与解析"><a href="#协议设计与解析" class="headerlink" title="协议设计与解析"></a>协议设计与解析</h4><p><strong>实现Redis RESP协议</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRedisProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] LINE=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">13</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup eventGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            bootstrap.group(eventGroup)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LoggingHandler());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(msg.toString());</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">                                    ByteBuf buffer1 = Unpooled.buffer();</span><br><span class="line"></span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;auth&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$9&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;mjy600811&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    ctx.writeAndFlush(buffer);</span><br><span class="line"></span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;$8&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    buffer1.writeBytes(<span class="string">&quot;zhangsan&quot;</span>.getBytes());</span><br><span class="line">                                    buffer1.writeBytes(LINE);</span><br><span class="line">                                    ctx.writeAndFlush(buffer1);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;116.62.122.89&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>http协议</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 添加http协议编码器和解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line"></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    System.out.println(msg.uri());</span><br><span class="line"></span><br><span class="line">                                    DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line">                                    response.content().writeBytes(<span class="string">&quot;&lt;h1&gt;hello,world&lt;h1/&gt;&quot;</span>.getBytes());</span><br><span class="line">                                    ctx.writeAndFlush(response);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>自定义协议要素</strong></p><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，登录、注册、单聊、群聊…跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><p>代码：</p><p>Message.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sequenceId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestMessage=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LoginRequestResponse=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Class&lt;?&gt; getMessageClass();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSequenceId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sequenceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSequenceId</span><span class="params">(<span class="keyword">int</span> sequenceId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sequenceId = sequenceId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageType</span><span class="params">(<span class="keyword">int</span> messageType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageType = messageType;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LoginRequestMessage.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginRequestMessage</span><span class="params">(String username, String password, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginRequestMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LoginRequestMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getMessageClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNickname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNickname</span><span class="params">(String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageCodec.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 写入4个字节魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 一个字节的版本</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个字节的序列化方式 0 jdk 1 json</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 1字节的指定类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 4个字节请求序列</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 对齐填充，为了让字节数为2的整数倍</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取内容的字节数组</span></span><br><span class="line">        ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="keyword">int</span> length=bytes.length;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        out.writeInt(length);</span><br><span class="line"></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 魔数</span></span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="comment">// 版本</span></span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="comment">// sequenceType</span></span><br><span class="line">        <span class="keyword">byte</span> sequenceType = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// messageType</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sequenceId</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充</span></span><br><span class="line">        in.readByte();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内容长度</span></span><br><span class="line">        <span class="keyword">int</span> len = in.readInt();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(bytes,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream bis=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        Message msg = (Message)ois.readObject();</span><br><span class="line"></span><br><span class="line">        out.add(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMessageCodec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EmbeddedChannel embeddedChannel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">                <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG),</span><br><span class="line"><span class="comment">//                new LengthFieldBasedFrameDecoder(1024,12,4,0,0),</span></span><br><span class="line">                <span class="keyword">new</span> MessageCodec()</span><br><span class="line">        );</span><br><span class="line">        LoginRequestMessage loginRequestMessage = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;12345&quot;</span>, <span class="string">&quot;法外狂徒&quot;</span>);</span><br><span class="line"></span><br><span class="line">        embeddedChannel.writeOutbound(loginRequestMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试解码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ByteBuf buffer = Unpooled.buffer();</span><br><span class="line">            <span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>,loginRequestMessage,buffer);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 还需要考虑粘包问题</span></span><br><span class="line">            ByteBuf s1 = buffer.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">            ByteBuf s2 = buffer.slice(<span class="number">100</span>, buffer.readableBytes() - <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在读取完内容之后，会执行release方法，释放内存，但因为slice方式是零拷贝，所以s1和s2使用的是同一块内存</span></span><br><span class="line">            <span class="comment">// 执行release会将所有内存释放，继续writeInbound(s2)会报错</span></span><br><span class="line">            <span class="comment">// 需要执行s1.retain()阻止release方法清除内存</span></span><br><span class="line">            s1.retain();</span><br><span class="line">            embeddedChannel.writeInbound(s1);</span><br><span class="line">            embeddedChannel.writeInbound(s2);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        embeddedChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Netty核心源码"><a href="#Netty核心源码" class="headerlink" title="Netty核心源码"></a>Netty核心源码</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Invalid bound statement (not found): com.project.seckill.mapper.UserMapper.getById</title>
      <link href="/2021/10/08/Invalid-bound-statement-not-found-com-project-seckill-mapper-UserMapper-getById/"/>
      <url>/2021/10/08/Invalid-bound-statement-not-found-com-project-seckill-mapper-UserMapper-getById/</url>
      
        <content type="html"><![CDATA[<p>在整合SpringBoot和Mybatis时，报错</p><p><strong>Invalid bound statement (not found):<br>  com.project.seckill.mapper.UserMapper.getById</strong></p><p>解决方法：</p><p>首先：</p><ul><li>仔细检查xxxMapper与xxxMapper.xml的内容，看是否未对应正确</li><li>查看xxxMapper.xml的namespace是否写错</li><li>查看xxxMapper.xml的返回结果是否映射正确</li></ul><p>若上述都没有问题，其次</p><ul><li><p>查看配置文件中的路径是否配置正确</p><img src="/2021/10/08/Invalid-bound-statement-not-found-com-project-seckill-mapper-UserMapper-getById/image-20211008230149945.png" class title="image-20211008230149945"></li><li><p>查看是否添加了@MapperScan(basePackages=”xxx”)</p><img src="/2021/10/08/Invalid-bound-statement-not-found-com-project-seckill-mapper-UserMapper-getById/image-20211008230251617.png" class title="image-20211008230251617"></li></ul><p>若上述都没问题，那就还有一个可能</p><p>Maven默认只识别src-main-resources下的资源文件，如果在maven工程中资源文件放在src-main-java下，我们需让Maven知道。在pom.xml中添加如下配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf引入静态资源无效</title>
      <link href="/2021/10/06/thymeleaf%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/"/>
      <url>/2021/10/06/thymeleaf%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h4 id="SpringBoot整合thymeleaf引用静态资源无效的问题"><a href="#SpringBoot整合thymeleaf引用静态资源无效的问题" class="headerlink" title="SpringBoot整合thymeleaf引用静态资源无效的问题"></a>SpringBoot整合thymeleaf引用静态资源无效的问题</h4><p>首先需要保证引入了thymeleaf的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要在application.properties中配置静态资源的路径</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.resources.add-mappings</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.chain.cache</span>=<span class="string">true </span></span><br><span class="line"><span class="meta">spring.resources.chain.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.chain.html-application-cache</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.static-locations</span>=<span class="string">classpath:/static/,classpath:/templates/</span></span><br></pre></td></tr></table></figure><p>resources目录下文件</p><img src="/2021/10/06/thymeleaf%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/image-20211006171656939.png" class title="image-20211006171656939"><p>引入th标签</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">#引用资源</span><br><span class="line">th:src=&quot;@&#123;&#125;&quot;</span><br></pre></td></tr></table></figure><img src="/2021/10/06/thymeleaf%E5%BC%95%E5%85%A5%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/image-20211006171830500.png" class title="image-20211006171830500"><p>注意这里的css引用是<link>标签，且th:href</p><p>若按上面做了都没有效果，可以试着清除浏览器的缓存，有可能是因为缓存导致引用失败。（没有配置其它配置类的情况下，若配置了其它的配置类，则可能有其它原因）</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 常见错误 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMq学习</title>
      <link href="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h4><h5 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h5><p>MQ(Message queue)从字面意思上看，本质是一个队列，FIFO先进先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递信息。在互联网架构中，MQ是一种非常常见的上下游”逻辑解耦+物理解耦“的信息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p><h5 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h5><p><strong>流量削峰</strong></p><p>举个例子，如果订单系统最多一秒能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余。但在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928222518791.png" class title="image-20210928222518791"><p><strong>应用解耦</strong></p><p><strong>异步处理</strong></p><h4 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h4><p><strong>ActiveMQ</strong></p><p>优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据</p><p>缺点：</p><p>官方对ActiveMQ5.x维护越来越少，高吞吐量场景较少使用</p><p><strong>Kafka</strong></p><p>为大数据而生的中间件，以其百万级TPS的吞吐量迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着重要作用。</p><p>优点：性能卓越，单击写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性ms级可用性非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者通过Pull方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次。主要支持简单的MQ功能，在大数据领域的实时计算以及<strong>日志采集</strong>被大规模使用</p><p>缺点：kafka单机超过64个队列/分区，Load会发生明显的飙高现象，load越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机，就会产生消息乱序</p><p><strong>RocketMQ</strong></p><p>RocketMQ出自阿里巴巴的开源产品，用Java语言实现，在设计时参考了kafka，并作出自己的一些改进。被阿里巴巴广泛应用于订单，交易，充值，流计算，消息推送，日志流式处理，binlog分发等场景</p><p>优点：<strong>单机吞吐量十万级</strong>，可用性非常高，分布式架构，<strong>消息可以做到0丢失</strong>，MQ功能较为完善，还是分布式的，扩展性好，<strong>支持十亿级别的消息堆积</strong>，不会因为堆积导致性能下降。</p><p>缺点：支持的客户端语言不多</p><p><strong>RabbitMQ</strong></p><p>2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一</p><p>优点：由于erlang语言的高并发特性，性能较好；吞吐量到万级，MQ功能比较完备，健壮，稳定，易用，跨平台，支持多种语言。</p><p>缺点：上夜班需要收费，学习成本较高</p><h4 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928225754577.png" class title="image-20210928225754577"><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><h5 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h5><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928230259050.png" class title="image-20210928230259050"><p>生产者：产生数据发送消息的程序是生产者</p><p>交换机：交换机是RabbitMQ非常重要的一个部件，一方面它接收来自消费者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或是把消息丢弃，这个由交换机决定</p><p>队列：一种数据结构，本质上是一个大的消息缓冲区</p><p>消费者：消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上，同一个应用程序既可以是生产者又可以是消费者。</p><h5 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h5><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928231020720.png" class title="image-20210928231020720"><h5 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h5><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928231103142.png" class title="image-20210928231103142"><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210928231334921.png" class title="image-20210928231334921"><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>官网地址：<a href="https://www.rabbitmq.com/download.html">Downloading and Installing RabbitMQ — RabbitMQ</a></p><p>安装rabbitmq前需要erlang的环境，注意版本的对应关系</p><p>下载地址：<a href="https://github.com/rabbitmq/erlang-rpm/releases">Releases · rabbitmq/erlang-rpm · GitHub</a></p><p>rabbitmq的下载地址：</p><p><a href="https://packagecloud.io/rabbitmq/rabbitmq-server/packages/el/7/rabbitmq-server-3.8.9-1.el7.noarch.rpm">el/7/rabbitmq-server-3.8.9-1.el7.noarch.rpm - rabbitmq/rabbitmq-server · packagecloud</a></p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210929001223149.png" class title="image-20210929001223149"><p>将安装包上传到/opt/rabbitmq(这个目录可以自己定)</p><p>安装文件（分别按以下顺序安装）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm ivh erlang-23.3.4.7-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.9-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>常用命令（按照以下顺序执行）</p><p>添加开机启动RabbitMQ服务</p><p>chkconfig rabbitmq-server on</p><p>或</p><p>systemctl enable rabbitmq-server.service</p><p>启动服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server</span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line">systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210929002841238.png" class title="image-20210929002841238"><p>安装web管理插件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210929131928849.png" class title="image-20210929131928849"><p>用默认账号密码（guest）访问地址：<a href="http://ip:15672/">http://ip:15672</a></p><p>添加一个新的用户</p><p>创建账号</p><p>rabbitmqctl add_user admin 123</p><p>设置用户角色</p><p>rabbitmqctl set_user_tags admin administrator</p><p>设置用户权限</p><p>set_permissions [-p <vhostpath>] <user> <conf> <write>  <read></read></write></conf></user></vhostpath></p><p>rabbitmqctl set_permissions -p “/“ admin “.<em>“ “.</em>“ “.*”</p><p>用户admin具有/vhost1这个virtual host 中的所有资源的配置、写、读权限</p><p>查看当前的用户和角色</p><p>rabbitmqctl list_users</p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><h4 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h4><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--rabbitmq--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编写生产者代码："><a href="#编写生产者代码：" class="headerlink" title="编写生产者代码："></a>编写生产者代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个连接工厂</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工厂IP，连接rabbitmq的队列</span></span><br><span class="line">    factory.setHost(<span class="string">&quot;116.62.122.89&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置rabbitmq用户名</span></span><br><span class="line">    factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置密码</span></span><br><span class="line">    factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        Connection conn = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取信道</span></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//queue：队列名称、durable：是否持久化一个队列、exclusive：是否是一个独占队列、autoDelete是否自动删除</span></span><br><span class="line">        <span class="comment">//arguments:其它阐述</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发消息</span></span><br><span class="line">        String message=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;发送完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-09-29 23:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        factory.setHost(<span class="string">&quot;116.62.122.89&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = factory.newConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消息成功消费时的回调</span></span><br><span class="line">            DeliverCallback deliverCallback=(tag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消费者取消消费时的回调</span></span><br><span class="line">            CancelCallback cancelCallback=consumerTag -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,deliverCallback,cancelCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h3><h4 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210929234251862.png" class title="image-20210929234251862"><p>抽取工具类</p><p>RabbitMqUtil.Java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConnectionFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_HOST=<span class="string">&quot;116.62.122.89&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_NAME=<span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(SERVER_HOST);</span><br><span class="line">        factory.setUsername(USER_NAME);</span><br><span class="line">        factory.setPassword(PASSWORD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取信道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = factory.newConnection();</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭资源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSource</span><span class="params">(Connection conn,Channel channel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(channel!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Connection conn=<span class="keyword">null</span>;</span><br><span class="line">    Channel channel=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    conn= RabbitMqUtil.getConnection();</span><br><span class="line">    <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel=conn.createChannel();</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="comment">// 阻塞等待键盘的输入</span></span><br><span class="line">            <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">                String message=scan.next();</span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">            RabbitMqUtil.closeSource(conn,channel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><p>注意：不能关闭信道和连接，否则程序不能阻塞消费消息，会直接结束</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Worker implements Runnable &#123;</span><br><span class="line">    // 队列名称</span><br><span class="line">    private static final String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 获取连接</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel=null;</span><br><span class="line"></span><br><span class="line">        if(conn!=null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 获取信道</span><br><span class="line">                channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                // 定义消费成功的回调</span><br><span class="line">                DeliverCallback deliverCallback = (consumerTag, message) -&gt; &#123;</span><br><span class="line">                    System.out.println(&quot;消息接收：&quot;+new String(message.getBody()));</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                // 定义消费终止的回调</span><br><span class="line">                CancelCallback cancelCallback = consumerTag -&gt; &#123;</span><br><span class="line">                    System.out.println(&quot;消费终止&quot;);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                channel.basicConsume(QUEUE_NAME,true,deliverCallback,cancelCallback);</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h4><p><strong>概念</strong></p><p>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了一部分突然它挂掉了，会发生什么情况。RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给消费者的消息。</p><p>为了保证消息在发送过程中不丢失，rabbitmq引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了</p><p><strong>自动应答</strong></p><p>消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性做权衡。因为如果消息在接收之前，消费者的连接或channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边传递了过多的消息，没有对消息的数量进行限制，使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，所以这种模式仅使用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。</p><p><strong>消息应答的方法</strong></p><p>Channel.backAsk(用于肯定确认)</p><p>使RabbitMQ知道该消息已经成功处理，可以将其丢弃了</p><p>Channel.basicNack(用于否定确认)</p><p>Channel.basicReject(用于否定确认)</p><p>与channel.basicNack相比少一个参数（批量处理）</p><p><strong>Multiple的解释</strong></p><p>手动应答的好处是可以批量应答并且减少网络拥堵</p><p><strong>消息自动重新入队</strong></p><p>如果消息由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致信息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将其重新排队。如果此时其它消费者可以处理，它将很快将其重新分发给另一个消费者。这样即使某个消费者偶尔失望，也可以确认消息不会丢失</p><p><strong>消息手动应答代码</strong></p><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME = <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Channel channel = conn.createChannel();</span><br><span class="line">                <span class="comment">// 声明一个队列</span></span><br><span class="line">                channel.queueDeclare(TASK_QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">                    String message = scan.next();</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者：&quot;</span> + message);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                scan.close();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><p>处理时间较长</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;work1处理消费消息时间较长....&quot;</span>);</span><br><span class="line">                DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费消息：&quot;</span>+<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者终止消费&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                channel.basicConsume(TASK_QUEUE_NAME,<span class="keyword">false</span>,deliverCallback,cancelCallback);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理时间较短</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TASK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;work2处理消费消息较短....&quot;</span>);</span><br><span class="line">                DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费消息：&quot;</span>+<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// deliveryTag：消息的标记</span></span><br><span class="line">                    <span class="comment">// multiple：是否批量应答；true:批量应答、false：不批量应答</span></span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者终止消费&quot;</span>);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                channel.basicConsume(TASK_QUEUE_NAME,<span class="keyword">false</span>,deliverCallback,cancelCallback);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210930122555684.png" class title="image-20210930122555684"><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210930122603727.png" class title="image-20210930122603727"><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210930122616828.png" class title="image-20210930122616828"><p>cc本应该交给work1处理，但因为work1中途挂掉了，消息自动重入队列，并交给work2处理</p><h4 id="RabbitMQ的持久化"><a href="#RabbitMQ的持久化" class="headerlink" title="RabbitMQ的持久化"></a>RabbitMQ的持久化</h4><p><strong>队列持久化</strong></p><p>要实现队列持久化，需要将queueDeclare的durable参数设为true,但若队列之前的参数为false则需要将原队列删除，然后再重新声明队列</p><p><strong>消息持久化</strong></p><p>要想让消息实现持久化需要修改消息生产者代码，添加属性MessageProperties.PERSISTENT_TEXT_PLAIN</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210930130722488.png" class title="image-20210930130722488"><p>将消息标记为持久化并不能完全保证不丢失信息。尽管它告诉RabbitMQ将信息保存到磁盘，但是这里仍然存在当消息刚准备存储在磁盘时候，但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强。</p><p><strong>不公平分发</strong></p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20210930131549826.png" class title="image-20210930131549826"><p>若需要进行不公平分发，需要在消费者端进行设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>预取值</strong></p><p>定义了消费者信道中的最大堆积数量，但依旧按轮询方式进行分发，若信道中已经堆积了预取值的数量，则不再向信道中加入信息。</p><h3 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h3><h4 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h4><p>注：需要使队列持久化和消息持久化</p><p>发布确认默认是没有开启的，如果要开启需要调方法confirmSelect，每当你要想使用发布确认，都需要在channel上调用该方法。</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211006100427734.png" class title="image-20211006100427734"><h4 id="单个发布确认"><a href="#单个发布确认" class="headerlink" title="单个发布确认"></a>单个发布确认</h4><p>这是一种简单的确认方式，是一种同步确认发布的方式，也就是发布一个消息后只有它被确认发布，后续的消息才能继续发布，waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。</p><p><strong>缺点：</strong>发布速度特别慢，因为若没有确认发布的消息就会阻塞所有后续消息的发布</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishSingle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;single_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 定义队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CONFIRM_COUNT; i++) &#123;</span><br><span class="line">            String text=i+<span class="string">&quot;_single&quot;</span>;</span><br><span class="line">            <span class="comment">// 设置生产者发送消息为持久化消息（要求保存到磁盘上），保存在内存中</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName , MessageProperties.PERSISTENT_TEXT_PLAIN, text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发布成功，耗时&quot;</span>+(end-start)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="批量发布确认"><a href="#批量发布确认" class="headerlink" title="批量发布确认"></a>批量发布确认</h4><p>与单个等待确认消息相比，先发布一批消息然后一起确认可以极大的提高吞吐量。</p><p><strong>缺点：</strong></p><p>当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息，这种方法仍然是同步的，也会阻塞消息的发布</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 批量发布确认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;batch_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 定义队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= CONFIRM_COUNT; i++) &#123;</span><br><span class="line">            String text = i + <span class="string">&quot;_single&quot;</span>;</span><br><span class="line">            <span class="comment">// 设置生产者发送消息为持久化消息（要求保存到磁盘上），保存在内存中</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            <span class="keyword">if</span> (i % batchSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag = channel.waitForConfirms();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发布成功，耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211006104902701.png" class title="image-20211006104902701"> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步确认</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line">            String queueName = <span class="string">&quot;async_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">            <span class="comment">// 定义队列</span></span><br><span class="line">            channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 开启发布确认</span></span><br><span class="line">            channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> batchSize = <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 准备消息的监听器，监听哪些消息成功了，哪些消息失败了</span></span><br><span class="line">            <span class="comment">// 消息确认成功 回调函数</span></span><br><span class="line">            ConfirmCallback ackCallback=(deliveryTag,multiple)-&gt;&#123;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 消息确认失败 回调函数</span></span><br><span class="line">            <span class="comment">// deliveryTag：消息的标识</span></span><br><span class="line">            <span class="comment">// multiple：是否为批量确认</span></span><br><span class="line">            ConfirmCallback nackCallback=(deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未确认的消息编号：&quot;</span>+deliveryTag);</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 异步监听</span></span><br><span class="line">            channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= CONFIRM_COUNT; i++) &#123;</span><br><span class="line">                String text = i + <span class="string">&quot;_async&quot;</span>;</span><br><span class="line">                <span class="comment">// 设置生产者发送消息为持久化消息（要求保存到磁盘上），保存在内存中</span></span><br><span class="line">                channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;消息发布成功，耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h4><p>最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用ConcurrentLinkedQueue这个队列在confirm callbacks与发布线程之间进行消息的传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步确认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">publishMessageAsync</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;async_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">// 定义队列</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来记录发布的消息</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,Object&gt; confirms=<span class="keyword">new</span> ConcurrentSkipListMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 准备消息的监听器，监听哪些消息成功了，哪些消息失败了</span></span><br><span class="line">        <span class="comment">// 消息确认成功 回调函数</span></span><br><span class="line">        ConfirmCallback ackCallback=(deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 删除已经确认的消息，剩下的就是未确认的消息</span></span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                <span class="comment">// 批量删除，headMap：方法用于返回此映射的键严格小于toKey的部分视图</span></span><br><span class="line">                ConcurrentNavigableMap&lt;Long, Object&gt; curMap = confirms.headMap(deliveryTag,<span class="keyword">true</span>);</span><br><span class="line">                curMap.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                confirms.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;发布成功：&quot;</span>+deliveryTag+<span class="string">&quot;条消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消息确认失败 回调函数</span></span><br><span class="line">        <span class="comment">// deliveryTag：消息的标识</span></span><br><span class="line">        <span class="comment">// multiple：是否为批量确认</span></span><br><span class="line">        ConfirmCallback nackCallback=(deliveryTag,multiple)-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认的消息编号：&quot;</span>+deliveryTag);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 异步监听</span></span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= CONFIRM_COUNT; i++) &#123;</span><br><span class="line">            String text = i + <span class="string">&quot;_async&quot;</span>;</span><br><span class="line">            <span class="comment">// 设置生产者发送消息为持久化消息（要求保存到磁盘上），保存在内存中</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, MessageProperties.PERSISTENT_TEXT_PLAIN, text.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录下所有要发送的消息，记录消息的总和</span></span><br><span class="line">            confirms.put(channel.getNextPublishSeqNo(),text);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消息发布成功，耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><h4 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h4><p>RabbitMQ消息传递模型的核心思想是：<strong>生产者生产的消息从不会直接发送到队列中</strong>。实际上通常生产者甚至都不知道这些消息传递到了哪些队列中</p><p>生产者只是将消息发送到交换机，交换机一方面接收来自生产者的消息，另一方面将他们推入队列中。交换机必须知道如何处理收到的消息，是应该放到特定队列还是说把他们放到许多队列中还是丢弃他们，这就由交换机的类型来决定。</p><p><strong>Exchanges的类型</strong></p><p>default：“”默认</p><p>direct：直接</p><p>topic：主题</p><p>headers：标题</p><p>fanout：扇出</p><h4 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h4><p>每当我们连接导Rabbit时，我们都需要一个全新的空列名，为此我们可以创建一个具有随即名称的队列，或者能让服务器为我们选择一个随机队列名称就好了。其次一旦我们断开了消费者的连接，队列将被自动删除</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211006122556352.png" class title="image-20211006122556352"><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211006123134920.png" class title="image-20211006123134920">binding其实是exchange和queue之间的桥梁，它告诉我们exchange和哪个队列进行了捆绑关系。<h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>Fanout这种类型非常简单，正如从名称中猜到的那样，它是将接受到的所有消息广播到<strong>它知道的所有队列中</strong>。系统中默认有些exchange类型。</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211006131437193.png" class title="image-20211006131437193"><p>实例：</p><p><strong>消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过交换机进行消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line">            FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;D:\\JavaLearn\\project\\rabbitmq\\rabbitmq-learn\\rabbitmq-demo\\src\\main\\java\\com\\mjy\\rabbitmq\\filesave\\receive_log.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 声明一个交换机</span></span><br><span class="line">                channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 声明一个临时队列</span></span><br><span class="line">                String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">                channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                DeliverCallback deliverCallback=(consumerTag, message)-&gt;&#123;</span><br><span class="line">                    fos.write(message.getBody());</span><br><span class="line">                    fos.flush();</span><br><span class="line">                &#125;;</span><br><span class="line">                channel.basicConsume(queueName,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 经过交换机进行消费</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明一个交换机</span></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明一个临时队列</span></span><br><span class="line">            String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定交换机与队列</span></span><br><span class="line">            channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;等待接收消息......&quot;</span>);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line">            channel.basicConsume(queueName,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>生产者：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发消息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME,<span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">                String message=scan.next();</span><br><span class="line"></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;&quot;</span>,<span class="keyword">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p>根据routing Key的不同，将消息发送给不同的队列中</p><p>消费者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogDirect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;console&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;console&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;console&quot;</span>,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogDirect1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;disk&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            channel.queueBind(<span class="string">&quot;disk&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;disk&quot;</span>,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectLogs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">                String message=scan.next();</span><br><span class="line"></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;info&quot;</span>,<span class="keyword">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p><strong>Topic的要求</strong></p><p>发送到类型是topic交换机的消息的routing_key不能随便写，必须满足一定的要求，它必须是一个单词列表，以点分隔开。这些单词可以是任意单词，比如说：”stock.usd.nyse“，”nyse.vmw“这个单词列表最多不能超过255个字节</p><p>在这个规则列表中，其中有两个替换符是大家需要注意的</p><p>*可以替代一个单词</p><p>#可以替代零个或多个单词</p><p>当一个队列绑定键是#，那么这个队列将接收所有数据，就有点像fanout了，如果队列绑定键当中没有#和*,那么该队列绑定类型就是direct</p><p><strong>实例：</strong></p><p>消费者：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReceiveLogsTopic &#123;</span><br><span class="line">    private static final String EXCHANGE_NAME=&quot;topic_logs&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(&quot;Q1&quot;,false,false,false,null);</span><br><span class="line"></span><br><span class="line">            channel.queueBind(&quot;Q1&quot;,EXCHANGE_NAME,&quot;*.orange.*&quot;);</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag, message)-&gt;&#123;</span><br><span class="line">                System.out.println(&quot;接收到的消息：&quot;+new String(message.getBody(),&quot;UTF-8&quot;));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(&quot;Q1&quot;,true,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveLogsTopic1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;Q2&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            channel.queueBind(<span class="string">&quot;Q2&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;Q2&quot;</span>,EXCHANGE_NAME,<span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag, message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(<span class="string">&quot;Q2&quot;</span>,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicEmitLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_NAME=<span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line"></span><br><span class="line">            Scanner scan=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">                String message=scan.next();</span><br><span class="line"></span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME,<span class="string">&quot;province.orange.rabbit&quot;</span>,<span class="keyword">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;生产者发送消息：&quot;</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><h4 id="死信队列的概念"><a href="#死信队列的概念" class="headerlink" title="死信队列的概念"></a>死信队列的概念</h4><p>死信就是指无法消费的消息，字面意思可以这样理解，一般来说，producer将消息传递到broker或者直接到queue里，consumer从queue取出消息进行消费，但某些时候由于<strong>特定的原因导致queue中的某些信息无法被消费</strong>，这样的消息如果没有后续处理就变成了死信，有死信自然就有死信队列</p><p><strong>应用场景：</strong></p><p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中，或者用户在商城下单成功并点击去支付后在指定时间未支付自动失效</p><h4 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h4><p>消息TTL过期</p><p>队列达到最大长度（队列满了，无法再添加数据到mq中）</p><p>消息被拒绝（basic.reject或basic.nack）并且requeue=false</p><h4 id="消息TTL过期实例"><a href="#消息TTL过期实例" class="headerlink" title="消息TTL过期实例"></a>消息TTL过期实例</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Channel channel = conn.createChannel();</span><br><span class="line">        <span class="comment">// 声明交换机</span></span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明两个队列</span></span><br><span class="line">        <span class="comment">// 普通队列</span></span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; arguments=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 可以设置过期时间（但不灵活，推荐发消息时指定过期时间）单位为ms</span></span><br><span class="line">        <span class="comment">// arguments.put(&quot;x-message-ttl&quot;,10000);</span></span><br><span class="line">        <span class="comment">// 正常队列设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">        <span class="comment">// 设置死信队列routingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;normal_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死信队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;dead_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定交换机</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;normal_queue&quot;</span>,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;dead_queue&quot;</span>,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 死信消息 设置TTL时间 单位是ms</span></span><br><span class="line">        AMQP.BasicProperties props=<span class="keyword">new</span> AMQP.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,props,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列达到最大长度"><a href="#队列达到最大长度" class="headerlink" title="队列达到最大长度"></a>队列达到最大长度</h4><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_EXCHANGE=<span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_EXCHANGE=<span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line">            <span class="comment">// 声明交换机</span></span><br><span class="line">            channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">            channel.exchangeDeclare(DEAD_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 声明两个队列</span></span><br><span class="line">            <span class="comment">// 普通队列</span></span><br><span class="line"></span><br><span class="line">            Map&lt;String, Object&gt; arguments=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 可以设置过期时间（但不灵活，推荐发消息时指定过期时间）单位为ms</span></span><br><span class="line">            <span class="comment">// arguments.put(&quot;x-message-ttl&quot;,10000);</span></span><br><span class="line">            <span class="comment">// 正常队列设置死信交换机</span></span><br><span class="line">            arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,DEAD_EXCHANGE);</span><br><span class="line">            <span class="comment">// 设置死信队列routingKey</span></span><br><span class="line">            arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置队列长度的限制</span></span><br><span class="line">            arguments.put(<span class="string">&quot;x-max-length&quot;</span>,<span class="number">6</span>);</span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;normal_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 死信队列</span></span><br><span class="line">            channel.queueDeclare(<span class="string">&quot;dead_queue&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定交换机</span></span><br><span class="line">            channel.queueBind(<span class="string">&quot;normal_queue&quot;</span>,NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">            channel.queueBind(<span class="string">&quot;dead_queue&quot;</span>,DEAD_EXCHANGE,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 死信消息 设置TTL时间 单位是ms</span></span><br><span class="line">            <span class="comment">// AMQP.BasicProperties props=new AMQP.BasicProperties().builder().expiration(&quot;10000&quot;).build();</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">                channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;info5&quot;</span>.equals(str))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;consumer接受的信息是&quot;</span>+message+<span class="string">&quot;:此消息被拒绝&quot;</span>);</span><br><span class="line">                    channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;接收到的消息：&quot;</span>+str);</span><br><span class="line">                    channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME,<span class="keyword">false</span>,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延时队列，队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列</p><h4 id="延迟队列的应用场景"><a href="#延迟队列的应用场景" class="headerlink" title="延迟队列的应用场景"></a>延迟队列的应用场景</h4><p>订单在十分钟之内未支付则自动取消</p><p>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒</p><p>用户注册成功后，如果三天内没有登录则进行短信提醒</p><p>用户发起退款，如果三天内没有得到处理则通知相关运营人员</p><p>预定会议后，需要在预定的时间点前十分钟通知各个参会人员参加会议</p><h3 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h3><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--RabbitMQ测试依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Rabbitmq</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">116.62.122.89</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br></pre></td></tr></table></figure><h4 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211007152625669.png" class title="image-20211007152625669"><p>声明交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TTLQueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_EXCHANGE = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信交换机名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="comment">// 普通队列名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_A = <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NORMAL_QUEUE_B = <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="comment">// 死信队列的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_QUEUE_NAME = <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通交换机，起别名xExchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">xExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(X_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">yExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 设置routingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(NORMAL_QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// 设置routingKey</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(NORMAL_QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死信队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queueD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(DEAD_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ttl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMsgController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log=LoggerFactory.getLogger(SendMsgController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条消息给两个TTL队列:&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XA&quot;</span>,<span class="string">&quot;消息来自ttl10s的队列：&quot;</span>+message);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XB&quot;</span>,<span class="string">&quot;消息来自ttl40s的队列：&quot;</span>+message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(SendMsgController.class);</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues=&quot;QD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String msg=<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,接收到死信队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h4><p>再声明一个普通队列不设置过期时间，在发送消息的时候设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queueC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置死信交换机</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    <span class="comment">// 设置routingKey</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(NORMAL_QUEUE_C).withArguments(arguments).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者发送消息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String delayTime)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条时延为&#123;&#125;ms的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),delayTime,message);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertSendAndReceive(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;XC&quot;</span>,message, msg-&gt;&#123;</span><br><span class="line">        msg.getMessageProperties().setExpiration(delayTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题：在消息属性上设置TTL的方式，消息可能并不会按时“死亡”，因为RabbitMQ只会检查第一个消息是否过期，如果过期则放到死信队列中，若第一个消息的延时时长很长，而第二条消息的延时时长很短，第二个消息并不会优先得到执行。</p><h4 id="RabbitMQ插件实现延时队列"><a href="#RabbitMQ插件实现延时队列" class="headerlink" title="RabbitMQ插件实现延时队列"></a>RabbitMQ插件实现延时队列</h4><p>安装插件</p><p>在<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases">Releases · rabbitmq/rabbitmq-delayed-message-exchange · GitHub</a>上下载</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211008145102905.png" class title="image-20211008145102905"><p>并将它拷贝到/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.9/plugins/目录下</p><p>安装</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>安装成功：</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211008145421500.png" class title="image-20211008145421500"><p>安装后，需要重新启动rabbitmq服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><p>安装成功后，客户端会出现一个新的类型的交换机</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211008145851281.png" class title="image-20211008145851281"><p>基于插件的延迟队列</p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211008150037546.png" class title="image-20211008150037546"><p><strong>代码实现：</strong></p><p>编写配置类，声明交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedQueueConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME=<span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME=<span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY=<span class="string">&quot;delayed.routingKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;delayExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayedExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; arguments=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME,<span class="string">&quot;x-delayed-message&quot;</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;delayedQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayedQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(DELAYED_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">queueBindExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,<span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> CustomExchange delayExchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayExchange).with(ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;，发送一条时延为&#123;&#125;ms的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),delayTime,message);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertSendAndReceive(DelayedQueueConfig.DELAYED_EXCHANGE_NAME,DelayedQueueConfig.ROUTING_KEY,message, msg-&gt;&#123;</span><br><span class="line">            msg.getMessageProperties().setDelay(delayTime);</span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编写消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(DelayQueueConsumer.class);</span><br><span class="line">    <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues=DelayedQueueConfig.DELAYED_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        String msg=<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,接受到延迟队列的消息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),msg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h3><p>解决生产者在发送消息的过程中，由于交换机或队列挂了导致消息丢失的问题</p><p>实例：</p><p>编写配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE=<span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE=<span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY=<span class="string">&quot;confirmKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(CONFIRM_EXCHANGE,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.nonDurable(CONFIRM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding  <span class="title">confirmQueueBindConfirmExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ProducerController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容为：&#123;&#125;&quot;</span>,message);</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(ConfirmConfig.CONFIRM_EXCHANGE,ConfirmConfig.ROUTING_KEY,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(Consumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues=ConfirmConfig.CONFIRM_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessage</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String msg=<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;当前时间为：&#123;&#125;，接收到来自交换机的信息：&#123;&#125;&quot;</span>,<span class="keyword">new</span> Date(),msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log= LoggerFactory.getLogger(MyCallBack.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的这个实现类，并未在RabbitTemplate中，RabbitTemplate无法调用，需要进行注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 保存回调信息的ID及内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机成功接受到消息&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未接收到消息，原因是：&#123;&#125;&quot;</span>,cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>开启发布确认：</strong></p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211008165944513.png" class title="image-20211008165944513"><h4 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h4><p><strong>Mandatory参数</strong></p><p>在仅开启了生产者确认机制的情况下，交换机接受到消息后，会直接给消息生产者发送确认信息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。通过设置Mandatory参数可以在当消息传递过程中不可达目的地时将消息返回给生产者</p><p>在application.properties设置发布退回</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>回调实现ReturnCallBack接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallBack</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger log= LoggerFactory.getLogger(MyCallBack.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在的这个实现类，并未在RabbitTemplate中，RabbitTemplate无法调用，需要进行注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 保存回调信息的ID及内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 失败的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机成功接受到消息&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机未接收到消息，原因是：&#123;&#125;&quot;</span>,cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有不可到达目的地时才进行回退</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息：&#123;&#125;,被交换机&#123;&#125;回退了，回退原因：&#123;&#125;,routingKey：&#123;&#125;&quot;</span>,<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>),exchange,replyText,routingKey);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h4><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211009111354020.png" class title="image-20211009111354020"><p>实例代码</p><p>声明交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_EXCHANGE=<span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONFIRM_QUEUE=<span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTING_KEY=<span class="string">&quot;confirmKey&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACK_UP_EXCHANGE=<span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">// 备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BACK_UP_QUEUE=<span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 警告队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WARNING_QUEUE=<span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">confirmExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE).durable(<span class="keyword">true</span>).withArgument(<span class="string">&quot;alternate-exchange&quot;</span>,BACK_UP_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">confirmQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BACK_UP_EXCHANGE,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backupQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACK_UP_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding  <span class="title">confirmQueueBindConfirmExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(ROUTING_KEY);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupQueueBindExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">warningQueueBindExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarningConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(WarningConsumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues=ConfirmConfig.WARNING_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMessageWarn</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String str=<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;接收到不可路由的一条消息：&#123;&#125;&quot;</span>,str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log= LoggerFactory.getLogger(ProducerController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;发送消息内容为：&#123;&#125;&quot;</span>,message);</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(ConfirmConfig.CONFIRM_EXCHANGE,ConfirmConfig.ROUTING_KEY,message);</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(ConfirmConfig.CONFIRM_EXCHANGE,ConfirmConfig.ROUTING_KEY+<span class="string">&quot;12&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mandatory参数与备份交换机可以一起使用时，若两者同时开启，<strong>备份交换机的优先级高</strong></p><h3 id="RabbitMQ的其它知识点"><a href="#RabbitMQ的其它知识点" class="headerlink" title="RabbitMQ的其它知识点"></a>RabbitMQ的其它知识点</h3><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p><strong>概念：</strong></p><p>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。</p><p><strong>消息重复消费</strong></p><p>消费者在消费MQ中的消息时，MQ已把消息发给消费者，消费者在给MQ返回ack时网络中断，导致MQ未收到消息确认，该消息会重新发给其它的消费者，或者在网络重连后再次将消息发给消费者，而该消费者之前已经消费过该消息了，导致消息重复消费。</p><p>解决方案：</p><p><strong>唯一ID+指纹码机制</strong></p><p>指纹码：我们的一些规则或者时间戳加别的服务得到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性，然后就利用查询语句进行判断这个id是否存在在数据库中，优势就是实现简单就一个拼接，然后查询判断是否重复；劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能。</p><p><strong>Redis原子性</strong></p><p>利用redis执行setnx命令，天然具有幂等性。从而实现不重复消费。</p><h4 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h4><p>实现实例</p><p>生产者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;priority.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            Map&lt;String,Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            arguments.put(<span class="string">&quot;x-max-priority&quot;</span>,<span class="number">10</span>);</span><br><span class="line">            channel.queueDeclare(QUEUE_NAME,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,arguments);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                    AMQP.BasicProperties props=<span class="keyword">new</span> AMQP.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,props,message.getBytes());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="keyword">null</span>,message.getBytes());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送完毕！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;priority.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection conn = RabbitMqUtil.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Channel channel = conn.createChannel();</span><br><span class="line"></span><br><span class="line">            DeliverCallback deliverCallback=(consumerTag,message)-&gt;&#123;</span><br><span class="line">                String msg=<span class="keyword">new</span> String(message.getBody(),<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(QUEUE_NAME,<span class="keyword">true</span>,deliverCallback,consumerTag-&gt;&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211009121919944.png" class title="image-20211009121919944"><h4 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h4><p><strong>使用场景</strong></p><p>RabbitMQ从3.6.0版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因（比如消费者下线、宕机亦或是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。</p><p>默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ需要释放内存时，会将内存中的信息换页至磁盘中，这个操作会耗费较长时间，也会阻塞队列的操作，进而无法接收新的消息。</p><p><strong>两种模式</strong></p><img src="/2021/09/28/RabbitMq%E5%AD%A6%E4%B9%A0/image-20211009133542836.png" class title="image-20211009133542836"><h3 id="RabbitMQ集群搭建"><a href="#RabbitMQ集群搭建" class="headerlink" title="RabbitMQ集群搭建"></a>RabbitMQ集群搭建</h3><p>准备三台机器</p><p>修改3台机器的主机名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/hostname</span><br></pre></td></tr></table></figure><p>配置各个节点的hosts文件，让各个节点能够互相识别对方</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/hosts</span><br></pre></td></tr></table></figure><p>确保各个节点的cookie文件使用的是同一个值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/.erlang.cookie</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node1:/var/lib/rabbitmq/.erlang.cookie</span><br></pre></td></tr></table></figure><p>启动RabbitMQ服务顺带启动Erlang虚拟机和RabbitMQ应用服务（在三台节点上分别执行以下命令）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure><p>在节点2执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rabbitmqctl stop 会将erlang虚拟机关闭，rabbitmqctl stop_app只关闭RabbitMQ服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line">rabbitmqctl join_cluster rabbit@node1</span><br><span class="line"><span class="comment">#只启动应用服务</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>在节点3执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rabbitmqctl stop 会将erlang虚拟机关闭，rabbitmqctl stop_app只关闭RabbitMQ服务</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"></span><br><span class="line">rabbitmqctl join_cluster rabbit@node2</span><br><span class="line"><span class="comment">#只启动应用服务</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure><p>查看集群状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure><p>需要重新设置用户</p><p>创建账户</p><p>rabbitmqctl add_user admin 1234</p><p>设置用户角色：</p><p>rabbitmqctl set_user_tags admin administrator</p><p>设置用户权限</p><p>rabbitmqctl set_permissions -p “/“ admin “.<em>“ “.</em>“ “.*”</p><p>解除集群节点(node2和node3分别执行)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop_app</span><br><span class="line">rabbitmqctl reset</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line">rabbitmqctl cluster_status</span><br><span class="line">rabbitmqctl forget_cluster_node rabbit@node2(node1机器执行)</span><br></pre></td></tr></table></figure><h4 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h4><p>如果RabbitMQ集群中只有一个Broker节点，那么该节点的失效将导致整体服务的临时不可用，并且也可能会导致消息的丢失。可以将消息设置为持久化，并且对应的队列也进行持久化，但是这样仍然无法避免由于缓存导致的问题：因为消息在发送之后和被写入磁盘并执行刷盘动作之间存在一个短暂却会产生问题的时间窗。引入镜像队列的机制，可以将队列镜像到集群中的其它Broker节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像的另一个节点上，保证服务的可用性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>秒杀项目（一）：准备</title>
      <link href="/2021/09/28/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/"/>
      <url>/2021/09/28/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><h4 id="在数据库中新创建一个数据库"><a href="#在数据库中新创建一个数据库" class="headerlink" title="在数据库中新创建一个数据库"></a><strong>在数据库中新创建一个数据库</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database seckill</span><br></pre></td></tr></table></figure><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>商品详情表：<code>sk_goods</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sk_goods` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;商品ID&#x27;</span>,</span><br><span class="line">  `goods_name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">  `goods_title` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品标题&#x27;</span>,</span><br><span class="line">  `goods_img` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品图片&#x27;</span>,</span><br><span class="line">  `goods_detail` longtext COMMENT <span class="string">&#x27;商品详情&#x27;</span>,</span><br><span class="line">  `goods_price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_stock` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;商品库存，-1表示没有限制&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>商品秒杀详情：<code>sk_goods_seckill</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sk_goods_seckill` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;秒杀商品id&#x27;</span>,</span><br><span class="line">  `goods_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品id&#x27;</span>,</span><br><span class="line">  `seckill_price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0.00&#x27;</span> COMMENT <span class="string">&#x27;秒杀价&#x27;</span>,</span><br><span class="line">  `stock_count` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;库存数量&#x27;</span>,</span><br><span class="line">  `start_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秒杀开始时间&#x27;</span>,</span><br><span class="line">  `end_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秒杀结束时间&#x27;</span>,</span><br><span class="line">  `version` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;并发版本控制&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>订单表：<code>sk_order</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sk_order` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `u_uid_gid` (`user_id`,`goods_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">11</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>订单详情：<code>sk_order_info</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sk_order_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `user_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `delivery_addr_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_count` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `goods_price` <span class="type">decimal</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `order_channel` tinyint <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单渠道，1在线，2android，3ios&#x27;</span>,</span><br><span class="line">  `status` tinyint <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态，0新建未支付，1已支付，2已发货，3已收货，4已退款，5已完成&#x27;</span>,</span><br><span class="line">  `create_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pay_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">11</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>用户表：<code>sk_user</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sk_user` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `nickname` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;MD5(MD5(pass明文+固定salt)+salt&#x27;</span>,</span><br><span class="line">  `salt` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;混淆盐&#x27;</span>,</span><br><span class="line">  `head` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像，云存储的ID&#x27;</span>,</span><br><span class="line">  `register_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span>,</span><br><span class="line">  `last_login_date` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;上次登录时间&#x27;</span>,</span><br><span class="line">  `login_count` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;登录次数&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><img src="/2021/09/28/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/image-20210928192032332.png" class title="image-20210928192032332"><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><p><strong>技术栈</strong>：</p><p>SpringBoot、Redis、Mybatis、RabbitMQ、thymeleaf</p><h5 id="新建一个SpringBoot项目"><a href="#新建一个SpringBoot项目" class="headerlink" title="新建一个SpringBoot项目"></a>新建一个SpringBoot项目</h5><p>这里使用了aliyun作为源</p><img src="/2021/09/28/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87/image-20210928192329898.png" class title="image-20210928192329898"><h5 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.project<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seckill<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>seckill<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--SpringBoot--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--加密--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--验证JavaBean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--RabbitMq--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>19.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.project.seckill.SeckillApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发，秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习</title>
      <link href="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h3><h4 id="1-1-NoSQL数据库概述"><a href="#1-1-NoSQL数据库概述" class="headerlink" title="1.1 NoSQL数据库概述"></a>1.1 NoSQL数据库概述</h4><p>NoSQL(Not Only SQL)，泛指<strong>非关系型数据库</strong>，NoSQL不依赖业务逻辑方式存储，而以简单的<strong>key-value</strong>模式存储。因此大大的增加了数据库的扩展能力。</p><p><strong>特点：</strong></p><ul><li>不遵循SQL标准</li><li>不支持ACID</li><li>远超SQL的性能</li></ul><h4 id="1-2-NoSQL的适用场景"><a href="#1-2-NoSQL的适用场景" class="headerlink" title="1.2 NoSQL的适用场景"></a>1.2 NoSQL的适用场景</h4><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据搞扩展性的</li></ul><h4 id="1-3-NoSQL不适用-的场景"><a href="#1-3-NoSQL不适用-的场景" class="headerlink" title="1.3 NoSQL不适用 的场景"></a>1.3 NoSQL不适用 的场景</h4><ul><li>需要事务支持</li><li>基于sql的结构化查询，处理复杂的关系，需要即席查询</li></ul><h4 id="1-4-NoSQL数据库"><a href="#1-4-NoSQL数据库" class="headerlink" title="1.4 NoSQL数据库"></a>1.4 NoSQL数据库</h4><p><strong>Memcache</strong></p><p><strong>特点：</strong></p><ul><li>数据都在内存中，一般不持久化</li><li>支持简单的key-value模式，<strong>支持类型单一</strong></li><li>一般作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><p><strong>Redis</strong></p><p><strong>特点：</strong></p><ul><li>几乎覆盖了Memcache的绝大部分功能</li><li>数据都在内存中，<strong>支持持久化</strong>，主要用作数据备份恢复</li><li>除了支持简单的<strong>key-value</strong>模式，还支持多种数据结构的存储，如 <strong>list、set、hash、zset</strong>等</li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><p><strong>MongoDB</strong></p><p><strong>特点：</strong></p><ul><li>高性能、开源、模式自由的文档型数据库</li><li>数据都在内存中，如果内存不足，把不常用的数据保存到硬盘上</li><li>虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能。</li><li>支持二进制数据及大型对象</li><li>可以根据数据的特点替代RDBMS，成为独立的数据库。或者配合RDBMS，存储特定的数据</li></ul><h3 id="Redis概述安装"><a href="#Redis概述安装" class="headerlink" title="Redis概述安装"></a>Redis概述安装</h3><h4 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h4><ul><li>Redis是一个开源的key-value存储系统</li><li>和Memcached类似，它支持存储的value类型相对更多，包括String、list、set、zset(有序集合)、hash</li><li>这些数据操作都支持push/pop、add/remove及取交集并集和差集及更丰富的的操作，而且这些操作都是原子性的</li><li>在此基础上，Redis支持各种不同方式的排序</li><li>数据缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件 </li><li>实现了主从同步</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>配合关系型数据库做高速缓存</p><ul><li>高频次，热门访问的数据，减少数据库I/O</li><li>分布式架构，做session共享</li></ul><p>多样数据结构存储持久化数据：</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210920132655339.png" class title="image-20210920132655339"><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><p>具体安装步骤略</p><p><strong>默认安装目录：</strong></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure><p>查看默认安装目录：</p><p>redis-benchmark：性能检测工具，可以在 自己本机运行，看看自己本机性能如何</p><p>redis-check-aof：修复有问题的AOF文件</p><p>redis-check-dump：修复有问题的dump.rdb文件</p><p>redis-sentinel：Redis集群使用</p><p><strong>redis-server</strong>：Redis服务器启动命令</p><p><strong>redis-cli</strong>：客户端，操作入口</p><p><strong>启动方式：</strong></p><p>前台启动（不推荐）：不能关闭启动界面</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>后台启动（推荐）：</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210920144819288.png" class title="image-20210920144819288"><p>将redis.conf文件复制一份到/etc/redis.conf</p><p>将/etc目录下的redis.conf文件中的 <code>daemonize</code>  改成yes</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210920145549953.png" class title="image-20210920145549953"><h4 id="Redis相关知识介绍"><a href="#Redis相关知识介绍" class="headerlink" title="Redis相关知识介绍"></a>Redis相关知识介绍</h4><p>Redis的默认端口号为：6379</p><p>默认16个数据库，类似数组下标从0开始，初始默认使用<strong>0号库</strong></p><p>使用select dbid来切换数据库，例如：select 8</p><p>同一密码管理，所有库同样的密码</p><p><strong>dbsize</strong>：查看当前数据库的key的数量</p><p><strong>flushdb 清空当前库</strong></p><p><strong>flushall  清空所有库</strong></p><p>Redis是单线程+多路IO复用技术</p><p>多路复用是指使用一个线程来检查多个文件描述符(Socket)的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p>Memcached：多线程+锁</p><p>Redis：单线程+多路IO复用技术</p><h3 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h3><p>获得redis常见数据类型操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h4 id="Redis键-key"><a href="#Redis键-key" class="headerlink" title="Redis键(key)"></a>Redis键(key)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前库所有key</span></span><br><span class="line">keys *</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断key是否存在</span></span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看你的key是什么类型的</span></span><br><span class="line"><span class="built_in">type</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除指定的key数据</span></span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"><span class="comment">#根据value选择非阻塞删除:仅将keys从keyspace元数据中删除，真#正的删除会在后续异步操作</span></span><br><span class="line">unlink key</span><br><span class="line"></span><br><span class="line"><span class="comment">#为给定的key设置过期时间</span></span><br><span class="line">expire key 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看还有多少秒过期，-1表示永不过期，-2表示已过期</span></span><br><span class="line">ttl key</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置key-value</span></span><br><span class="line"><span class="built_in">set</span> key value</span><br></pre></td></tr></table></figure><h4 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h4><p>String是Redis最基本的类型，一个key对应一个value</p><p>String类型<strong>是二进制安全的</strong>。意味着Redis的string可以包含任何数据。比如jpg图片或序列化的对象</p><p>一个Redis中字符串value最多可以是<strong>512M</strong></p><p><strong>常用命令：</strong></p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#添加键值对</span><br><span class="line">#NX：当数据库中key不存在时，可以将key-value添加到数据库</span><br><span class="line">#XX：当数据库中key存在时，可以将key-value添加到数据库，与NX参数互斥</span><br><span class="line">#EX：key的超时秒数</span><br><span class="line">#PX：key的超时毫秒数，与EX互斥</span><br><span class="line"><span class="built_in">set</span> key value 参数</span><br><span class="line"></span><br><span class="line">#查询对应键值</span><br><span class="line">get key</span><br><span class="line"></span><br><span class="line">#将给定的value追加到原值的末尾</span><br><span class="line"><span class="built_in">append</span> key value</span><br><span class="line"></span><br><span class="line">#获得值的长度</span><br><span class="line">strlen key</span><br><span class="line"></span><br><span class="line">#只有在key不存在时，设置key的值</span><br><span class="line">setnx key value</span><br><span class="line"></span><br><span class="line">#将key中存储的数字值增<span class="number">1</span>，只能对数字进行操作，如果为空，新增值为<span class="number">1</span></span><br><span class="line">incr key</span><br><span class="line"></span><br><span class="line">#将key中存储的数字值减<span class="number">1</span>,只能对数字进行操作，如果为空，新增值为-<span class="number">1</span></span><br><span class="line">decr key</span><br><span class="line"></span><br><span class="line">#将key中存储的数字值增减。自定义步长</span><br><span class="line">incrby/decrby key 步长</span><br><span class="line"></span><br><span class="line">#同时设置一个或多个键值对</span><br><span class="line">mset key1 value1 key2 value2</span><br><span class="line"></span><br><span class="line">#同时获取一个或多个value</span><br><span class="line">mget key1 key2 key3</span><br><span class="line"></span><br><span class="line">#同时设置一个或多个key-value对，当且仅当所有给定key都不存在</span><br><span class="line">#原子性，有一个失败则都失败</span><br><span class="line">msetnx key1 value1 key2 value2</span><br><span class="line"></span><br><span class="line">#获取值的范围，类似于substring,前闭、后闭</span><br><span class="line">getrange key 起始位置 结束位置</span><br><span class="line"></span><br><span class="line">#用value覆写key所存储的字符串值，从起始位置开始（索引从<span class="number">0</span>开始）</span><br><span class="line">setrange key 起始位置 value</span><br><span class="line"></span><br><span class="line">#设置键值的同时，设置过期时间，单位秒</span><br><span class="line">setex key 过期时间 value</span><br><span class="line"></span><br><span class="line">#以新换旧，设置了心智同时获得旧值</span><br><span class="line">getset key value</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>incr是原子操作</p><p>原子操作：不会被线程调度机制打断的操作</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何context switch（切换到另一个线程）</p><ul><li>在单线程中，能够在单挑指令中完成的操作都可以被认为是“原子操作”，因为中断只能发生于指令之间</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</li></ul><p>Redis单命令的原子性主要得益于Redis的单线程</p><p>Redis String底层数据结构为简单动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p><h4 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis(List)"></a>Redis(List)</h4><p>单值多键，Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部或者尾部</p><p>它的底层实际是个<strong>双向链表</strong>，对两端的操作性能很高，通过索引下标操作中间的节点性能会较差。</p><p><strong>常用命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#从左边|右边插入一个或多个值</span></span><br><span class="line">lpush/rpush key value1 value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#从左边|右边取出一个值（并移除），值在键在，值光键亡</span></span><br><span class="line">lpop/rpop key</span><br><span class="line"></span><br><span class="line"><span class="comment">#从key1列表中右边取出一个值，插到key2列表的左边</span></span><br><span class="line">rpoplpush key1 key2</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照索引下标获得元素（从左到右）0 -1指取所有值</span></span><br><span class="line">lrange key start stop</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照索引下标获得元素（从左到右）</span></span><br><span class="line">lindex key index</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得列表长度</span></span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line"><span class="comment">#在value后面插入newvalue</span></span><br><span class="line">linsert key before value newvalue</span><br><span class="line"></span><br><span class="line"><span class="comment">#从左边删除n个value</span></span><br><span class="line">lrem key n value</span><br><span class="line"></span><br><span class="line"><span class="comment">#将列表下标为index的值替换成value</span></span><br><span class="line">lset key value</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Redis（List）底层结构</strong></p><p>List底层数据结构为quickList,在列表元素较少的情况下会使用一块连续的的内存存储，这个结构是zipList，即压缩列表。</p><p>压缩列表：将所有的元素紧挨着一起存储，分配的是一块连续的内存</p><p>当数据量比较大时才会改成quicklist</p><p>普通的链表需要的附加指针空间太大，会比较浪费空间，比如列表中存储的是int类型的数据，结构上还需要两个额外的指针prev和next</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210920174603605.png" class title="image-20210920174603605"><p>Redis将链表和ziplist结合起来组成了quicklist。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余</p><h4 id="Redis（set）"><a href="#Redis（set）" class="headerlink" title="Redis（set）"></a>Redis（set）</h4><p>常用命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member元素加到集合key中，已经存在的member元素将被忽略</span></span><br><span class="line">sadd key value1 value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#取出该集合的所有值</span></span><br><span class="line">smembers key</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断集合key是否含有该value值，有1，没有0</span></span><br><span class="line">sismember key value</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回该集合的元素的个数</span></span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除集合中的某个元素</span></span><br><span class="line">srem key value1 value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机从该集合中吐出一个值</span></span><br><span class="line">spop key</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机从集合中取出n个值。不会从集合中删除</span></span><br><span class="line">srandmember key n</span><br><span class="line"></span><br><span class="line"><span class="comment">#把集合中一个值从一个集合移动到另一个集合</span></span><br><span class="line">smove <span class="built_in">source</span> destination value</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回两个集合的交集元素</span></span><br><span class="line">sinter key1 key2</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回两个集合的并集元素</span></span><br><span class="line">sunion key1 key2</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回集合的差集元素（key1中的，不包含key2中的）</span></span><br><span class="line">sdiff key1 key2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数据结构：</strong></p><p>Set数据结构是dict字典，字典是用哈希表实现的</p><h4 id="Redis（hash）"><a href="#Redis（hash）" class="headerlink" title="Redis（hash）"></a>Redis（hash）</h4><p>Redis hash 是一个键值对集合</p><p>Redis hash是一个String类型的field和value的映射表，hash特别适合存储对象，类似于Java中的Map</p><p>​    </p><p><strong>常用命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#给key集合中的field键赋值value</span></span><br><span class="line">hset key field value</span><br><span class="line"></span><br><span class="line"><span class="comment">#从key集合field取出value</span></span><br><span class="line">hget key field</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量设置hash的值</span></span><br><span class="line">hmset key1 field1 value1 filed2 value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看哈希表key中，给定field是否存在</span></span><br><span class="line">hexists key field</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出该hash集合的所有field</span></span><br><span class="line">hkeys key</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出该hash集合的所有value</span></span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"><span class="comment">#为哈希表key中的域field的值加上增量 1 -1</span></span><br><span class="line">hincrby key field increment</span><br><span class="line"></span><br><span class="line"><span class="comment">#将哈希表key中的域field值设置成value，当且仅当field不存在</span></span><br><span class="line">hsetnx key field value</span><br></pre></td></tr></table></figure><p><strong>数据结构：</strong></p><p>Hash类型对应的数据结构是两种：ziplist（压缩列表）,hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</p><h4 id="Redis有序集合Zset（sorted-set）"><a href="#Redis有序集合Zset（sorted-set）" class="headerlink" title="Redis有序集合Zset（sorted set）"></a>Redis有序集合Zset（sorted set）</h4><p><strong>常用命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个或多个member元素及其score值加入到有序集key当中</span></span><br><span class="line">zadd key score1 value score2 value2</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回有续集key中,下标start stop之间的元素，带WITHSCORED可以让分数一起和值返回到结果集</span></span><br><span class="line">zrange key start stop </span><br><span class="line"></span><br><span class="line"><span class="comment">#返回有续集,所有score 介于min和max之间（包括min和max）有序集合集key中，有序列表成员按score值大小按序排列</span></span><br><span class="line">zrangebyscore key min max [withscores] [<span class="built_in">limit</span> offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#同上，改为从大到小</span></span><br><span class="line">zrevrangebyscore key max min [withscores] [<span class="built_in">limit</span> offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment">#为元素的score加上增量</span></span><br><span class="line">zincrby key increment value</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除该集合下，指定值的元素</span></span><br><span class="line">zrem key value</span><br><span class="line"></span><br><span class="line"><span class="comment">#统计该集合，分数区间内的元素个数</span></span><br><span class="line">zcount key min max</span><br><span class="line"></span><br><span class="line"><span class="comment">#返回该值在集合中的排名，从0开始</span></span><br><span class="line">zrank key value</span><br></pre></td></tr></table></figure><h3 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h3><h3 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h3><h4 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h4><p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息</p><p>Redis客户端可以订阅任意数量的频道</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921181328953.png" class title="image-20210921181328953"><h4 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a>发布订阅命令行实现</h4><p>1、打开一个客户端订阅channel1</p><p><code>SUBSCRIBE  channel1</code></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921181729571.png" class title="image-20210921181729571"><p>2、打开另一个客户端，给channel1发布消息hello</p><p><code>pushlish  channel1  xxxx</code></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921181951793.png" class title="image-20210921181951793"><p>3、第一个客户端可以看到发送的消息</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921182058932.png" class title="image-20210921182058932"><h3 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><p>可进行位操作的字符串</p><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置Bitmaps中某个偏移量的值（0 或 1）</span></span><br><span class="line">setbit key offset value</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921183140397.png" class title="image-20210921183140397"><p>注：在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis阻塞</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取Bitmaps中某个偏移量的值</span></span><br><span class="line">getbit key offset</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921183554902.png" class title="image-20210921183554902"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#统计字符串从start字节到end字节比特为1的数量</span></span><br><span class="line">bitcount key start end</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bitop是一个复合操作，它可以做多个Bitmaps的and(交集),or(并集)，not(非)，xor(异或)操作，并将结果保存在destkey中</span></span><br><span class="line">bitop and(or/not/xor) destkey</span><br></pre></td></tr></table></figure><p>在2021-11-03和11-04日访问网站的记录</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921185106645.png" class title="image-20210921185106645"><p>计算出两天都访问过网站的用户数量</p><p>bitop and users:20211103_04 users:20211103 users:20211104</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站pv(PageView页面访问量)，可以使用Redis的incr、incrby轻松实现。但像UV(UniqueVistor独立访客)、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><ul><li>数据存储在MySQL表中，使用distinct、count计算不重复个数</li><li>使用Redis提供的hash、set、bitmaps可解决</li></ul><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>Redis推出了HyperLogLog，通过降低一定的精度来平衡存储空间</p><p>Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是在输入元素的数量或者体积非常大时，计算基数所需的空间总是固定的，并且是很小的</p><p><strong>命令：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加指定元素到HyperLogLog中,若近似基数发生变化返回1，否则返回0</span></span><br><span class="line">pfadd key element</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921213017413.png" class title="image-20210921213017413"><p><strong>pfcount</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV,计算一周的UV可以使用7天的UV合并计算即可</span></span><br><span class="line">pfcount key1 key2</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921213419104.png" class title="image-20210921213419104"><p><strong>pfmerge</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</span></span><br><span class="line">pfmerge destkey sourcekey</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921213928595.png" class title="image-20210921213928595"><p><strong>Geospatial</strong></p><p>简介：Redis 3.2中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。Redis基于该类型提供了经纬度设置，查询，范围查询，距离查询，经纬度hash等操作</p><p><strong>geoadd</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加地理位置（经度、纬度、名称）</span></span><br><span class="line">geoadd key longitude latitude member</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921215007502.png" class title="image-20210921215007502"><p>两级无法直接添加，一般会下载城市信息，直接通过Java程序一次性导入</p><p>有效的经度从-180度到180度。有效的纬度从-85.05112878度到85.05112878</p><p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>已经添加的数据，是无法再次往里面添加的</p><p><strong>geopos</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获得指定地区的坐标值</span></span><br><span class="line">geopos key member</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921215954294.png" class title="image-20210921215954294"><p><strong>geodist</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取两个位置之间的直线距离</span></span><br><span class="line">geodist key member1 member2 [m|km|ft（英尺）|mi（英里）]（单位）</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921220200673.png" class title="image-20210921220200673"><p><strong>georadius</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#以给定的经纬度为中心，找出某一半径内的元素</span></span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210921220651563.png" class title="image-20210921220651563"><h3 id="Redis-Jedis-测试"><a href="#Redis-Jedis-测试" class="headerlink" title="Redis_Jedis_测试"></a>Redis_Jedis_测试</h3><p><strong>需要的依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>连接的注意事项</strong></p><p>关闭Linux的防火墙</p><h4 id="操作key"><a href="#操作key" class="headerlink" title="操作key"></a>操作key</h4><p>api中的方法名与前面的命令行操作的名字相同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作key</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建jedis对象</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;116.62.122.89&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;mjy600811&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加key-value</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    String value = jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Long time = jedis.ttl(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(time);</span><br><span class="line"></span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h3><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Spring2.x集成redis所需common-pool2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">redis-demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">9002</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#redis</span></span><br><span class="line"><span class="comment">#服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">116.62.122.89</span></span><br><span class="line"><span class="comment">#redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#redis数据库索引</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有联系）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没有限制)</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接数</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接数</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><p>配置RedisConfig</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span> <span class="comment">//开启缓存</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashMap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis-事务-锁机制-秒杀"><a href="#Redis-事务-锁机制-秒杀" class="headerlink" title="Redis-事务-锁机制-秒杀"></a>Redis-事务-锁机制-秒杀</h3><p><strong>Redis事务定义</strong>：</p><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队</p><h4 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210923211402229.png" class title="image-20210923211402229"><h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消；若执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他命令都会执行，不会回滚。</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210923212551067.png" class title="image-20210923212551067"><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210923212832973.png" class title="image-20210923212832973"><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>每次去拿数据的时候都认为别人会修改，所以每次拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里面就用到了很多这种锁机制，比如行锁，表锁等，读锁、写锁等，都是在做操作前上锁。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断以下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check_and_set机制实现事务</p><h4 id="Watch-key1-key2"><a href="#Watch-key1-key2" class="headerlink" title="Watch key1 key2"></a>Watch key1 key2</h4><p>在执行multi之前，先执行watch key1 key2，可以监视一个（或多个）key，如果在事务执行之前这个（这些）key被其他命令所改动，那么事务将被打断。</p><h4 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h4><ul><li>单独的隔离操作：事务中的所有命令都会序列化、按顺序的执行。事务在执行过程中，不会被其他客户端发来的请求所打断</li><li>没有隔离级别的概念：队列中的命令没有提交之前都不会被实际操作，因为事务提交前热河指令都不会被实际执行</li><li>不保证原子性：事务中如果有一条命令执行失败，其后的命令仍然会被执行，不会回滚</li></ul><h3 id="Redis事务秒杀案例"><a href="#Redis事务秒杀案例" class="headerlink" title="Redis事务秒杀案例"></a>Redis事务秒杀案例</h3><h4 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210923222648573.png" class title="image-20210923222648573"><p><strong>秒杀逻辑：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 商品秒杀模拟</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSeckill</span><span class="params">(String prodId, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断商品prodId,或uid是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(prodId==<span class="keyword">null</span>||prodId.length()==<span class="number">0</span>||uid==<span class="keyword">null</span>||uid.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接key</span></span><br><span class="line">        String prodKey=<span class="string">&quot;prod:&quot;</span>+prodId+<span class="string">&quot;:num&quot;</span>;</span><br><span class="line">        String userKey=<span class="string">&quot;user:&quot;</span>+prodId+<span class="string">&quot;:success&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断秒杀活动是否已经开始</span></span><br><span class="line">        Integer count =(Integer)redisTemplate.opsForValue().get(prodKey);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀成功还未开始或已经结束！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断该用户是否已经成功秒杀了一次</span></span><br><span class="line">        Boolean isExist = redisTemplate.opsForSet().isMember(userKey, uid);</span><br><span class="line">        <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您已经成功秒杀到商品，每人限购一件！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断秒杀活动是否剩余商品</span></span><br><span class="line">        <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀商品已经全部被购买！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行秒杀</span></span><br><span class="line">        redisTemplate.opsForValue().decrement(prodKey);</span><br><span class="line">        redisTemplate.opsForSet().add(userKey,uid);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功秒杀&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redis事务–秒杀并发模拟"><a href="#Redis事务–秒杀并发模拟" class="headerlink" title="Redis事务–秒杀并发模拟"></a>Redis事务–秒杀并发模拟</h4><p>使用工具ab模拟测试，CentOS7需要手动安装</p><p>联网：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure><p>无网络：</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210924145730867.png" class title="image-20210924145730867"><p><strong>ab命令</strong>：</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210924150610338.png" class title="image-20210924150610338"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab -n 1000 -c 100 -T application/x-www-form-urlencoded http://10.17.84.120:9002/redisTest/seckill</span><br></pre></td></tr></table></figure><p>由于服务器ping不通本地，所以没有测试</p><h4 id="超卖问题，通过事务实现"><a href="#超卖问题，通过事务实现" class="headerlink" title="超卖问题，通过事务实现"></a>超卖问题，通过事务实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 商品秒杀模拟</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doSeckill</span><span class="params">(String prodId, String uid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断商品prodId,或uid是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(prodId==<span class="keyword">null</span>||prodId.length()==<span class="number">0</span>||uid==<span class="keyword">null</span>||uid.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接key</span></span><br><span class="line">        String prodKey=<span class="string">&quot;prod:&quot;</span>+prodId+<span class="string">&quot;:num&quot;</span>;</span><br><span class="line">        String userKey=<span class="string">&quot;user:&quot;</span>+prodId+<span class="string">&quot;:success&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断秒杀活动是否已经开始</span></span><br><span class="line">        Integer count =(Integer)redisTemplate.opsForValue().get(prodKey);</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀成功还未开始或已经结束！！！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用事务</span></span><br><span class="line">        List list = (List) redisTemplate.execute(<span class="keyword">new</span> SessionCallback&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(RedisOperations redisOperations)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                <span class="comment">// 监视库存</span></span><br><span class="line">                redisOperations.watch(prodKey);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断该用户是否已经成功秒杀了一次</span></span><br><span class="line">                Boolean isExist = redisOperations.opsForSet().isMember(userKey, uid);</span><br><span class="line">                <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;您已经成功秒杀到商品，每人限购一件！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断秒杀活动是否剩余商品</span></span><br><span class="line">                <span class="keyword">if</span>(count&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;秒杀商品已经全部被购买！！&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                redisOperations.multi();</span><br><span class="line">                redisOperations.opsForValue().decrement(prodKey);</span><br><span class="line">                redisOperations.opsForSet().add(userKey, uid);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> redisOperations.exec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span>||list.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功秒杀&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="乐观锁造成库存遗留问题"><a href="#乐观锁造成库存遗留问题" class="headerlink" title="乐观锁造成库存遗留问题"></a>乐观锁造成库存遗留问题</h4><h5 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h5><p>Lua是一个小巧的<strong>脚本语言</strong>，Lua脚本可以很容易的被C/C++代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个Lua解释器不超过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p><h5 id="LUA脚本在Redis中的优势"><a href="#LUA脚本在Redis中的优势" class="headerlink" title="LUA脚本在Redis中的优势"></a>LUA脚本在Redis中的优势</h5><p>将复杂的或者多步的Redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p><p>LUA脚本是类似redis事务，有一定原子性，不会被其他命令插队，可以完成一些redis事务性的操作。</p><p>redis的Lua脚本功能，只有在Redis2.6以上的版本才可以使用</p><p>利用lua脚本淘汰用户，解决超卖问题</p><p>redis2.6版本以后，通过lua脚本解决争抢问题，实际上是redis利用其单线程的特性，用任务队列的方式解决多任务并发问题。</p><p><strong>Lua脚本：</strong></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> userId=KEYS[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">local</span> prodId=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;prod:&quot;</span>..prodId..<span class="string">&quot;:num&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> userkey=<span class="string">&quot;sk:&quot;</span>..prodId..<span class="string">&quot;:usr&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> userExists=redis.call(<span class="string">&quot;sismember&quot;</span>,userkey,userId);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(userExists)==<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> num=redis.call(<span class="string">&quot;get&quot;</span>,qtkey);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(num)&lt;=<span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">redis.call(<span class="string">&quot;decr&quot;</span>,qtkey);</span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>,userkey,userId);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="持久化之RDB"><a href="#持久化之RDB" class="headerlink" title="持久化之RDB"></a>持久化之RDB</h3><h4 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h4><p>在指定的<strong>时间间隔</strong>内将内存中的数据集<strong>快照</strong>写入磁盘，它恢复时是将快照文件直接读到内存中。</p><h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入一个临时文件中，待持久化过程都结束了，再用这个<strong>临时文件替换上次持久化</strong>的文件，整个过程中，主进程是不进行任何操作，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是特别敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是<strong>最后一次持久化后的数据可能丢失</strong></p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><p>Fork的作用是复制一个与当前进程<strong>一样的进程</strong>，新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p><p>在linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时赋值技术”</p><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</p><h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a>dump.rdb文件</h4><p><strong>rdb文件的优势：</strong></p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><strong>劣势：</strong></p><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能</li><li>备份周期在一定时间间隔内做一次备份，如果Redis意外挂掉的话，就会丢失最后一次快照的所有修改</li></ul><h3 id="Redis持久化之AOF"><a href="#Redis持久化之AOF" class="headerlink" title="Redis持久化之AOF"></a>Redis持久化之AOF</h3><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p><strong>以日志的形式来记录每个写操作（增量保存）</strong>，将Redis执行过的所有写指令记录下来（<strong>读操作不记录</strong>），<strong>只许追加内容但不可以改写文件</strong>，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为<strong>appendonly.aof</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启AOF</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925153837342.png" class title="image-20210925153837342"><p>AOF文件的保存路径，同RDB的路径一致</p><h4 id="AOF和RDB同时开启，Redis听谁的"><a href="#AOF和RDB同时开启，Redis听谁的" class="headerlink" title="AOF和RDB同时开启，Redis听谁的"></a>AOF和RDB同时开启，Redis听谁的</h4><p>AOF和RDB同时开启，系统默认读取AOF的数据（数据不会存在丢失）</p><h4 id="AOF异常恢复"><a href="#AOF异常恢复" class="headerlink" title="AOF异常恢复"></a>AOF异常恢复</h4><p>如遇到AOF文件损坏，通过/usr/local/bin/redis-check-aof –fix</p><p>appendonly.aof进行恢复</p><h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><p><strong>appendfsync always</strong></p><p>始终同步，每次redis的写入都会立刻写入日志，性能较差但数据完整性比较好</p><p><strong>appendfsync everysec</strong> </p><p>每秒同步，每秒记入日志一次，如果宕机，当前秒的数据可能会丢失</p><p><strong>appendfsync no</strong></p><p>redis不主动进行同步，把<strong>同步时机交给操作系统</strong></p><h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><p>AOF采用文件追加方式，文件会越来越大为避免这种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令<strong>bgrewriteaof</strong></p><p><strong>重写原理，如何实现重写</strong></p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename）,<strong>redis4.0版本后的重写，是指把rdb的快照以二进制的形式附在新的aof头部，作为已有的历史数据，替换掉</strong>原来的流水账操作</p><p><strong>触发机制，何时重写</strong></p><p>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的以呗且文件大于64M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间，但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写</p><p><strong>auto-aof-rewrite-percentage</strong>：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64M。达到这个值开始重写</p><p><strong>重写流程：</strong></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925160906610.png" class title="image-20210925160906610"><h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h4><ul><li>客户端的请求写命令会被追加到AOF缓冲区中</li><li>AOF缓冲区根据AOF持久化策略【always、everysec、no】将操作sync同步到磁盘的aof文件中</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量</li><li>redis服务重启时，会重新load加载AOF文件中的写操作达到恢复数据的目的</li></ul><p><strong>优点：</strong></p><ul><li>备份机制更加稳健，丢失数据概率更低</li><li>刻度的日志文本，通过操作AOF稳健，可以处理误操作</li></ul><p><strong>缺点：</strong></p><ul><li><p>比起RDB占用更多的磁盘空间</p></li><li><p>恢复备份速度慢</p></li><li><p>每次读写都同步的话，有一定的性能压力</p></li><li><p>存在个别bug,造成不能恢复</p></li></ul><h4 id="总结：选哪个好"><a href="#总结：选哪个好" class="headerlink" title="总结：选哪个好"></a>总结：选哪个好</h4><p>官方推荐两个都启用</p><p>如果对数据不明干，可以选单独用RDB</p><p>不建议单独用AOF，因为可能会出现Bug</p><p>如果知识做纯内存缓存，可以都不用</p><h3 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis_主从复制"></a>Redis_主从复制</h3><p>主机数据更新后根据配置和策略，自动同步到备机的<strong>master/slaver</strong>机制，<strong>Master以写为主，Slave以读为主</strong></p><p><strong>用处：</strong></p><ul><li>读写分离，性能扩展</li><li>容灾快速恢复 </li></ul><h4 id="配置一主两从"><a href="#配置一主两从" class="headerlink" title="配置一主两从"></a>配置一主两从</h4><ul><li><p>创建/myredis文件夹</p></li><li><p>将redis.conf配置文件复制到/myredis中</p></li><li><p>配置一主两从，创建三个配置文件</p><p>redis6379.conf</p><p>redis6380.conf</p><p>redis6381.conf</p></li><li><p>在三个配置文件写入配置内容</p><p><strong>在redis6379.conf中写入以下内容</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure><p>另外两个文件同上。</p></li><li><p>启动三个redis服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">redis-server myredis/redisxxx.conf</span><br><span class="line"><span class="comment">#客户端</span></span><br><span class="line">redis-cli -p xxx</span><br></pre></td></tr></table></figure></li><li><p>查看三台主机的运行情况</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#打印主从复制的相关信息</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925180158541.png" class title="image-20210925180158541"><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925180224781.png" class title="image-20210925180224781"><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925180249219.png" class title="image-20210925180249219"></li><li><p>配从（库）不配主（库）</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">#成为某个实例的从服务器</span><br><span class="line">slaveof ip port</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925180649399.png" class title="image-20210925180649399"><p><strong>出现问题：</strong>主节点不显示从节点信息</p><p>原因：master设置了密码，若需要实现主从复制，需要在配置文件中设置<code>masterauth  password</code></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925183208343.png" class title="image-20210925183208343"><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925184456075.png" class title="image-20210925184456075"><p> 配置成功显示（上述操作知识临时的，当redis重启会失效）</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210925184602872.png" class title="image-20210925184602872"></li></ul><h4 id="常用三招"><a href="#常用三招" class="headerlink" title="常用三招"></a>常用三招</h4><p><strong>一主二仆：</strong></p><p>主服务器可以写和读，从服务器只能读不能写</p><p>从服务器挂掉之后重启服务器，会变成主服务器，重新操作之后会将主服务器中的数据从头复制。</p><p>当主服务器挂掉后，从服务器不做任何操作，当主服务器重启之后，仍然是之前的从服务器的主服务器。</p><p><strong>主从复制的原理：</strong></p><ul><li>当从服务器连接上主服务器之后，从服务器向主服务器发送进行数据同步的消息</li><li>主服务器接到从服务器发送过来的同步消息后，把主服务器数据进行持久化，将数据放到rdb文件，再将rdb文件发送给从服务器，从服务器拿到rdb进行读取</li><li>每次主服务器进行写操作 之后，和从服务器进行数据同步</li></ul><p><strong>薪火相传：</strong></p><p>从服务器下面还能有从服务器，主服务器进行写操作之后，从服务器依旧将数据进行同步。</p><p><strong>反客为主：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#把从机变成主机</span></span><br><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库</p><p><strong>实现哨兵模式</strong></p><p>先将服务器变成一主二仆的形式</p><p>在自定义的/myredis目录下新建sentinel.conf 文件，名字不能错</p><p>sentinel.conf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mymaster为监控对象起的服务器名称，1为至少有多少个哨兵同意迁移的数量</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>启动哨兵</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-sentinel myredis/sentinel.conf</span><br></pre></td></tr></table></figure><p>当主服务器挂掉后，会在从服务器中选出一个作为主服务器，而挂掉的主服务器会作为新的主服务器的一个从服务器。</p><p><strong>复制延时</strong></p><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更严重，Slave机器数量的增加也会使这个问题更加严重。</p><p><strong>选取主服务器的规则：</strong></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926004720025.png" class title="image-20210926004720025"><h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><h4 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h4><p>Redis集群实现了对Redis的水平扩容，及启动N个Redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N</p><p>Redis集群通过分区（partition）来提供一定程度的可用性（availability）:即使集群中有一部分节点失效或者无法进行通信，集群也可以继续处理命令请求</p><h4 id="搭建Redis集群"><a href="#搭建Redis集群" class="headerlink" title="搭建Redis集群"></a>搭建Redis集群</h4><p><strong>删除持久化数据：</strong></p><p>将rdb，aof文件都删除掉</p><p><strong>制作6个实例，6379，6380，6381，6389，6390，6391</strong></p><p><strong>配置基本信息：</strong></p><p>开启daemonize yes</p><p>Pid文件名字</p><p>指定端口</p><p>log文件名字</p><p>dump.rdb 名字</p><p>appendonly 关掉或换名字</p><p><strong>Redis cluster配置修改</strong></p><p>cluster-enable yes  打开集群模式</p><p>cluster-config-file nodes-6379.conf  设置节点配置文件名</p><p>cluster-node-timeout 15000  设节点失联时间，超过该时间（毫秒），集群自动进行主从切换</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926204453558.png" class title="image-20210926204453558"><p>其它节点的配置文件类似</p><p><strong>启动节点：</strong></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926205056793.png" class title="image-20210926205056793"><p><strong>将6个节点合成一个集群</strong></p><p>组合之前请确保所有redis实例启动后，nodes-xxx.conf文件都正常生成</p><p>cd 到/usr/local/redis/redis-6.2.3/src目录下（该目录为自己安装的redis的地址）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#合成集群 --replicas 1采用最简单的方式配置集群，一台主机，一台从机，正好三组(这里的ip使用的阿里云服务器的内网ip)</span></span><br><span class="line">redis-cli -a mjy600811 --cluster create --cluster-replicas 1 172.19.11.126:6379 172.19.11.126:6380 172.19.11.126:6381 172.19.11.126:6389 172.19.11.126:6390 172.19.11.126:6391</span><br><span class="line"></span><br><span class="line">redis-cli -a mjy600811 --cluster create --cluster-replicas 1 116.62.122.89:6379 116.62.122.89:6380 116.62.122.89:6381 116.62.122.89:6389 116.62.122.89:6390 116.62.122.89:6391</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926212055531.png" class title="image-20210926212055531"><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926212110418.png" class title="image-20210926212110418"><p>使用公网ip一直waiting的解决办法</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927123520744.png" class title="image-20210927123520744"><p><strong>采用集群策略连接，设置数据会自动切换到相应的写主机</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-c指采用集群策略连接</span></span><br><span class="line">redis-cli -c -p xxx</span><br><span class="line"><span class="comment">#查看节点信息</span></span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><p>采用cluster nodes 查看节点信息</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926212752329.png" class title="image-20210926212752329"><h4 id="redis-cluster如何分配这六个节点"><a href="#redis-cluster如何分配这六个节点" class="headerlink" title="redis cluster如何分配这六个节点"></a>redis cluster如何分配这六个节点</h4><p>一个集群至少有<strong>三个主节点</strong></p><p>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</p><h4 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926221101029.png" class title="image-20210926221101029"><p>一个Redis集群包含16384个插槽（hash slot），数据库中的每个键都属于这16384个插槽中的其中一个</p><p>集群使用公式CRC16(key)%16384来计算key属于哪个插槽，其中CRC16(key)语句用于计算键key的CRC16校验和。其中集群中的每个节点负责处理一部分插槽。</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926221543281.png" class title="image-20210926221543281"><h4 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926225324838.png" class title="image-20210926225324838"><p>直接使用mset命令会出错</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926225405961.png" class title="image-20210926225405961"><p>设置多个值</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926225529108.png" class title="image-20210926225529108"><p>查询集群中的值</p><p>cluster keyslot key:查看key计算出的插槽值</p><p>cluster countkeysinslot  slotval:查看插槽值对应的插槽中的键的个数</p><p>cluster getkeysinslot slotval  num：查看插槽值对应的插槽中的num个值</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926225947889.png" class title="image-20210926225947889"><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>如果主节点下线，从节点能否自动升为主节点。注意：15秒超时</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210926232023054.png" class title="image-20210926232023054"><p>主节点恢复后，会变成从机</p><p>如果所有某一段插槽的主从都挂掉，而cluster-require-full-coverage为yes，那么整个集群都挂掉</p><p>如果所有某一段插槽的主从都挂掉，而cluster-require-full-coverage为no，那么该插槽数据全都不能使用，也无法存储</p><h4 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群，无论从哪台主机写的数据，其它主机上都能读到数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClusterDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        Set&lt;HostAndPort&gt; nodes=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">&quot;116.62.122.89&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">        <span class="comment">//注意：这里超时时间不要太短，他会有超时重试机制。而且其他像httpclient、dubbo等RPC框架也要注意这点</span></span><br><span class="line">        JedisCluster jedisCluster = <span class="keyword">new</span> JedisCluster(nodes,<span class="number">1000</span>,<span class="number">1000</span>,<span class="number">1</span>,<span class="string">&quot;mjy600811&quot;</span>,<span class="keyword">new</span> GenericObjectPoolConfig());</span><br><span class="line"></span><br><span class="line">        jedisCluster.set(<span class="string">&quot;uid&quot;</span>,<span class="string">&quot;378423&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String uid = jedisCluster.get(<span class="string">&quot;uid&quot;</span>);</span><br><span class="line">        System.out.println(uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Redis集群提供了以下好处"><a href="#Redis集群提供了以下好处" class="headerlink" title="Redis集群提供了以下好处"></a>Redis集群提供了以下好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h4 id="Redis集群的不足"><a href="#Redis集群的不足" class="headerlink" title="Redis集群的不足"></a>Redis集群的不足</h4><p>多键操作是不被支持的</p><p>多键的Redis事务是不被支持的。lua脚本不被支持</p><p>由于集群方案出现交完，很多公司已经采用了其他的集群方案，而代理或客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><h3 id="Redis6应用问题解决"><a href="#Redis6应用问题解决" class="headerlink" title="Redis6应用问题解决"></a>Redis6应用问题解决</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>问题描述：</strong></p><p>key对应的数据在数据源并不存在，每次针对此key的请求从缓存中获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不了缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927163719793.png" class title="image-20210927163719793"><p>可能发生的条件：</p><ul><li>访问量剧增，应用服务器压力变大了</li><li>redis命中率降低</li><li>一直查询数据库</li><li>出现很多非正常的url访问</li></ul><p><strong>解决方案：</strong></p><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致每次请求都要到存储层去查询，失去了缓存的意义。</p><p>解决办法：</p><p><strong>对空值进行缓存</strong>：如果一个查询返回的数据为空（不管数据是否存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过5分钟</p><p><strong>设置可访问的名单（白名单）</strong>：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmaps里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问</p><p><strong>采用布隆过滤器</strong>：布隆过滤器是1970年由布隆提出的，它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的识别率和删除困难将所有困难存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的压力</p><p><strong>进行实时监控：</strong></p><p>当发现Redis的命中率开始急速下降，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>问题描述</strong></p><p>key对应的数据存在，但在Redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候高并发的请求可能会瞬间把后端DB压垮</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927170931378.png" class title="image-20210927170931378"><p><strong>特点：</strong></p><p>数据库访问压力瞬时增大</p><p>redis里面没有出现大量key过期</p><p>redis正常运行</p><p><strong>造成的原因</strong></p><p>redis某个key刚好过期，大量访问使用这个key,例如热搜</p><p><strong>解决方案</strong></p><p>key可能会在某些时间点被超高并发的访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被击穿</p><p><strong>解决方法：</strong></p><p><strong>预先设置热门数据：</strong>在redis访问高峰期之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的有效期</p><p><strong>实时调整：</strong>现场监控哪些是热门数据，实时调整key的过期时长</p><p><strong>使用锁：</strong></p><ul><li>在缓存失效的时候（判断拿出来的值为空），而不是立即去load db</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如 Redis的setnx）去set 一个mutex key</li><li>当操作返回成功时，再进行load db操作，并回设缓存，最后删除mutex key</li><li>当操作返回失败，这名有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法</li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>问题描述</strong></p><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发请求可能会瞬间把后端DB压垮</p><p>缓存雪崩与缓存击穿的区别在于缓存雪崩针对很多key缓存，而缓存击穿则是针对某一个热点key</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927173323503.png" class title="image-20210927173323503"><p>特点：</p><p>数据库压力变大，服务器崩溃</p><p>造成原因：</p><p>在某一时间内，大量key过期，且出现大量请求</p><p><strong>解决方案：</strong></p><p><strong>构建多级缓存架构：</strong>nginx缓存+redis缓存+其它缓存（echache）等</p><p><strong>使用锁或队列：</strong>用加锁或者队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上，不适用于高并发情况下。</p><p><strong>设置过期标志更新缓存：</strong>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际的key的缓存</p><p><strong>将缓存失效时间分散开</strong></p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h4 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h4><p>使用setnx上锁，del释放锁</p><p>但这样会存在一个问题，当setnx操作完以后，程序挂掉了del操作未能执行，锁没能释放。</p><p>解决方法：使用expire命令给锁设置一个过期时间</p><p>但这样同样还有问题，若在上锁后，设置过期时间之前，服务挂掉了，那么会导致未能设置过期时间，从而导致锁一直不能释放</p><p>解决办法：将上锁和设置过期时间的命令写成一条命令</p><p><code>set  key  val  nx  ex 过期时间</code></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927213757267.png" class title="image-20210927213757267"><p>设置了过期时间后还有一个问题，若当某个线程拿到锁后进行操作，由于操作时间比较长，锁已经过期了，这时另一个线程拿到了锁，当之前的线程执行完成后，又手动释放了另一个线程的锁。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String key=<span class="string">&quot;lock&quot;</span>;</span><br><span class="line">        <span class="keyword">long</span> timeout=<span class="number">30</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        String uuid= UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置lock的值为1，过期时间为30，单位为秒</span></span><br><span class="line">        Boolean lock = redisTemplate.opsForValue().setIfAbsent(key, <span class="number">1</span>, timeout, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">            <span class="comment">// 记录值</span></span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 业务执行完之后，手动释放锁</span></span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 没能拿到锁，每隔0.1秒再获取</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                getLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="UUID防误删"><a href="#UUID防误删" class="headerlink" title="UUID防误删"></a>UUID防误删</h4><p>解决办法：将lock的值设为UUID，在释放锁之前比较uuid是否相同，若相同则释放锁，若不是则不释放锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String key=<span class="string">&quot;lock&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> timeout=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    String uuid= UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置lock的值为1，过期时间为30，单位为秒</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// 记录值</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line"></span><br><span class="line">        String val = (String)redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(uuid.equals(val))&#123;</span><br><span class="line">            <span class="comment">// 业务执行完之后，手动释放锁</span></span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没能拿到锁，每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            getLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原子性操作造成问题"><a href="#原子性操作造成问题" class="headerlink" title="原子性操作造成问题"></a>原子性操作造成问题</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927215858620.png" class title="image-20210927215858620"><p><strong>问题描述：</strong></p><p>当a线程获得锁，并且操作完后，会获取lock的值，获得的lock的值与uuid相同，正要执行下面的操作时，key过期了，此时b拿到了锁，而a线程则删除了b的锁</p><p>解决办法：使用Lua脚本（只能在单机上操作，集群不行）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String key=<span class="string">&quot;lock&quot;</span>;</span><br><span class="line">    <span class="keyword">long</span> timeout=<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    String uuid= UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置lock的值为1，过期时间为30，单位为秒</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="comment">// 记录值</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>,++num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*String val = (String)redisTemplate.opsForValue().get(key);</span></span><br><span class="line"><span class="comment">        if(uuid.equals(val))&#123;</span></span><br><span class="line"><span class="comment">            // 业务执行完之后，手动释放锁</span></span><br><span class="line"><span class="comment">            redisTemplate.delete(key);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        String str=<span class="string">&quot;if ARGV[1]==redis.call(&#x27;get&#x27;,KEYS[1]) then&quot;</span> +</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;del&#x27;,KYES[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置Lua脚本返回的数据类型</span></span><br><span class="line">        RedisScript&lt;Long&gt; script = RedisScript.of(str, Long.class);</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line">        redisTemplate.execute(script,list,uuid);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没能拿到锁，每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            getLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927221241645.png" class title="image-20210927221241645"><h3 id="Redis6-0新功能"><a href="#Redis6-0新功能" class="headerlink" title="Redis6.0新功能"></a>Redis6.0新功能</h3><h4 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h4><p>Redis ACL是Access Control List(访问控制列表)的缩写，该功能允许根据可执行的命令和可以访问的键来限制某些连接。</p><p>在Redis 5版本之前，Redis安全规则只有密码控制，还有通过rename来调整高危命令比如flushdb，keys *,shutdown等，Redis6 则提供ACL的功能对用户进行更细粒度的权限控制</p><ul><li>接入权限：用户名和密码</li><li>可以执行的命令</li><li>可以操作的key</li></ul><p>参考官网：<a href="https://redis.io/topic/acl">https://redis.io/topic/acl</a></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>使用acl  list命令展现用户列表</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927222115093.png" class title="image-20210927222115093"><p>acl cat命令</p><p>（1）查看添加权限指令类别</p><p>​            <img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927222619437.png" class title="image-20210927222619437"></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927222649327.png" class title="image-20210927222649327"><p>acl whoami 命令查看当前用户</p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927222843968.png" class title="image-20210927222843968"><p>设置有用户名、密码、ACL权限、并启用用户</p><p>acl setuser user2 on &gt;password ~cached:* +get</p><h4 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h4><p>简介：</p><p>Redis6终于支持多线程了。IO多线程其实指<strong>客户端交互部分的网络IO</strong>交互模块多线程，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p><p><strong>原理架构：</strong></p><p>Redis6 加入多线程，但跟Memcached这种从IO处理到数据访问多线程的实现模式有些差异。Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制key ,lua、事务、LPUSH/LPOP等等的并发问题</p><p><strong>多线程IO默认是不开启的，需要在配置文件中配置</strong></p><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927225139877.png" class title="image-20210927225139877"><p>io-threads-do-redis yes ：开启</p><h4 id="工具支持Cluster"><a href="#工具支持Cluster" class="headerlink" title="工具支持Cluster"></a>工具支持Cluster</h4><img src="/2021/09/20/Redis%E5%AD%A6%E4%B9%A0/image-20210927225255453.png" class title="image-20210927225255453">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Swagger2</title>
      <link href="/2021/09/14/SpringBoot%E6%95%B4%E5%90%88Swagger2/"/>
      <url>/2021/09/14/SpringBoot%E6%95%B4%E5%90%88Swagger2/</url>
      
        <content type="html"><![CDATA[<p>作为一个后端开发人员，测试是必不可少的工作，而swagger2作为一个测试接口的工具会为我们的工作带来方便。</p><h4 id="首先，创建一个SpringBoot项目，导入依赖"><a href="#首先，创建一个SpringBoot项目，导入依赖" class="headerlink" title="首先，创建一个SpringBoot项目，导入依赖"></a>首先，创建一个SpringBoot项目，导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h4><p>配置Swagger2需要开发者自己提供一个Docket的Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.servicebase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Predicates;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-05-09 22:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line"><span class="comment">//                .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;)))</span></span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">&quot;/error.*&quot;</span>)))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">&quot;网站-课程中心API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;本文档描述了课程中心微服务接口定义&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;Helen&quot;</span>, <span class="string">&quot;http://mjy.com&quot;</span>, <span class="string">&quot;55317332@qq.com&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个Bean中，我们需要配置映射路径和要扫描接口的位置。</p><p>ApiInfo主要配置一下Swagger2文档页面显示的一些信息，例如：网站的title、网站的描述、联系人的信息、使用的协议等。</p><h4 id="Swagger的注解"><a href="#Swagger的注解" class="headerlink" title="Swagger的注解"></a>Swagger的注解</h4><p>@Api：可以用来标记当前Controller的功能</p><p>@ApiOperation：用来标记一个方法的作用</p><p>@ApiImplicitParam：用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值。</p><p>注：若有多个参数，则需要使用多个@ApiImplicitParam注解来描述，多个@ApiImplicitParam注解需要放在一个@ApiImplicitParams</p><p><strong>实例：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(tags=&quot;讲师管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/eduService/teacher&quot;)</span></span><br><span class="line"><span class="comment">//@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TeacherService teacherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询讲师表所有数据</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;所有讲师列表&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">getAllTeacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        List&lt;Teacher&gt; list = teacherService.list(<span class="keyword">null</span>);</span><br><span class="line">        map.put(<span class="string">&quot;items&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> RebackInfo.ok().data(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑删除</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;通过id逻辑删除讲师&quot;)</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">deleteTeacherById</span><span class="params">(<span class="meta">@ApiParam(name=&quot;id&quot;,value=&quot;讲师ID&quot;,required=true)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="meta">@PathVariable</span> String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = teacherService.removeById(id);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> RebackInfo.ok();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> RebackInfo.error();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页查询讲师</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;分页查修讲师&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;pageTeacher/&#123;current&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">pageTeacher</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">long</span> current,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="meta">@PathVariable</span> <span class="keyword">long</span> limit)</span></span>&#123;</span><br><span class="line">        Page&lt;Teacher&gt; page = <span class="keyword">new</span> Page&lt;&gt;(current,limit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法实现</span></span><br><span class="line">        <span class="comment">//底层会将查询到的数据封装到传入的page中，我们可以通过page获得数据</span></span><br><span class="line">        teacherService.page(page, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Teacher&gt; records = page.getRecords();</span><br><span class="line">        Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>,page.getTotal());</span><br><span class="line">        map.put(<span class="string">&quot;teachers&quot;</span>,records);</span><br><span class="line">        <span class="keyword">return</span> RebackInfo.ok().data(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//条件查询带分页的方法</span></span><br><span class="line">    <span class="meta">@ApiOperation(value=&quot;条件带分页查询讲师&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;pageTeacherCondition/&#123;current&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">pageTeacherCondition</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">long</span> current,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="meta">@PathVariable</span> <span class="keyword">long</span> limit,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="meta">@RequestBody(required=false)</span> TeacherQuery teacherQuery)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建page对象</span></span><br><span class="line">        Page&lt;Teacher&gt; page = <span class="keyword">new</span> Page&lt;&gt;(current,limit);</span><br><span class="line">        <span class="comment">//构建条件</span></span><br><span class="line">        QueryWrapper&lt;Teacher&gt; wrapper=<span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        String name = teacherQuery.getName();</span><br><span class="line">        Integer level = teacherQuery.getLevel();</span><br><span class="line">        String begin = teacherQuery.getBegin();</span><br><span class="line">        String end = teacherQuery.getEnd();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断条件值是否为空，如果不为空拼接条件</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(name))&#123;</span><br><span class="line">            wrapper.like(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(level))&#123;</span><br><span class="line">            wrapper.eq(<span class="string">&quot;level&quot;</span>,level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(begin))&#123;</span><br><span class="line">            wrapper.ge(<span class="string">&quot;gmt_create&quot;</span>,begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(end))&#123;</span><br><span class="line">            wrapper.le(<span class="string">&quot;gmt_create&quot;</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照时间降序排列</span></span><br><span class="line">        wrapper.orderByAsc(<span class="string">&quot;gmt_create&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用方法实现分页</span></span><br><span class="line">        teacherService.page(page,wrapper);</span><br><span class="line">        List&lt;Teacher&gt; records = page.getRecords();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;items&quot;</span>,records);</span><br><span class="line">        map.put(<span class="string">&quot;total&quot;</span>,page.getTotal());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RebackInfo.ok().data(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于参数的描述，也可以应用在实体类中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = false)</span></span><br><span class="line"><span class="meta">@Accessors(chain = true)</span></span><br><span class="line"><span class="meta">@TableName(&quot;edu_teacher&quot;)</span></span><br><span class="line"><span class="meta">@ApiModel(value=&quot;Teacher对象&quot;, description=&quot;讲师&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;讲师ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.ID_WORKER_STR)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;讲师姓名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;讲师简介&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;讲师资历,一句话说明讲师&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String career;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;头衔 1高级讲师 2首席讲师&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;讲师头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;排序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;逻辑删除 1（true）已删除， 0（false）未删除&quot;)</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="meta">@TableField(fill=FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Integer isDeleted;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;创建时间&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(fill=FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date gmtCreate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;更新时间&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(fill=FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date gmtModified;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置完成后，访问swagger:<a href>localhost:8001/swagger-ui.html</a></p><img src="/2021/09/14/SpringBoot%E6%95%B4%E5%90%88Swagger2/image-20210510093614533.png" class title="image-20210510093614533">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="在Linux上安装MySQL"><a href="#在Linux上安装MySQL" class="headerlink" title="在Linux上安装MySQL"></a>在Linux上安装MySQL</h3><p>检查当前系统是否安装过mysql</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询命令</span></span><br><span class="line">rpm -qa|grep - i mysql</span><br><span class="line"><span class="comment">#删除命令</span></span><br><span class="line">rpm -e RPM软件包名（该名字是查询命令查询出来的名字）</span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.x86_64</span><br><span class="line"><span class="comment">#普通删除模式</span></span><br><span class="line">rpm -e mysql</span><br><span class="line"><span class="comment">#强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</span></span><br><span class="line">rpm -e --nodeps mysql　　</span><br></pre></td></tr></table></figure><p>下载MySQL rpm安装包（MySQL官网：<a href="https://dev.mysql.com/downloads/mysql/">MySQL :: Download MySQL Community Server</a>）</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912154148995.png" class title="image-20210912154148995"><h5 id="使用rpm命令安装"><a href="#使用rpm命令安装" class="headerlink" title="使用rpm命令安装"></a>使用rpm命令安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#参数用rpm --help自行查看</span><br><span class="line">rpm -ivh mysql-community-common-5.7.35-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><h5 id="查看mysql安装目录"><a href="#查看mysql安装目录" class="headerlink" title="查看mysql安装目录"></a>查看mysql安装目录</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef |grep mysql</span><br></pre></td></tr></table></figure><h5 id="可能会出现以下错误"><a href="#可能会出现以下错误" class="headerlink" title="可能会出现以下错误"></a>可能会出现以下错误</h5><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912152734558.png" class title="image-20210912152734558"><p><strong>首先查看libaio是否安装使用</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">rpm -qa|grep libaio</span><br></pre></td></tr></table></figure><h5 id="若无libaio-则使用命令进行安装"><a href="#若无libaio-则使用命令进行安装" class="headerlink" title="若无libaio,则使用命令进行安装"></a>若无libaio,则使用命令进行安装</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install  libaio-devel.x86_64</span><br></pre></td></tr></table></figure><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912153015786.png" class title="image-20210912153015786"><p>安装好之后，继续使用上述命令进行安装</p><h5 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h5><p>安装顺序：common-&gt;libs-&gt;client-&gt;server</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-community-common-5.7.35-1.el7.x86_64.rpm mysql-community-libs-5.7.35-1.el7.x86_64.rpm mysql-community-client-5.7.35-1.el7.x86_64.rpm mysql-community-server-5.7.35-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912154416564.png" class title="image-20210912154416564"><h5 id="安装完成后，进行验证"><a href="#安装完成后，进行验证" class="headerlink" title="安装完成后，进行验证"></a>安装完成后，进行验证</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld start　　　　　　　　<span class="comment">#开启MySQL服务　　　　只要没有错误信息就表示已经正常启动了。</span></span><br><span class="line">service mysqld stop　　　　　　　　<span class="comment">#关闭MySQL服务</span></span><br><span class="line">service mysqld restart　　　　　　<span class="comment">#重启MySQL服务 </span></span><br><span class="line">service mysqld status　　　　　　<span class="comment">#查看服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以是</span></span><br><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure><h5 id="查看默认密码"><a href="#查看默认密码" class="headerlink" title="查看默认密码"></a>查看默认密码</h5><p>MySQL5.7会在安装后为root用户生成一个随机临时密码，系统赋予了***默认的且临时的***密码，打开mysql默认日志文件/var/log/mysqld.log</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看日志文件</span></span><br><span class="line">cat /var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="comment">#或直接在日志文件中搜索</span></span><br><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912155134257.png" class title="image-20210912155134257"><p>拿到密码后可以进行登录，但是当我们执行SQL命令时就会报错（提示我们必须先重置密码）</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912155951893.png" class title="image-20210912155951893"><p>MySQL安装时默认安装了 <a href="http://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html">validate_password</a>，MySQL的密码策略比较复杂。这个插件要求密码至少包含一个大写字母，一个小写字母，一个数字和一个特殊字符，并且密码长度至少8个字符。过于简单的密码，不会被通过。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 重置MySQL（root）登录密码</span><br><span class="line"><span class="keyword">set</span> password <span class="operator">=</span> password(<span class="string">&#x27;MySQL5.7&#x27;</span>);　　　　　　</span><br><span class="line">#或者如下格式：</span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> 用户名<span class="variable">@localhost</span><span class="operator">/</span>ip<span class="operator">/</span><span class="operator">%</span> <span class="operator">=</span> password(<span class="string">&#x27;新密码&#x27;</span>); #Ccr600811<span class="operator">!</span></span><br></pre></td></tr></table></figure><h5 id="查看密码策略相关参数"><a href="#查看密码策略相关参数" class="headerlink" title="查看密码策略相关参数"></a>查看密码策略相关参数</h5><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912160955545.png" class title="image-20210912160955545"><h5 id="禁用validate-password密码策略"><a href="#禁用validate-password密码策略" class="headerlink" title="禁用validate_password密码策略"></a>禁用validate_password密码策略</h5><p>在/etc/my.cnf中添加以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">validate_password = off</span><br></pre></td></tr></table></figure><p>修改后需要重启mysql服务</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912161147171.png" class title="image-20210912161147171"><h4 id="数据库乱码问题（推荐设置）"><a href="#数据库乱码问题（推荐设置）" class="headerlink" title="数据库乱码问题（推荐设置）"></a>数据库乱码问题（推荐设置）</h4><p>查看MySQL编码问题</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%character_set%&#x27;</span></span><br></pre></td></tr></table></figure><p>添加如下配置：（注意下图中配置的所在位置，不要乱了，否则可能无法启动数据库服务了）</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912161934612.png" class title="image-20210912161934612"><p><strong>开放远程连接</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> host<span class="operator">=</span><span class="string">&#x27;%&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h5 id="设置mysql服务开机自启动"><a href="#设置mysql服务开机自启动" class="headerlink" title="设置mysql服务开机自启动"></a>设置mysql服务开机自启动</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> mysqld.service</span><br></pre></td></tr></table></figure><h5 id="停止mysql服务开机自启动"><a href="#停止mysql服务开机自启动" class="headerlink" title="停止mysql服务开机自启动"></a>停止mysql服务开机自启动</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> mysqld.service</span><br></pre></td></tr></table></figure><p>关于用户授权</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">####创建用户并授权</span><br><span class="line">grant  all  on  *.*  to  &#x27;xsge&#x27;@&#x27;%&#x27;  identified  by  &#x27;SQLxsge1.&#x27;;　　　　#创建用户xsge，密码SQLxsge1.  授权所有权限（all），允许正在任意主机登录（%），任意库任意表（*.*）</span><br><span class="line">----------------------------------如需其他修改请看参考下面的SQL-----------------------------------</span><br><span class="line">####修改xsge主机访问权限范围(前提，该用户xsge已经存在)</span><br><span class="line">update  mysql.user  set  host=&#x27;localhost&#x27;  where  user=&#x27;xsge&#x27;;　　　#修改xsge账户访问范围：localhost只能在Linux系统本机访问</span><br><span class="line"></span><br><span class="line">####修改权限</span><br><span class="line">Grant select，update on test.*  to  &#x27;xsge&#x27;@&#x27;%&#x27;;　　　　#给xsge授权查询，更新，test库中所有表（test.*）</span><br></pre></td></tr></table></figure><p><strong>注：</strong>注意若是服务器，记得开放3306端口。</p><h3 id="MySQL主要配置文件"><a href="#MySQL主要配置文件" class="headerlink" title="MySQL主要配置文件"></a>MySQL主要配置文件</h3><p>1、二进制日志log-bin(主从复制)</p><p>2、错误日志log-error:默认是关闭的，记录严重的警告和错误信息，每次启动和关闭的详细信息等</p><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h4><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在存储引擎上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912185607685.png" class title="image-20210912185607685"><p><strong>连接层：</strong></p><p>一些客户端和连接服务，包含本地socket通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引用了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它据有的操作权限。</p><p><strong>服务端：</strong></p><p>第二层架构主要完成大多的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如果成、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化确定如查询表的顺序，是否利用索引等，最后生成相应的执行操作。</p><p><strong>引擎层：</strong></p><p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，可以根据业务需求进行选取。</p><p><strong>存储层：</strong></p><p>数据存储层，主要是将数据存储在运行于裸设备的文件系统上，并完成与存储引擎的交互。</p><h5 id="查看引擎："><a href="#查看引擎：" class="headerlink" title="查看引擎："></a>查看引擎：</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h5 id="Join的几种类型"><a href="#Join的几种类型" class="headerlink" title="Join的几种类型"></a>Join的几种类型</h5><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210912230026548.png" class title="image-20210912230026548"><p><strong>索引：</strong>索引是帮助MySQL高效获取数据的数据结构，即排好序的快速查找数据结构</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上</p><p>我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉树的）结构组织的索引。其中聚集索引、次要索引、覆盖索引、符合索引，前缀索引、唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引等</p><p><strong>索引的优势：</strong></p><ul><li>提高数据检索的效率，降低数据库的I/O成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li></ul><p><strong>索引的劣势：</strong></p><ul><li>索引在本质上也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的</li><li>索引大大提高了查询速度，但却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件每次更新添加了索引列的字段，会调整因为更新所带来的键值变化后的索引信息</li><li>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询</li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><p>1、单值索引：即一个索引只包含单个列，一个表可以有多个单列索引</p><p>2、唯一索引：索引列的值必须唯一，但允许有空值</p><p>3、复合索引：即一个索引包含多个列</p><h5 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h5><p>创建：<code>create [UNIQUE] index indexName on table（columnName(length)）</code></p><p><code>alter table add [unique] index [indexName]  on (columnName(length))</code></p><p>删除：<code>drop index [indexName] on table</code></p><p>查看：show index from table</p><h5 id="需要建立索引的情况："><a href="#需要建立索引的情况：" class="headerlink" title="需要建立索引的情况："></a>需要建立索引的情况：</h5><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>频繁更新的字段不适合创建索引</li><li>where条件里用不到的字段不创建索引</li><li>在高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><p><strong>不需要建立索引的情况：</strong></p><ul><li>表记录太少</li><li>经常增删改的表</li><li>如果某个数据列包含许多重复的内容，为它建立索引就没有必要</li></ul><h5 id="MySQL常见瓶颈："><a href="#MySQL常见瓶颈：" class="headerlink" title="MySQL常见瓶颈："></a>MySQL常见瓶颈：</h5><p>CPU:CPU在饱和的时候一般发生在数据装入内存或从磁盘读取数据的时候</p><p>I/O:磁盘I/O瓶颈发生在装入数据远大于内存容量的时候。</p><p>服务器硬件的性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态</p><h3 id="Explain：执行计划"><a href="#Explain：执行计划" class="headerlink" title="Explain：执行计划"></a>Explain：执行计划</h3><p>使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，可以通过Explain关键字分析你的查询语句或是表结构的性能瓶颈</p><p><strong>使用方法：</strong><code>Explain+SQL语句</code></p><h5 id="Explain能干什么："><a href="#Explain能干什么：" class="headerlink" title="Explain能干什么："></a>Explain能干什么：</h5><ul><li>查看表的读取顺序</li><li>查看数据读取操作的操作类型</li><li>查看哪些索引可以使用</li><li>查看哪些索引被实际使用</li><li>查看表之间的引用</li><li>查看每张表有多少行被优化器查询</li></ul><h5 id="执行计划中包含的信息"><a href="#执行计划中包含的信息" class="headerlink" title="执行计划中包含的信息"></a>执行计划中包含的信息</h5><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210913154201651.png" class title="image-20210913154201651"><h4 id="表字段的解释："><a href="#表字段的解释：" class="headerlink" title="表字段的解释："></a>表字段的解释：</h4><p><strong>id</strong>：select查询的序列号，包含一组数字，表示查询中执行select字句或者操作表的顺序</p><ul><li><p>id相同：执行顺序由上至下</p></li><li><p>id不同：如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p></li><li><p>id中有相同的也有不同的：id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</p><p>DERIVED=衍生</p></li></ul><p><strong>select_type</strong>：</p><ul><li>SIMPLE:简单select查询，查询中不包含子查询或者UNION</li><li>PRIMARY:查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY</li><li>SUBQUERY:在SQL语句中包含了子查询</li><li>DERIVED:在FROM列表中包含的子查询被标记为DERIVED(衍生)，MySQL会递归执行这些子查询，把结果放在临时表里</li><li>UNION：若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED</li><li>UNION RESULT:从UNION表获取结果的SELECT</li></ul><p><strong>type：</strong>访问类型排列，显示查询使用了何种类型</p><p><strong>从最好到最差依次是</strong>：<code>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</code></p><p>一般来说，得保证查询至少达到range级别，最好能达到ref</p><ul><li>system：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现</li><li>const表示通过索引一次就找到了，const用于比较primary key或unique索引。因为只匹配一行数据，所以很快，如将主键置于where列表中，MySQL就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&gt;、&lt;、in等的查询。这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index：index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是从索引中读取，而all是从硬盘中读的）</li><li>all：全表扫描找到匹配的行</li></ul><p><strong>possible_keys:</strong></p><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><p><strong>key:</strong></p><p>实际使用的索引。如果为NULL，则没有使用索引。<strong>查询中若使用覆盖索引，则该索引仅出现在key列表中</strong></p><p>覆盖索引：指查询的字段数量顺序都与所建的索引相同</p><p><strong>key_len:</strong></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</p><p><strong>ref:</strong></p><p>显示索引的哪一列被使用了，如果可能的话是一个常数。哪些列或常量被用于查找索引列上的值。</p><p><strong>rows:</strong></p><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数</p><p><strong>Extra:</strong></p><p>包含不适合在其它列中显示但十分重要的额外信息 </p><p>Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</p><p>Using temporary:使用了临时表保存中间结果，MySQL在对查询结果排序使用临时表。常见于排序order by和分组查询group by(尽量按照所建索引进行分组)</p><p>Using index:</p><p>表示相应的select操作中使用了覆盖索引，避免访问表的数据行，效率不错。</p><p>如果同时出现using where ,表明索引被用来执行索引键值的查找</p><p>如果没有同时出现using where,表明索引用来读取数据而非执行查找操作。</p><p>Using where:表明使用了where过滤</p><p>Using join buffer：使用了连接缓存</p><p>impossible where：where 字句的值总是false，不能用来获取任何元组</p><p>select tables optimized away：在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p><p>distinct:</p><p>优化distinct操作，在找到第一匹配的元组后即停止找同样值动作。1</p><h5 id="覆盖索引（索引覆盖）"><a href="#覆盖索引（索引覆盖）" class="headerlink" title="覆盖索引（索引覆盖）"></a>覆盖索引（索引覆盖）</h5><p>理解方式一：select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong></p><p><strong>注：</strong></p><p>如果要使用覆盖索引，一定要注意select列表中只取出需要的列，不可select *，因为如果将所有字段一起做索引会导致索引文件过大，查询性能下降。</p><h5 id="建立索引的关键点"><a href="#建立索引的关键点" class="headerlink" title="建立索引的关键点"></a>建立索引的关键点</h5><p>SQL语句中排序前有范围过滤语句的，可能会导致创建的索引失效。</p><p>由于左右连接的特性，作为“主表”的那个表的所有记录都会存在，因此需要将索引加在另一张表上。</p><p>尽可能减少join语句中的NestedLoop的循环总次数，“永远用小结果集驱动大结果集”</p><p><strong>全值匹配我最爱</strong>：</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210914170203644.png" class title="image-20210914170203644"><p>最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且<strong>不跳过索引中的列</strong></p><p>不在索引列上做任何操作（计算、函数、（自动或手动）类型转换），会导致索引失效而转向全表扫描</p><p>存储引擎不能使用索引中范围条件右边的列，即索引范围右边的索引都会失效</p><p>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *</p><p>mysql在使用!=或&lt;&gt;的时候无法使用索引会导致全表扫描</p><p>is null，is not null 也无法使用索引</p><p>like以通配符开头（’%abc….’）mysql索引失效会变成全表扫描的操作</p><p>字符串不加单引号索引失效</p><p>少用or,用它来连接时会索引失效</p><p>对于单值索引，尽量选择当前查询过滤性更好的索引。</p><p>在选择组合索引的时候，当前查询中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</p><p>在选择组合索引的适合，尽量选择可以能够包含当前查询中的where字句中更多字段的索引尽可能通过分析统计信息和调整查询的写法来达到选择合适索引的目的。</p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>1、观察SQL运行情况，至少跑一天，看看生产的慢SQL情况</p><p>2、开启慢查询日志，设置阙值，比如超过5秒钟就是慢SQL，并将它抓取出来</p><p>3、explain+慢SQL分析</p><p>4、show profile</p><p><strong>总结：</strong></p><ul><li>慢查询的开启并捕获</li><li>explain+慢SQL分析</li><li>show profile 查询SQL在MySQL服务器里面的执行细节和生命周期情况</li><li>SQL数据库服务器的参数调优</li><li>始终小表驱动大表</li></ul><h4 id="Order-By排序优化"><a href="#Order-By排序优化" class="headerlink" title="Order By排序优化"></a>Order By排序优化</h4><p>MySQL支持两种方式的排序，FileSort和Index，Index效率高。Index指MySQL扫描索引本身完成排序，FileSort方式效率较低。</p><h5 id="Order-By-满足两情况，会使用Index方式排序"><a href="#Order-By-满足两情况，会使用Index方式排序" class="headerlink" title="Order By 满足两情况，会使用Index方式排序"></a>Order By 满足两情况，会使用Index方式排序</h5><p>Order By语句使用索引最左前列</p><p>使用Where字句与Order By字句条件组合满足索引最左前列</p><p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p><h5 id="若不在索引列上，firesort有两种算法："><a href="#若不在索引列上，firesort有两种算法：" class="headerlink" title="若不在索引列上，firesort有两种算法："></a>若不在索引列上，firesort有两种算法：</h5><p>单路排序：一次磁盘扫描，但因为单路排序是将数据取出放到buffer钟进行排序，若数据量超过buffer的大小，那么就会造成多次磁盘扫描。</p><p>双路排序：两次磁盘扫描</p><p><strong>提高Order By的速度的方式：</strong></p><ul><li><p>当查询的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT|BLOB类型时，会用改进后的算法（单路排序），否则使用多路排序</p><p>两种排序算法的数据都可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些，所以要提高sort_buffer_size</p></li><li><p>尝试提高sort_buffer_size</p></li><li><p>尝试提高max_length_for_sort_data</p><p>提高这个参数，会增加用改进算法的概率。但是如果设得太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率</p></li></ul><h4 id="Group-By关键字优化"><a href="#Group-By关键字优化" class="headerlink" title="Group By关键字优化"></a>Group By关键字优化</h4><p>与Order By相似，Group By实质是先排序后进行分组，遵照索引建的最佳左前缀</p><p>where高于having，能写在where限定的条件就不要去having中限定了。</p><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志。</p><p>慢查询日志默认是未开启的，若不是调优需要，尽量不要开启慢查询日志，因为它或多或少会对查询效率产生影响</p><p><strong>查看慢查询日志开启状态：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>开启慢查询</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只针对当前数据库有效，MySQL重启后会失效</span></span><br><span class="line"><span class="built_in">set</span> global show_query_log=1;</span><br></pre></td></tr></table></figure><p>若需要永久生效，则需要修改配置文件my.cnf</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在[mysqld]下面添加以下内容</span></span><br><span class="line">show_query_log=1;</span><br><span class="line">slow_query_log_file=/var/lib/mysql/laity-slow.log;</span><br></pre></td></tr></table></figure><p>查看慢查询日志的阈值</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看</span></span><br><span class="line">show variables like <span class="string">&#x27;%long_query_time%&#x27;</span>;</span><br><span class="line"><span class="comment">#修改值:修改的值需要重新开启一个会话或使用</span></span><br><span class="line"><span class="comment">#show global variables like &#x27;%long_query_time%&#x27;;</span></span><br><span class="line"><span class="comment">#才能查看到</span></span><br><span class="line"><span class="built_in">set</span> global long_query_time=3;</span><br><span class="line"><span class="comment">#查询当前有多少条慢SQL</span></span><br><span class="line">show global status like <span class="string">&#x27;%Slow_queries&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个阈值可以用命令修改，也可以修改配置文件（默认为10s）。且只有<strong>运行时间大于阈值的SQL</strong>才能被记录下来</p><h5 id="使用mysqldumpslow查看日志"><a href="#使用mysqldumpslow查看日志" class="headerlink" title="使用mysqldumpslow查看日志"></a>使用mysqldumpslow查看日志</h5><p>mysqldumpslow  参数</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210915235556032.png" class title="image-20210915235556032"><p>实例：</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210915235638963.png" class title="image-20210915235638963"><h4 id="批量插入数据库脚本"><a href="#批量插入数据库脚本" class="headerlink" title="批量插入数据库脚本"></a>批量插入数据库脚本</h4><h5 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h5><p>创建函数可能会报错：the function has none of deterministic</p><p>由于开启过慢查询日志，我们开启了bin-log,我们就必须为我们的function指定一个参数。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看参数</span></span><br><span class="line">show variables like <span class="string">&#x27;log_bin_trust_function_creators&#x27;</span></span><br><span class="line"><span class="comment">#为参数赋值</span></span><br><span class="line"><span class="built_in">set</span> global log_bin_trust_function_creators=1;</span><br></pre></td></tr></table></figure><p>上述方法，若mysql服务重启，上述参数会失效，若要永久生效需要修改配置文件my.cnf</p><p>在[mysqld]下添加<code>log_bin_trust_function_creators=1;</code></p><p>定义函数，生成随机字符串和随机数字</p><p>生成随机字符串</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_string(n <span class="type">int</span>) <span class="keyword">returns</span> <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">DECLARE</span> chars_str <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> return_str <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">while i <span class="operator">&lt;</span> n do</span><br><span class="line"><span class="keyword">set</span> return_str<span class="operator">=</span>concat(return_str,<span class="built_in">substring</span>(chars_str,<span class="built_in">FLOOR</span>(<span class="number">1</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">26</span>),<span class="number">1</span>));</span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> return_str;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure><p>生成随机数字</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> rand_num <span class="keyword">returns</span> <span class="type">int</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">DECLARE</span> res <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> res<span class="operator">=</span><span class="built_in">FLOOR</span>(<span class="number">100</span><span class="operator">+</span>RAND()<span class="operator">*</span><span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure><p>向emp表中插入一千万条数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure insert_emp(<span class="keyword">in</span> start int(10),<span class="keyword">in</span> max_num int(10))</span><br><span class="line">begin</span><br><span class="line">DECLARE i int DEFAULT 0;</span><br><span class="line"><span class="comment">#关闭自动提交</span></span><br><span class="line"><span class="built_in">set</span> autocommit=0;</span><br><span class="line">repeat</span><br><span class="line"><span class="built_in">set</span> i=i+1;</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(start+i,rand_string(6),<span class="string">&#x27;SALESMAN&#x27;</span>,0001,curdate(),2000,400,rand_num());</span><br><span class="line">until i=max_num</span><br><span class="line">end repeat;</span><br><span class="line">commit;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure><p>向dept表中插入数据</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure insert_dept(<span class="keyword">in</span> start int(10),<span class="keyword">in</span> max_num int(10))</span><br><span class="line">begin</span><br><span class="line">DECLARE i int DEFAULT 0;</span><br><span class="line"><span class="comment">#关闭自动提交</span></span><br><span class="line"><span class="built_in">set</span> autocommit=0;</span><br><span class="line">repeat</span><br><span class="line"><span class="built_in">set</span> i=i+1;</span><br><span class="line">insert into dept(deptno,dname,loc) values(start+i,rand_string(10),rand_string(8));</span><br><span class="line">until i=max_num</span><br><span class="line">end repeat;</span><br><span class="line">commit;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure><h4 id="Show-profile"><a href="#Show-profile" class="headerlink" title="Show profile"></a>Show profile</h4><p>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。</p><p> 默认情况下处于关闭状态，使用前需要开启</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看是否开启</span><br><span class="line">show variables like &#x27;profiling&#x27;;</span><br><span class="line">#开启</span><br><span class="line">set profiling=on;</span><br><span class="line"></span><br><span class="line">#查看sql语句的具体运行情况</span><br><span class="line">show profile cpu,block io for query 哪条sql </span><br></pre></td></tr></table></figure><p>除开cpu,block id之外，还能查看的其它参数<img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210916124104260.png" class title="image-20210916124104260"></p><p>若出现以下过程，SQL需要进行进一步优化：</p><ul><li>converting HEAP to MyISAM：查询结果太大，内存都不够用了往磁盘上搬</li><li>creating tmp table：创建临时表，将数据拷贝到临时表，用完再删除，大大影响效率</li><li>Copying to tmp table on disk：把内存中临时表复制到磁盘，危险</li><li>locked</li></ul><h4 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h4><p>注：永远不要在生产环境开启这个功能。</p><p>启用方式：</p><p>配置文件方式：</p><p>在mysql的my.cnf中设置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启</span></span><br><span class="line">general_log=1</span><br><span class="line"><span class="comment">#记录日志文件的路径</span></span><br><span class="line">general_log_file=/path/xxx</span><br><span class="line"><span class="comment">#输出格式</span></span><br><span class="line">log_output=FILE</span><br></pre></td></tr></table></figure><p>命令方式启用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> general_log=1</span><br><span class="line"><span class="comment">#编写的sql语句会记录到mysql库里的general_log表中</span></span><br><span class="line"><span class="built_in">set</span> global log_output=<span class="string">&#x27;TABLE&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><p><strong>从对数据操作的粒度分：</strong></p><ul><li>表锁（偏向：MyISAM引擎）</li><li>行锁（InnoDB）</li></ul><p><strong>从对数据操作的类型分：</strong></p><ul><li><p>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行，而不会互相干扰</p><p>每一个Session对表加锁后，只能读被锁的表，不能读其它表，更不能修改被加锁的表</p></li><li><p>写锁（排它锁）：当前写操作没有完成前，它会阻断其它写锁和读锁</p></li></ul><p>简而言之：读锁会阻塞写，但是不会阻塞读。写锁会把读和写都阻塞</p><p>查看被锁过的表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">show open tables;</span><br></pre></td></tr></table></figure><p>手动增加表锁</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock table 表名 read|write，表名1 read|write ...</span><br></pre></td></tr></table></figure><p>MyISAM表</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210918124347690.png" class title="image-20210918124347690"><h4 id="分析表锁定"><a href="#分析表锁定" class="headerlink" title="分析表锁定"></a>分析表锁定</h4><p>可以通过检查table_locks_waited和table_locks_immediate状态变量来分析系统上的表锁定。</p><p>SQL：show status like ‘table%’’</p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210918145807087.png" class title="image-20210918145807087"><p>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：</p><p>Table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数</p><p>Table_locks_waited：出现标记锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次锁值加一），此值搞说明存在着较严重的表级锁争用情况。</p><p><strong>MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</strong></p><h4 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h4><p>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁粒度最小，发生锁冲突的概率最低，并发度也最高。</p><p>InnoDB与MyISAM的最大不同：</p><ul><li>支持事务</li><li>采用了行级锁</li></ul><p>MySQL的默认事务级别为 <strong>Repeatable read</strong></p><p>查看当前数据库的事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure><p>无索引或索引失效会导致行锁升级为表锁，会大大影响性能。</p><h5 id="间隙锁："><a href="#间隙锁：" class="headerlink" title="间隙锁："></a>间隙锁：</h5><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值再条件范围内但并不存在的记录，叫做’间隙(GAP)‘，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-key锁）。</p><p>危害：</p><p>在查询过程中通过范围查找的话，他会锁定整个范围内的所有索引键值，即使这个键值并不存在，当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下，这可能会对性能造成很大的伤害。</p><p><strong>面试题：如何锁定一行</strong></p><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210918160357131.png" class title="image-20210918160357131"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> xxx <span class="keyword">from</span> xxx <span class="keyword">for</span> update</span><br></pre></td></tr></table></figure><h4 id="行锁分析"><a href="#行锁分析" class="headerlink" title="行锁分析"></a>行锁分析</h4><p>命令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210918160843936.png" class title="image-20210918160843936"><p>Innodb_row_lock_current_waits：当前正在正在等待锁定的数量</p><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度</p><p>Innodb_row_lock_time_avg：每次等待所花平均时间</p><p>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花的时间</p><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数</p><p><strong>优化建议：</strong></p><ul><li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li><li>合理设计索引，尽量缩小锁的范围</li><li>尽可能减少检索条件，避免间隙锁</li><li>尽量控制事务大小，减少锁定资源量和时间长度</li><li>尽可能低级别事务隔离</li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>MySQL复制过程分为三步：</p><ul><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events</li><li>slave将master的binary log events拷贝到它的中继日志（relay log）</li><li>slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL的复制是异步且串行化的</li></ul><p>复制的基本原则：</p><ul><li>每个slave只有一个master</li><li>每个slave只能有一个唯一的服务器ID</li><li>每个master可以有多个slave</li></ul><h4 id="一主一从常见配置"><a href="#一主一从常见配置" class="headerlink" title="一主一从常见配置"></a>一主一从常见配置</h4><p>mysql版本一致且后台以服务运行</p><p>组从都配置在[mysqld]节点下，都是小写</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210919233248908.png" class title="image-20210919233248908"><p>B树（m叉树）是一种数据结构，具有以下特点：</p><ul><li>根节点至少有两个子节点</li><li>每个中间节点都包含k-1个元素和k个子节点，其中m/2&lt;=k&lt;=m</li><li>每一个叶子节点都包含k-1个元素，其中m/2&lt;=k&lt;=m</li><li>所有叶子节点都位于同一层</li><li>每个节点中关键字从小到大排列，并且当该节点的孩子是非叶子节点时，该k-1个元素正好是k个子节点包含的元素的值域的分划</li></ul><p><strong>B树在保留二叉树预划分范围从而提升查询效率的思想的前提，做了以下优化：</strong></p><p>二叉树变成m叉树，这个m的大小可以根据单个页的大小做对应调整，从而使得一个页可以存储更多的数据，从磁盘上读取一页可以读到的数据就更多，随机I/O次数变少，大大提升效率。但是只能通过中序遍历查询全表，当进行范围查询时，可能会需要中序回溯。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><img src="/2021/09/11/MySQL%E9%AB%98%E7%BA%A7/image-20210919234754977.png" class title="image-20210919234754977"><p>B+树在B树的基础上加了以下优化：</p><ul><li>叶子节点增加了指针进行连接，即叶子节点间形成了链表</li><li>非叶子节点只存关键字key，不再存储数据，只在叶子节点存储数据</li></ul><p>说明：叶子之间用双向链表连接比单向链表连接是通过链表的任一节点都可以通过往前或往后遍历找到链表中指定的其它节点</p><p>好处：</p><ul><li>范围查询时可以通过访问叶子节点的链表进行有序遍历，而不再需要中序回溯访问节点</li><li>非叶子节点只存储关键字key，一方面这种结构相当于划分出了更多的范围，加快了查询速度，另一方面相当于单个索引值大小变小，同一个页可以存储更多的关键字，读取单个页就可以得到更多的关键字，可检索的范围变大了，相对读写次数就降低了</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2021/09/10/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/09/10/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统一返回结果集</title>
      <link href="/2021/08/23/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86/"/>
      <url>/2021/08/23/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="SSM的统一返回结果集（供以后做参考）"><a href="#SSM的统一返回结果集（供以后做参考）" class="headerlink" title="SSM的统一返回结果集（供以后做参考）"></a>SSM的统一返回结果集（供以后做参考）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultEntity</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUCCESS=<span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ERROR=<span class="string">&quot;error&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultEntity</span><span class="params">(String result, String message, String code, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;Type&gt;:声明一个泛型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求成功且没有返回数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Type&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResultEntity&lt;Type&gt; <span class="title">successWithOutData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultEntity&lt;Type&gt;(SUCCESS,<span class="keyword">null</span>,<span class="string">&quot;200&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理成功，且有返回数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Type&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResultEntity&lt;Type&gt; <span class="title">successWithData</span><span class="params">(Type data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultEntity&lt;Type&gt;(SUCCESS,<span class="keyword">null</span>,<span class="string">&quot;200&quot;</span>,data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求处理失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;Type&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;Type&gt; <span class="function">ResultEntity&lt;Type&gt; <span class="title">failure</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultEntity&lt;Type&gt;(ERROR,message,<span class="string">&quot;500&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(String result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringBoot项目学到的统一返回结果集"><a href="#SpringBoot项目学到的统一返回结果集" class="headerlink" title="SpringBoot项目学到的统一返回结果集"></a>SpringBoot项目学到的统一返回结果集</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RebackInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;返回状态码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;返回消息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;返回数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; data=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">RebackInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RebackInfo <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RebackInfo info = <span class="keyword">new</span> RebackInfo();</span><br><span class="line">        info.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        info.setCode(ResultCode.SUCCESS);</span><br><span class="line">        info.setMessage(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RebackInfo <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RebackInfo info=<span class="keyword">new</span> RebackInfo();</span><br><span class="line">        info.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        info.setCode(ResultCode.ERROR);</span><br><span class="line">        info.setMessage(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">success</span><span class="params">(Boolean success)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSuccess(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">code</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">message</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">data</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.put(key,value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RebackInfo <span class="title">data</span><span class="params">(Map&lt;String,Object&gt; data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(data);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 规范返回结果 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5加密</title>
      <link href="/2021/08/23/md5%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/08/23/md5%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="md5加密代码："><a href="#md5加密代码：" class="headerlink" title="md5加密代码："></a>md5加密代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String source)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 对传入参数进行校验</span></span><br><span class="line">        <span class="keyword">if</span>( source ==<span class="keyword">null</span> || source.length() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="comment">//字符串为空抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(CrowdConstant.MESSAGE_ILLEGAL_PARAM);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取MessageDigest对象</span></span><br><span class="line">            String algorithm = <span class="string">&quot;md5&quot;</span>;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(algorithm);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取明文对应的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] input = source.getBytes();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] output = messageDigest.digest(input);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建BigInteger对象</span></span><br><span class="line">            <span class="keyword">int</span> signum=<span class="number">1</span>;</span><br><span class="line">            BigInteger bigInteger = <span class="keyword">new</span> BigInteger(signum, output);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 按照16进制将bigInteger的值传唤为字符串</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定进制</span></span><br><span class="line">            <span class="keyword">int</span> radix=<span class="number">16</span>;</span><br><span class="line">            String encoded = bigInteger.toString(radix);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> encoded;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单配置PageHelper分页插件</title>
      <link href="/2021/08/22/%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AEPageHelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
      <url>/2021/08/22/%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AEPageHelper%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="PageHelper是Mybatis的一款分页插件"><a href="#PageHelper是Mybatis的一款分页插件" class="headerlink" title="PageHelper是Mybatis的一款分页插件"></a>PageHelper是Mybatis的一款分页插件</h4><h3 id="使用方法（maven）"><a href="#使用方法（maven）" class="headerlink" title="使用方法（maven）"></a>使用方法（maven）</h3><h4 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、配置拦截器插件"><a href="#2、配置拦截器插件" class="headerlink" title="2、配置拦截器插件"></a>2、配置拦截器插件</h4><p>注意：新版的PageHelper的拦截器是<code>com.github.pagehelper.PageInterceptor</code>,<code>com.github.pagehelper.PageHelper</code> 现在是一个特殊的 <code>dialect</code> 实现类，是分页插件的默认实现类，提供了和以前相同的用法。</p><h5 id="1-在MyBatis的mybatis-config-xml中配置拦截器插件"><a href="#1-在MyBatis的mybatis-config-xml中配置拦截器插件" class="headerlink" title="(1) 在MyBatis的mybatis-config.xml中配置拦截器插件"></a>(1) 在MyBatis的mybatis-config.xml中配置拦截器插件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下:</span></span><br><span class="line"><span class="comment">    properties?, settings?,</span></span><br><span class="line"><span class="comment">    typeAliases?, typeHandlers?,</span></span><br><span class="line"><span class="comment">    objectFactory?,objectWrapperFactory?,</span></span><br><span class="line"><span class="comment">    plugins?,</span></span><br><span class="line"><span class="comment">    environments?, databaseIdProvider?, mappers?</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-在Spring配置文件（spring-dao-xml）中配置拦截器插件"><a href="#2-在Spring配置文件（spring-dao-xml）中配置拦截器插件" class="headerlink" title="(2) 在Spring配置文件（spring-dao.xml）中配置拦截器插件"></a>(2) 在Spring配置文件（spring-dao.xml）中配置拦截器插件</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--绑定mybatis的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:mybatis/mapper/*Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置pageHelper插件,新版拦截器是 com.github.pagehelper.PageInterceptor--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置页码的合理化修正,在1~总页数之间修正页码--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;reasonable&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、分页插件参数"><a href="#3、分页插件参数" class="headerlink" title="3、分页插件参数"></a>3、分页插件参数</h4><p><a href="https://pagehelper.github.io/docs/howtouse/">如何使用分页插件 (pagehelper.github.io)</a></p><p><strong>注意：</strong>上述的两种配置分页插件的方法任选一种配置即可，不能重复配置</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageInfo&lt;Admin&gt; <span class="title">getPageInfo</span><span class="params">(String keyword, <span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用PageHelper的静态方法开启分页功能</span></span><br><span class="line">    <span class="comment">// 充分体现了PageHelper的&quot;非侵入式&quot;设计：原本要做的查询不必有任何修改</span></span><br><span class="line">    PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    List&lt;Admin&gt; adminList = adminMapper.selectAdminWithLimit(keyword);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装到PageInfo对象中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageInfo&lt;&gt;(adminList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// defaultValue设置参数初始值</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/get/page.html&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPageInfo</span><span class="params">(<span class="meta">@RequestParam(value = &quot;keyword&quot;, defaultValue = &quot;&quot;)</span> String keyword,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(value = &quot;pageNum&quot;, defaultValue = &quot;1&quot;)</span> <span class="keyword">int</span> pageNum,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="meta">@RequestParam(value = &quot;pageSize&quot;, defaultValue = &quot;5&quot;)</span> <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ModelMap modelMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PageInfo&lt;Admin&gt; pageInfo = adminService.getPageInfo(keyword, pageNum, pageSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pageInfo存入模型中</span></span><br><span class="line">    modelMap.addAttribute(CrowdConstant.ATTR_NAME_PAGE_INFO, pageInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin-page&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端生成页码导航器"><a href="#前端生成页码导航器" class="headerlink" title="前端生成页码导航器"></a>前端生成页码导航器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/pagination.css&quot;</span>&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;jquery/jquery.pagination.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        initPagination();</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">initPagination</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 获取总记录数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> totalRecord=$&#123;requestScope.pageInfo.total&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 声明一个JSON对象存储Pagination要设置的属性</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> properties=&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// 边缘页数，即显示在最左边的页码的数量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">num_edge_entries</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// 主体页，即显示在最右边的页码的数量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">num_display_entries</span>: <span class="number">4</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// 指定用户点击&quot;翻页&quot;按钮时跳转页面的回调函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">callback</span>: pageSelectCallback,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// 每页要显示的数据的数量</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">items_per_page</span>: $&#123;requestScope.pageInfo.pageSize&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="comment">// current_page：从0开始，而pageNum从1开始，所以需要减一</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">current_page</span>: $&#123;requestScope.pageInfo.pageNum-<span class="number">1</span>&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">prev_text</span>: <span class="string">&quot;上一页&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">next_text</span>: <span class="string">&quot;下一页&quot;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 生成页码导航器</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        $(<span class="string">&quot;#Pagination&quot;</span>).pagination(totalRecord,properties);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 回调函数的含义：声明出来以后不是自己调用，而是交给系统或框架调用</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 用户点击页码时调用这个函数实现页面跳转</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// pageIndex是Pagination传给我们的那个“从0开始”的那个页码</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">pageSelectCallback</span>(<span class="params">pageIndex,jQuery</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 根据pageIndex计算得到pageNum</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">var</span> pageNum=pageIndex+<span class="number">1</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 跳转页面</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">window</span>.location.href=<span class="string">&quot;admin/get/page.html?pageNum=&quot;</span>+pageNum+<span class="string">&quot;&amp;keyword=$&#123;param.keyword&#125;&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 由于每一个页码按钮都是超链接，所以在这个函数最后取消超链接的默认行为</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2021/08/13/SpringMVC/"/>
      <url>/2021/08/13/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="MVC简介："><a href="#MVC简介：" class="headerlink" title="MVC简介："></a>MVC简介：</h2><ul><li>MVC是模型(Model)、视图(View)、控制器(Controller)的件写，是一种软件设计规范</li><li>它能讲业务逻辑、数据、显示分离的方法来组织代码</li><li>MVC只要作用是<strong>降低了视图与业务逻辑间的双向耦合</strong></li><li>MVC不是一种设计模式，<strong>MVC是一种架构模式</strong>，当然不同的MVC存在差异</li></ul><p>**Model(模型)**：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object(数据Dao)和服务层（行为Service)。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务</p><p>**View(视图)**：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西</p><p>**Controller(控制器)**：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作</p><h2 id="回顾servlet"><a href="#回顾servlet" class="headerlink" title="回顾servlet"></a>回顾servlet</h2><ol><li><p>创建一个maven项目</p></li><li><p>导入相关依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建一个web项目</p><img src="/2021/08/13/SpringMVC/image-20210405144947118.png" class title="image-20210405144947118"></li></ol><h3 id="SpringMVC的特点"><a href="#SpringMVC的特点" class="headerlink" title="SpringMVC的特点"></a>SpringMVC的特点</h3><ul><li>轻量级，简单易学</li><li>高效，基于请求响应的MVC框架</li><li>与Spring兼容性好，无缝结合</li><li>约定优于配置</li><li>功能强大：RESTful、数据验证、格式化、本地化、主题</li><li>简洁灵活</li></ul><h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3><img src="/2021/08/13/SpringMVC/image-20210405170346590.png" class title="image-20210405170346590"><ul><li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求</p><ul><li><p>我们假设请求的url为：<a href="http://localhost:8080/SpringMVC/hello">http://localhost:8080/SpringMVC/hello</a></p></li><li><p>url分为三部分</p><p>服务器域名：<a href="http://localhost:8080/">http://localhost:8080</a></p><p>部署在服务器上的web站点：SpringMVC</p><p>控制器：hello</p></li><li><p>如上url表示：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器</p></li></ul></li><li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler</p></li><li><p>HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为:hello</p></li><li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等</p></li><li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler</p></li><li><p>Handler让具体的Controller执行</p></li><li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView.</p></li><li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet</p></li><li><p>DispatcherServlet调用视图解析器（ViewResolver）来解析HandlerAdapter传递的逻辑视图名</p></li><li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet</p></li><li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图</p></li><li><p>最终将视图呈现给用户</p></li></ul><h3 id="第一个SpringMVC程序"><a href="#第一个SpringMVC程序" class="headerlink" title="第一个SpringMVC程序"></a>第一个SpringMVC程序</h3><ol><li><p>创建一个maven项目</p></li><li><p>导入相关的依赖jar包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>确定依赖导入</p><img src="/2021/08/13/SpringMVC/image-20210405173403353.png" class title="image-20210405173403353"><img src="/2021/08/13/SpringMVC/image-20210405173431380.png" class title="image-20210405173431380"></li><li><p>编写web.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置DispatcherServlet:SpringMVC的核心;请求分发器;前端控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--DispatcherServlet要绑定的Spring的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动级别:1,与服务器一同启动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在SpringMVC中，/ /*</span></span><br><span class="line"><span class="comment">/:只匹配所有的请求，不会去匹配jsp页面</span></span><br><span class="line"><span class="comment">/*:匹配所有的请求，会匹配jsp页面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--处理器映射器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--真正在开发中不用配，可以自动配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--处理器适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视图解析器:模板引擎Thymeleaf Freemarker....--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--前缀 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--BeanNameUrlHandlerMapping:根据bean的名称来适配--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.controller.HelloController&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">    String result=<span class="string">&quot;HelloSpringMVC&quot;</span>;</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;msg&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图跳转</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用注解方式编写SpringMVC程序"><a href="#使用注解方式编写SpringMVC程序" class="headerlink" title="使用注解方式编写SpringMVC程序"></a>使用注解方式编写SpringMVC程序</h3><ol><li><p>创建maven对象，导入相关依赖，jar包</p></li><li><p>确定依赖导入成功，创建web工程</p></li><li><p>编写web.xml文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置DispatcherServlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-annotaion.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置启动级别：1,和服务器同时启动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Spring配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启自动扫描包，让指定包下的注解生效，由IOC容器统一管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--让SpringMVC不处理静态资源 .css  .js   .html  .mp3 .mp4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">h</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//真实访问地址：项目名/HelloController/hello</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">        <span class="comment">//封装数据</span></span><br><span class="line">        <span class="comment">//向模型中添加属性msg与值,可以在JSP页面中取出并渲染</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Hello SpringMVC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// web-inf/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;<span class="comment">//会被视图解析器处理,视图名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li><p>只要实现了Controller接口的类，说明就是一个控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>不使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>通过以下方法也能进行跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndViewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    System.out.println(session.getId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;control&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过SpringMVC来实现转发和重定向-无需视图解析器"><a href="#通过SpringMVC来实现转发和重定向-无需视图解析器" class="headerlink" title="通过SpringMVC来实现转发和重定向-无需视图解析器"></a>通过SpringMVC来实现转发和重定向-无需视图解析器</h3><p>测试前，需要将视图解析器注释掉</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelAndViewTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;转发&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/control.jsp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发:会使用到视图解析器</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/forward1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;转发&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/WEB-INF/jsp/control.jsp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/resend&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//redirect:重定向</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;重定向&quot;</span>);</span><br><span class="line">        <span class="comment">//redirect不会使用视图解析器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:index.jsp&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringMVC数据处理"><a href="#SpringMVC数据处理" class="headerlink" title="SpringMVC数据处理"></a>SpringMVC数据处理</h3><h4 id="处理提交的数据"><a href="#处理提交的数据" class="headerlink" title="处理提交的数据"></a>处理提交的数据</h4><ol><li><p><strong>提交的域名陈和处理方法的参数名一致</strong></p><p>提交数据：<a href="http://localhost:8080/%E9%A1%B9%E7%9B%AE%E5%90%8D/user/t1?name=">http://localhost:8080/项目名/user/t1?name=</a>???</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t1&quot;)</span></span><br><span class="line"><span class="comment">//只要是要从前端接收的参数，无论参数名一不一样，都建议把@RequestParam写上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span>String name, Model model)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收前端参数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;接受到前端的参数为：&quot;</span>+name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将返回的结果传递给前端</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图跳转</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;control&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收到的是一个对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前端传递的是一个对象：age,name address</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、接收前端用户传递的参数，判断参数的名称，假设名称自接在方法上，可以直接使用</span></span><br><span class="line"><span class="comment">2、假设传递的是一个对象User,匹配User对象中的字段名：如果名字一致则ok,否则匹配不到</span></span><br><span class="line"><span class="comment">3、前端传递的参数需要与对象中的字段名一致，否则该字段为null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/t2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;control&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="将数据展示到前端页面上的方式"><a href="#将数据展示到前端页面上的方式" class="headerlink" title="将数据展示到前端页面上的方式"></a>将数据展示到前端页面上的方式</h5><ul><li><p>Model:精简版（大部分使用Model）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/resend&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">//redirect:重定向</span></span><br><span class="line">      model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;重定向&quot;</span>);</span><br><span class="line">      <span class="comment">//redirect不会使用视图解析器</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;redirect:index.jsp&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>ModelMap：继承了LinkedHashMap,所以他拥有LinkedHashMap的全部功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/t3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(User user, ModelMap map)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        map.addAttribute(<span class="string">&quot;msg&quot;</span>,map);</span><br><span class="line">        </span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;control&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>ModelAndView:可以在存储数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Controller详解&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mv.setViewName(<span class="string">&quot;control&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="解决乱码问题："><a href="#解决乱码问题：" class="headerlink" title="解决乱码问题："></a>解决乱码问题：</h3><p>配置SpringMVC配置过滤器</p><p>自定义的Filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml中配置过滤器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.mjy.filter.EncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注：</strong>/:只匹配所有的请求，不会去匹配jsp页面<br>/*:匹配所有的请求，会匹配jsp页面</p><p>SpringMVC自带的过滤器（但不知道为什么，我的没有生效，反倒是自己写的生效了）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encode1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encode1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：有些极端情况下，这个过滤器对get的支持不好</p><p>处理方法：</p><ol><li><p>修改tomcat配置文件：设置编码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义filter</p></li><li><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--JSON乱码问题配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li>JSON(JavaScript Object Notation,JS对象标记)，是一种轻量级的数据交换格式，目前使用广泛</li><li>采用完全独立于编程语言的文本格式来存储和表示数据</li><li>简洁和清晰的层次结构使得JSON成为理想的数据交换语言</li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率</li></ul><h3 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h3><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--servlet-api导入高版本的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/download&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">downloads</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        要下载的图片地址</span></span><br><span class="line">        String realPath = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        String fileName=<span class="string">&quot;带眼镜的女生.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置response响应头</span></span><br><span class="line">        <span class="comment">// 设置页面不缓存，清空buffer</span></span><br><span class="line">        response.reset();</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>);<span class="comment">//二进制传输数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置响应头</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;fileName=&quot;</span>+ URLEncoder.encode(fileName,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        File file=<span class="keyword">new</span> File(realPath,fileName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取文件-输入流</span></span><br><span class="line">        InputStream is=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="comment">//写出文件的输出流</span></span><br><span class="line">        OutputStream output = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len=is.read(buff))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            output.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            output.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output.close();</span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/upload&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习</title>
      <link href="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h2><ul><li>Spring是轻量级的开源的JavaEE框架</li><li>Spring可以解决企业应用开发的复杂性</li><li>Spring有两个核心部分：IOC和AOP<ol><li>IOC:控制反转，把创建对象过程交给Spring进行管理</li><li>AOP：面向切面，不修改源代码进行功能增强</li></ol></li><li>Spring特点<ol><li>方便解耦，简化开发</li><li>AOP编程支持</li><li>方便程序测试</li><li>方便和其它框架进行整合</li><li>方便进行事务操作</li><li>降低API开发难度</li></ol></li></ul><p><strong>Spring下载地址：</strong><a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p><p><strong>源码地址</strong>：<a href="https://github.com/spring-projects/spring-framework">GitHub - spring-projects/spring-framework: Spring Framework</a></p><p><strong>导入依赖：</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Spring7大组件:</strong></p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/1010726-20190908042152777-1895820426.png" class title="img"><h3 id="IOC理论推导"><a href="#IOC理论推导" class="headerlink" title="IOC理论推导"></a>IOC理论推导</h3><p><strong>之前(每多增加一个需求需要修改底层代码，程序主动创建对象，创建对象的控制权在程序员手中)：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao=<span class="keyword">new</span> UserDaoImpl();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用set方法对属性进行动态赋set方法对属性进行动态赋值</strong></p><p>程序不再具有主动性，而是变成了被动的接受对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用set方法对属性进行动态赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userDao=userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userDao.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="IOC的概念和原理"><a href="#IOC的概念和原理" class="headerlink" title="IOC的概念和原理"></a>IOC的概念和原理</h3><ol><li><p>什么是IOC</p><ul><li>控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理</li><li>使用IOC的目的：降低耦合度</li></ul></li><li><p>IOC底层原理</p><ul><li><p>xml解析、工厂模式、反射</p></li><li><p>IOC过程</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210328175720678.png" alt="image-20210328175720678"></p></li></ul></li><li><p>IOC：接口</p><ul><li><p>IOC思想基于IOC容器完成，IOC容器底层就是对象工厂</p></li><li><p>Spring提供IOC容器事项的两种方式：两个接口</p><ol><li><p>BeanFactory:IOC容器基本实现方式，是Spring内部的使用接口，不提供给开发人员进行使用</p><p>区别：<strong>BeanFactory加载配置文件时不会创建对象，在获取对象（使用）才会去创建对象</strong></p></li><li><p>ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p><p><strong>ApplocationContext:加载配置文件时就会把在配置文件的对象进行创建</strong></p></li><li><p>ApplicationContext接口的实现类</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210328181936073.png" alt="image-20210328181936073"></p></li></ol></li></ul></li></ol><h3 id="IOC操作Bean管理"><a href="#IOC操作Bean管理" class="headerlink" title="IOC操作Bean管理"></a>IOC操作Bean管理</h3><p><strong>什么是Bean管理</strong></p><ol><li><p>Bean管理指的是两个操作</p><p>Spring创建对象</p><p>Spring注入属性</p></li></ol><p><strong>Bean管理操作有两种方式</strong></p><ol><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ol><h3 id="基于xml方式创建对象"><a href="#基于xml方式创建对象" class="headerlink" title="基于xml方式创建对象"></a>基于xml方式创建对象</h3><ol><li><h4 id="基于xml方式创建对象-1"><a href="#基于xml方式创建对象-1" class="headerlink" title="基于xml方式创建对象"></a>基于xml方式创建对象</h4></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置User对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建</p><p>bean标签中有很多属性，常用的属性</p><ol><li>id属性：唯一的标识</li><li>class属性：创建对象所属类的全路径（包类路径）</li><li>name属性：作用与id属性相同。区别：name可以使用特殊符号，id不能使用特殊符号</li></ol><p>创建对象的时候，默认执行无参构造器</p><h4 id="2-基于xml方式注入属性"><a href="#2-基于xml方式注入属性" class="headerlink" title="2.基于xml方式注入属性"></a>2.基于xml方式注入属性</h4><ul><li><p>DI:依赖注入，就是注入属性—-DI是IOC的一种具体的实现，</p><ol><li><p>使用set方法进行注入</p><ol><li><p>创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建set方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件配置对象创建，配置属性注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--set方法注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property标签完成属性注入</span></span><br><span class="line"><span class="comment">        name:类里面属性名称</span></span><br><span class="line"><span class="comment">        value：向属性注入的值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;老人与海&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;海明威&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>有参构造器注入</p><ol><li><p>创建有参构造器的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Orders</span><span class="params">(String oname, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> oname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--有参构造注入属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--报错是因为无无参构造器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Orders&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;电脑&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--不建议使用：通过类型创建--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;莫枫舞&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--下标赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.entity.User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;莫语诸&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--起别名，有别名的对象，也可以通过别名来从Spring容器中取出对象--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;animal&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id:bean的唯一标识符，也就是相当于我们学的对象名</span></span><br><span class="line"><span class="comment">  class:bean对象所对应的全限定名：报名+类型</span></span><br><span class="line"><span class="comment">    name：也是别名，而且name可以同时取多个别名</span></span><br><span class="line"><span class="comment">    scope:可以设置单例，还是每次创建不同的东西</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.entity.User&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user2,user3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;夏雨&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        </span><br><span class="line">      </span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ul><ol start="3"><li>p名称空间注入使用p名称空间注入，可以简化基于xml配置方式<ol><li>添加p名称空间在配置文件中<img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210330180400748.png" class title="image-20210330180400748"></li><li>进行属性注入，在bean标签里面进行操作<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Book&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;斗破苍穹&quot;</span> <span class="attr">p:author</span>=<span class="string">&quot;天蚕土豆&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li>IOC操作Bean管理（xml注入其它类型属性）<ol><li><p>null值</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--向属性赋空值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>属性值包含特殊符号</p><p>1、把特殊符号进行转义</p><p>2、把带特殊符号内容写到CDATA</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[&lt;&lt;hell&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="注入属性-外部bean"><a href="#注入属性-外部bean" class="headerlink" title="注入属性-外部bean"></a>注入属性-外部bean</h4><ol><li><p>创建两个类service类和dao类</p></li><li><p>在service调用dao里面的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建UserMapper类型的属性，并提供set方法</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserMapper</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service....&quot;</span>);</span><br><span class="line">        userMapper.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    创建UserMapper的实现类对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.dao.UserMapperImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.service.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="注入属性–内部bean和级联赋值"><a href="#注入属性–内部bean和级联赋值" class="headerlink" title="注入属性–内部bean和级联赋值"></a>注入属性–内部bean和级联赋值</h4><p>一对多关系：员工和部门</p><p>一个部门有多个员工，一个员工属于一个部门</p><p>部门是一，员工是多</p><p><strong>在实体类之间表示一对多关系</strong></p><p>创建对应的实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Development dep;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDep</span><span class="params">(Development dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dep = dep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Development</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDname</span><span class="params">(String dname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dname = dname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小芳&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dep&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Development&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;人事部&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="级联赋值"><a href="#级联赋值" class="headerlink" title="级联赋值"></a>级联赋值</h4><ul><li>```xml<?xml version="1.0" encoding="UTF-8"?>&lt;beans xmlns=”<a href="http://www.springframework.org/schema/beans&quot;">http://www.springframework.org/schema/beans&quot;</a><pre><code>   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:p=&quot;http://www.springframework.org/schema/p&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!--级联赋值--&gt;&lt;bean id=&quot;employee&quot; class=&quot;com.mjy.pojo.Employee&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;李信&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;dep&quot; ref=&quot;dep&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;dep&quot; class=&quot;com.mjy.pojo.Development&quot;&gt;    &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 第二种方法：</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">  </span><br><span class="line">      &lt;!--级联赋值--&gt;</span><br><span class="line">      &lt;bean id=&quot;employee&quot; class=&quot;com.mjy.pojo.Employee&quot;&gt;</span><br><span class="line">          &lt;property name=&quot;name&quot; value=&quot;李信&quot;&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;</span><br><span class="line">          &lt;property name=&quot;dep&quot; ref=&quot;dep&quot;&gt;&lt;/property&gt;</span><br><span class="line">          &lt;!--使用之前需要获得该属性的get方法--&gt;</span><br><span class="line">          &lt;property name=&quot;dep.dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">  </span><br><span class="line">      &lt;bean id=&quot;dep&quot; class=&quot;com.mjy.pojo.Development&quot;&gt;</span><br><span class="line">      &lt;/bean&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/beans&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="xml注入集合属性"><a href="#xml注入集合属性" class="headerlink" title="xml注入集合属性"></a>xml注入集合属性</h4><ol><li><p>注入数组类型属性</p></li><li><p>注入List集合类型属性</p></li><li><p>注入Map集合类型属性</p></li><li><p>步骤</p><ol><li><p>创建类并定义数组、list、map、set类型属性，生成对应set方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组类型</span></span><br><span class="line">    <span class="keyword">private</span> String[] course;</span><br><span class="line">    <span class="comment">//list类型</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//map类型</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; maps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set类型</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; sets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getCourse() &#123;</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourse</span><span class="params">(String[] course)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.course = course;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getMaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaps</span><span class="params">(Map&lt;String, String&gt; maps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSets</span><span class="params">(Set&lt;String&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sets = sets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中进行配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--集合类型属性注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;course&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--list类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>宁毅<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>苏檀儿<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--map类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;数据库&quot;</span> <span class="attr">value</span>=<span class="string">&quot;陈老师&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;操作系统&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吴老师&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--set类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sets&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注入集合对象的属性</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建多个Course对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;英语&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Course&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;数学&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>把结合注入部分提取出来</p><ol><li><p>在Spring配置文件中引入名称J空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用util标签完成list集合注入提取</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--提取list集合类型属性注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>降龙十八掌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>打狗棍法<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>玉女心经<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--提取list集合类型属性注入使用--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookList&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="IOC操作bean管理（FactoryBean）"><a href="#IOC操作bean管理（FactoryBean）" class="headerlink" title="IOC操作bean管理（FactoryBean）"></a>IOC操作bean管理（FactoryBean）</h3><ol><li>Spring有两种类型bean，一种普通bean，另外一种工厂bean(FactoryBean)</li><li>普通bean：在配置文件中定义bean类型就是返回类型</li><li>工厂bean：在配置文件定义bean类型可以和返回类型不一样</li></ol><p>创建一个FactoryBean的步骤：</p><ul><li><p>创建类，让这个类作为工厂bean，实现接口FactoryBean</p></li><li><p>实现接口里面的方法，在实现的方法中定义返回的bean类型</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public class MyBean implements FactoryBean<span class="tag">&lt;<span class="name">Book</span>&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getObject() throws Exception &#123;</span><br><span class="line">        Book book = new Book();</span><br><span class="line">        ArrayList<span class="tag">&lt;<span class="name">String</span>&gt;</span> strings = new ArrayList<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        strings.add(&quot;hello&quot;);</span><br><span class="line">        strings.add(&quot;西游记&quot;);</span><br><span class="line">        book.setList(strings);</span><br><span class="line">        return book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;);</span><br><span class="line"></span><br><span class="line">    Book myBean = context.getBean(&quot;myBean&quot;, Book.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(myBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="IOC操作Bean管理（bean作用域）"><a href="#IOC操作Bean管理（bean作用域）" class="headerlink" title="IOC操作Bean管理（bean作用域）"></a>IOC操作Bean管理（bean作用域）</h3><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210811165359915.png" class title="image-20210811165359915"><ul><li><p>在Spring里面，可以设置创建bean实例是单实例还是多实例</p></li><li><p>在Spring里面，默认情况下，bean是单实例例对象</p></li><li><p>设置单实例还是多实例</p><ol><li><p>在Spring配置文件bean标签里面有属性(scope)用于设置单实例还是多实例</p></li><li><p>scope常用属性值：</p><p>singleton：默认值，表示是单实例对象</p><p>prototype：表示是多实例对象</p></li><li><p>singleton和prototype的区别</p><p>设置scope为singleton的时候，加载spring配置文件时就会创建单实例对象</p><p>设置scope值是prototype的时候，不是在加载spring 配置文件的时候创建对象，而是在调用getBean方法的时候去创建多实例对象</p></li><li></li></ol></li><li><p>在配置文件中配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--单实例还是多实例设置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--单例：singleton，原型：prototype--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Course&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="IOC操作Bean管理（bean生命周期）"><a href="#IOC操作Bean管理（bean生命周期）" class="headerlink" title="IOC操作Bean管理（bean生命周期）"></a>IOC操作Bean管理（bean生命周期）</h3><ul><li><p>生命周期：从对象创建到对象销毁的过程</p></li><li><p>bean生命周期</p><ol><li>通过构造器创建bean实例（无参数构造）</li><li>为bean的属性设置值和对其他bean引用（调用set方法）</li><li>调用bean的初始化方法（需要进行配置初始化的方法）</li><li>bean能够使用（对象获取到了）</li><li>当容器关闭时，调用bean的销毁的方法（需要进行配置销毁的方法）</li></ol></li><li><p>bean生命周期的演示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用无参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用set方法设置属性&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Order&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;外卖&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean3.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Order order = context.getBean(<span class="string">&quot;order&quot;</span>, Order.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;获取了order对象&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210401111652522.png" class title="image-20210401111652522"></li><li><p>有bean的后置处理器的情况下，bean的生命周期有七步</p><ol><li>通过构造器创建bean实例（无参数构造）</li><li>为bean的属性设置值和对其他bean引用（调用set方法）</li><li>把bean实例传递给bean后置处理器的方法<strong>postProcessBeforeInitialization</strong></li><li>调用bean的初始化方法（需要进行配置初始化的方法）</li><li>把bean实例传给bean后置处理器的方法<strong>postProcessAfterInitialization</strong></li><li>bean能够使用（对象获取到了）</li><li>当容器关闭时，调用bean的销毁的方法（需要进行配置销毁的方法）</li></ol></li><li><p>演示添加后置处理器效果</p><ol><li><p>创建类，实现BeanPostProcessor接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPost</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置bean后置处理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Order&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;orderName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;外卖&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--配置bean后置处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBoonPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.MyBeanPost&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210401113427712.png" class title="image-20210401113427712"></li></ol></li></ul><h3 id="IOC操作Bean管理（xml自动装配）"><a href="#IOC操作Bean管理（xml自动装配）" class="headerlink" title="IOC操作Bean管理（xml自动装配）"></a>IOC操作Bean管理（xml自动装配）</h3><ul><li><p>什么是自动装配</p><p>根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入</p></li><li><p>演示自动装配的过程</p><ol><li><p>根据属性名称自动注入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;阿里巴巴&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据属性类型进行注入  注意：不能定义两个相同类型的bean</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Employee&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.pojo.Development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;阿里巴巴&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="IOC操作Bean管理（外部属性文件）"><a href="#IOC操作Bean管理（外部属性文件）" class="headerlink" title="IOC操作Bean管理（外部属性文件）"></a>IOC操作Bean管理（外部属性文件）</h3><ol><li><p>直接配置数据库信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mjy600811&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>把外部properties属性文件引入到spring配置文件中</p><p>步骤：</p><ol><li><p>引入context名称空间</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210401194647861.png" class title="image-20210401194647861"></li><li><p>在spring配置文件中使用标签引入外部属性文件</p></li></ol></li></ol><h3 id="IOC操作Bean管理（基于注解方式）"><a href="#IOC操作Bean管理（基于注解方式）" class="headerlink" title="IOC操作Bean管理（基于注解方式）"></a>IOC操作Bean管理（基于注解方式）</h3><ol><li><p>什么是注解</p><ol><li>注解是代码特殊标记，格式：@注解名称（属性名称=属性值，属性名称=属性值..）</li><li>使用注解，注解作用在类上面，方法上面，属性上面</li><li>使用注解的目的：简化xml配置</li></ol></li><li><p>Spring针对Bean管理中创建对象提供注解</p><p>下面四个注解的功能是一样的，都可以用来创建bean实例，按照mvc架构区分</p><ol><li>@Component</li><li>@Service 【service】</li><li>@Controller 【controller】</li><li>@Repository 【dao】</li></ol></li><li><p>基于注解方式实现对象创建</p><ol><li><p>引入依赖</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210401204132106.png" class title="image-20210401204132106"></li><li><p>开启组件扫描：需要引入context名称空间</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment">    1、如果扫描多个包，多个包使用逗号隔开</span></span><br><span class="line"><span class="comment">    2、扫描包上层目录</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    &lt;context:component-scan base-package=&quot;com.mjy.dao,com.mjy.service&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建类，在类上面添加创建对象注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的操作相当于：&lt;bean id=&quot;userService&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//注解方式可以不写value值，默认为类名首字母小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>开启组件扫描细节配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例一</span></span><br><span class="line"><span class="comment">    use-default-filter=false 表示现在不使用默认filter,自己配置filter</span></span><br><span class="line"><span class="comment">    context:include-filter ,设置扫描哪些内容</span></span><br><span class="line"><span class="comment">    默认扫描全部</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--示例2</span></span><br><span class="line"><span class="comment">下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment">context:exclude-filter 设置不扫描哪些内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:exclude-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解方式实现属性注入</p><ul><li><p>@Autowired:根据属性类型进行自动装配</p><ol><li><p>把service和dao对象创建，在service和dao类添加创建对象注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户信息。。。。balabala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在service注入dao对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的操作相当于：&lt;bean id=&quot;userService&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//注解方式可以不写value值，默认为类名首字母小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dao属性</span></span><br><span class="line">    <span class="comment">//不需要添加set方法，内部已经帮我们实现了</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service.....&quot;</span>);</span><br><span class="line">        userDao.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>@Qualifier：根据属性名称进行注入(使用需要和@AUtowired一起使用)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(value=&quot;userDaoImpl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户信息。。。。balabala&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面的操作相当于：&lt;bean id=&quot;userService&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//注解方式可以不写value值，默认为类名首字母小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dao属性</span></span><br><span class="line">    <span class="comment">//不需要添加set方法，内部已经帮我们实现了</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//根据类型进行注入</span></span><br><span class="line">    <span class="meta">@Qualifier(value=&quot;userDaoImpl&quot;)</span><span class="comment">//根据名称进行注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service.....&quot;</span>);</span><br><span class="line">        userDao.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Resource：可以根据类型注入，也可以根据名称注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-01 20:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的操作相当于：&lt;bean id=&quot;userService&quot; class=&quot;&quot;&gt;</span></span><br><span class="line"><span class="meta">@Service(value=&quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//注解方式可以不写value值，默认为类名首字母小写</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dao属性</span></span><br><span class="line">    <span class="comment">//不需要添加set方法，内部已经帮我们实现了</span></span><br><span class="line">    <span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="comment">//    @Autowired //根据类型进行注入</span></span><br><span class="line"><span class="comment">//    @Qualifier(value=&quot;userDaoImpl&quot;)//根据名称进行注入</span></span><br><span class="line"><span class="comment">//    @Resource  //根据类型注入</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;userDaoImpl&quot;)</span><span class="comment">//根据名称进行注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service.....&quot;</span>);</span><br><span class="line">        userDao.info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>@Value：注入普通类型属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li></li></ul></li><li><p>完全注解开发</p><ul><li><p>创建配置类，替代xml配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//作为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&#123;&quot;com.mjy&quot;&#125;)</span></span><br><span class="line"><span class="comment">//上面的ComponentScan等同于  &lt;context:component-scan base-package=&quot;com.mjy&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">    UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">    userService.service();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h3><p>JavaConfig是Spring的一个子项目，在Spring4之后，它成为了一个核心功能</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210811220213960.png" class title="image-20210811220213960"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//说明这个类被Spring接管了，注册到了容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="comment">//    @Value(&quot;小敖&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;曦雨&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(UserConfig1.class)</span> <span class="comment">//引入UserConfig1配置类合成一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line"><span class="comment">//        User bean = context.getBean(User.class);</span></span><br><span class="line"><span class="comment">//        System.out.println(bean.name);</span></span><br><span class="line"></span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(UserConfig.class);</span><br><span class="line">    User bean = context.getBean(User.class);</span><br><span class="line">    System.out.println(bean.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>什么是AOP<ul><li>面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发效率</li><li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</li><li>使用登录例子说明AOP</li></ul></li></ol><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>角色分析：</p><ul><li>抽象角色：一般会使用接口或者抽象类来解决</li><li>真实的角色：被代理的角色</li><li>代理角色：代理真实的角色，代理真实角色后，我们一般会做一些附属操作</li><li>客户：访问代理对象的人</li></ul><p>租房：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//租房这件事</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RentHouse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>房东：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseMaster</span> <span class="keyword">implements</span> <span class="title">RentHouse</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>中介：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">RentHouse</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HouseMaster master;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(HouseMaster master)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.master=master;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        viewHouse();</span><br><span class="line">        recommendHouse();</span><br><span class="line">        writePact();</span><br><span class="line">        master.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">viewHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介可以带你参观房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recommendHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;中介推荐符合要求的房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writePact</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;签定合同&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>租客：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Agent agent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Agent agent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.agent = agent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rentHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        agent.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理模式的好处：</p><ul><li>可以使真实角色的操作更加纯粹！不用关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候方便集中管理</li></ul><p>缺点：</p><ul><li>一个真实角色就会产生一个代理对象；代码量会翻倍~开发效率会变低</li></ul><h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><ol><li><p>AOP底层使用动态代理</p><p>动态代理有两种情况</p><ol><li><p>有接口情况，使用JDK动态代理</p><p>创建接口实现类代理对象，增强类的方法</p></li><li><p>没有接口情况，使用CGLIB动态代理</p><p>创建子类的代理对象，增强类的方法</p></li></ol></li></ol><h3 id="JDK动态代理的代码实现"><a href="#JDK动态代理的代码实现" class="headerlink" title="JDK动态代理的代码实现"></a>JDK动态代理的代码实现</h3><ol><li><p>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</p><p>java.lang.reflect.Proxy</p><p>调用newProxyInsatance方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>方法有三个参数：</p><p>第一个参数，类加载器</p><p>第二个参数，增强方法所在的类，这个类实现的接口，支持多个接口</p><p>第三个参数，实现这个接口的InvocationHandler,创建代理对象，写增强方法</p></li><li><p>编写JDK动态代理代码</p><ol><li><p>创建接口，定义方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">discountPrice</span><span class="params">(<span class="keyword">double</span> discount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建接口实现类，实现方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;图书的信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discountPrice</span><span class="params">(<span class="keyword">double</span> discount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">89</span>*discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Proxy类创建接口代理对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces=<span class="keyword">new</span> Class[]&#123;BookDao.class&#125;;</span><br><span class="line"></span><br><span class="line">        BookDaoImpl bookDao = <span class="keyword">new</span> BookDaoImpl();</span><br><span class="line"></span><br><span class="line">        BookDao bookDao1 = (BookDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, <span class="keyword">new</span> BookDaoProxy(bookDao));</span><br><span class="line">        bookDao1.info();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象的代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDaoProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建的是谁的代理对象，需要把该对象传递过来</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookDaoProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj=obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//增强的功能就是指在指定方法执行之前和之后进行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行指定方法&quot;</span>+method.getName()+<span class="string">&quot;之前进行的操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行，res表示方法的返回值</span></span><br><span class="line">        Object res = method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行指定方法之后进行的操作&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="AOP术语：专业术语"><a href="#AOP术语：专业术语" class="headerlink" title="AOP术语：专业术语"></a>AOP术语：专业术语</h3><ul><li><p>连接点</p><p>类里面可以被增强的方法，称为连接点</p></li><li><p>切入点</p><p>实际被真正增强的方法，称其为切入点</p></li><li><p>通知（增强）</p><ol><li> 实际增强的逻辑部分称为通知（增强）</li><li>通知有多种类型<ul><li>前置通知：在增强方法之前执行的操作</li><li>后置通知：在增强方法之后执行的操作</li><li>环绕通知：在增强方法之前及之后执行的操作</li><li>异常通知：在增强方法出现异常时执行的操作</li><li>最终通知：与finally类似</li></ul></li></ol></li><li><p>切面</p><p>把通知应用到切入点</p></li></ul><h3 id="AOP操作准备工作"><a href="#AOP操作准备工作" class="headerlink" title="AOP操作准备工作"></a>AOP操作准备工作</h3><ul><li><p>Spring框架一般都是基于AspectJ实现AOP操作</p><p>AspectJ:AspectJ不是Spring组成部分，是一个独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作</p></li><li><p>基于AspectJ实现AOP操作</p><ul><li>基于xml配置文件实现</li><li>基于注解方式实现（使用较方便）</li></ul></li><li><p>在项目工程里面引入相关依赖</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210402164639866.png" class title="image-20210402164639866"></li><li><p>切入点表达式</p><ul><li><p>切入点表达式的作用：知道对哪个类里面的哪个方法进行增强</p></li><li><p>语法结构：</p><p>execution(【权限修饰符】【返回值类型】【类全路径】【方法名称】（【参数列表】）)</p></li><li><p>举例</p><p>1、对com.atguigu.dao.BookDao类里面的add进行增强</p><p>​    execution(* com.atguigu.dao.BookDao.add(..)) 注：*指任意类型的权限修饰符（可以省略） . .可以代表参数列表，返回值类型也可以省略</p><p>2、对com.atguigu.dao.BookDao类里面的所有方法进行增强</p><p>​    execution(* com.atguigu.dao.BookDao.*(..))  </p><p>3、对com.atguigu.dao所有类里面的所有方法进行增强</p><p>​    execution(* com.atguigu.dao.*.*(..))                                                                    </p></li></ul></li></ul><h3 id="AOP操作（AspectJ注解）"><a href="#AOP操作（AspectJ注解）" class="headerlink" title="AOP操作（AspectJ注解）"></a>AOP操作（AspectJ注解）</h3><ol><li><p>创建类，在类里面定义方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个善良的人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建增强类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我虽然不漂亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行通知的配置</p><ol><li><p>在Spring配置文件中，开启注解扫描</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启注解的扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解创建User和UserProxy对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//被增强类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个善良的人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我虽然不漂亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在增强类上面添加注解@Aspect</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//创建对象</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我虽然不漂亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中开启生成代理对象</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置不同类型的通知</p><ul><li>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式</li></ul></li><li><p>公共切入点抽取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强类</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//创建对象</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">//公共切入点抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(value=&quot;execution(* com.mjy.dao.User.info(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="meta">@Before(value=&quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我虽然不漂亮&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终通知</span></span><br><span class="line">    <span class="meta">@After(value=&quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置对象通知</span></span><br><span class="line">    <span class="meta">@AfterReturning(value=&quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value=&quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value=&quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之前.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被增强的方法执行</span></span><br><span class="line">        proceedingJoinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕之后.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有多个增强类对同一个方法进行增强，设置增强类优先级</p><p>在增强类上面添加注解@Order(数字类型值)，数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(value=&quot;execution(* com.mjy.dao.User.info(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;personProxy before....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全使用注解开发</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启注解扫描</span></span><br><span class="line"><span class="comment">//&lt;context:component-scan base-package=&quot;com.mjy&quot;&gt;&lt;/context:component-scan&gt;</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&#123;&quot;com.mjy&quot;&#125;)</span></span><br><span class="line"><span class="comment">//&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line"><span class="comment">//&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigAop</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="AOP-基于AspectJ配置文件"><a href="#AOP-基于AspectJ配置文件" class="headerlink" title="AOP 基于AspectJ配置文件"></a>AOP 基于AspectJ配置文件</h3><ol><li><p>创建两个类，增强类和被增强类，创建方法</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中创建两个类对象</p></li><li><p>在Spring配置文件中配置切入点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;po&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.mjy.aopxml.Book.info(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;po&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Spring-API"><a href="#Spring-API" class="headerlink" title="Spring API"></a>Spring API</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(o.getClass().getName()+<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterLog</span> <span class="keyword">implements</span> <span class="title">AfterReturningAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+method.getName()+<span class="string">&quot;方法，执行结果为：&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.log.Log&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置aop：需要导入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点:expression表达式，execution(要执行的位置)--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.mjy.service.impl.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--执行环绕增加--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="自定义实现AOP"><a href="#自定义实现AOP" class="headerlink" title="自定义实现AOP"></a>自定义实现AOP</h3><p>切入的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xmlns:aop=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--注册bean--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.service.impl.UserServiceImpl&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;log&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.log.Log&quot;</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;afterLog&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.log.AfterLog&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    &amp;lt;!&amp;ndash;配置aop：需要导入&amp;ndash;&amp;gt;--&gt;</span><br><span class="line">&lt;!--    &lt;aop:config&gt;--&gt;</span><br><span class="line">&lt;!--        &amp;lt;!&amp;ndash;切入点:expression表达式，execution(要执行的位置)&amp;ndash;&amp;gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        &lt;aop:pointcut id=<span class="string">&quot;pointcut&quot;</span> expression=<span class="string">&quot;execution(* com.mjy.service.impl.UserServiceImpl.*(..))&quot;</span>/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        &amp;lt;!&amp;ndash;执行环绕增加&amp;ndash;&amp;gt;--&gt;</span><br><span class="line">&lt;!--        &lt;aop:advisor advice-ref=<span class="string">&quot;log&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;--&gt;</span><br><span class="line">&lt;!--        &lt;aop:advisor advice-ref=<span class="string">&quot;afterLog&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;--&gt;</span><br><span class="line">&lt;!--    &lt;/aop:config&gt;--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--自定义类--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;diy&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.diy.PointCut&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--自定义切面,ref要引用的对象--&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">&quot;diy&quot;</span>&gt;</span><br><span class="line">            &lt;!--切入点--&gt;</span><br><span class="line">            &lt;aop:pointcut id=<span class="string">&quot;pointcut&quot;</span> expression=<span class="string">&quot;execution(* com.mjy.service.impl.UserServiceImpl.*(..))&quot;</span>/&gt;</span><br><span class="line">            &lt;!--通知--&gt;</span><br><span class="line">            &lt;aop:before method=<span class="string">&quot;before&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="line">            &lt;aop:after method=<span class="string">&quot;after&quot;</span> pointcut-ref=<span class="string">&quot;pointcut&quot;</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><p><strong>导入依赖：</strong></p><ul><li>junit</li><li>mybatis</li><li>mysql数据库</li><li>spring相关</li><li>aop相关</li><li>mybatis-spring</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--aop织入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写配置文件：</strong></p><p>mybatis-config.xml:配置别名和一些设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置日志--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=<span class="string">&quot;logImpl&quot;</span> value=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="line">        &lt;!--开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn--&gt;</span><br><span class="line">        &lt;setting name=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">        &lt;!--开启全局缓存--&gt;</span><br><span class="line">        &lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span>/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.mjy.entity&quot;</span>/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>spring-dao.xml：配置跟数据源相关的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据源--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;mjy600811&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置sqlSessionFactory--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;dataSource&quot;</span> ref=<span class="string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="line">        &lt;!--绑定mybatis-config.xml--&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;configLocation&quot;</span> value=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;mapperLocations&quot;</span> value=<span class="string">&quot;classpath*:com/mjy/mapper/xml/*Mapper.xml&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置sqlSession--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;sqlSession&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span><br><span class="line">        &lt;!--只能用有参构造注入，没有set方法--&gt;</span><br><span class="line">        &lt;constructor-arg name=<span class="string">&quot;sqlSessionFactory&quot;</span> ref=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>applicationContext.xml：各配置文件的汇总</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">import</span> resource=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置UserMapper--&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;userMapper&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.mapper.UserMapperImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;sqlSessionTemplate&quot;</span> ref=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userMapper1&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.mjy.mapper.UserMapperImpl1&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;sqlSessionFactory&quot;</span> ref=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="line">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;com.mjy.mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=<span class="string">&quot;getUserList&quot;</span> resultType=<span class="string">&quot;User&quot;</span>&gt;</span><br><span class="line">        select * from user;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>UserMapper.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title">UserMapper</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSqlSessionTemplate</span><span class="params">(SqlSessionTemplate sqlSessionTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sqlSessionTemplate = sqlSessionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.getUserList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    UserMapper userMapper = context.getBean(<span class="string">&quot;userMapper1&quot;</span>, UserMapper.class);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; userList = userMapper.getUserList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="jdbcTemplate"><a href="#jdbcTemplate" class="headerlink" title="jdbcTemplate"></a>jdbcTemplate</h2><h3 id="1、概念和准备工作"><a href="#1、概念和准备工作" class="headerlink" title="1、概念和准备工作"></a>1、概念和准备工作</h3><ol><li><p>什么是jdbcTemplate</p><p>Spring框架对JDBC进行封装，使用jdbcTemplate方便实现对数据库操作</p></li><li><p>准备工作</p><ol><li><p>导入相关的jar包</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210403115606606.png" class title="image-20210403115606606"></li><li></li><li><p>配置jdbcTemplate对象，注入DataSource</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdbcTemplate对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建service类，创建dao类，在dao注入jdbcTemplate都对象</p><p>配置文件开启注解扫描</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在service里面注入BookDao</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在dao中注入JdbcTemplate</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="2、JdbcTemplate操作数据库"><a href="#2、JdbcTemplate操作数据库" class="headerlink" title="2、JdbcTemplate操作数据库"></a>2、JdbcTemplate操作数据库</h3><p><strong>插入：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    String sql=<span class="string">&quot;insert into book values(?,?,?)&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql,book.getId(),book.getName(),book.getPrice());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>修改：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    String sql=<span class="string">&quot;update book set name=?,price=? where id=?&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql,book.getName(),book.getPrice(),book.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    String sql=<span class="string">&quot;delete from book where id=?&quot;</span>;</span><br><span class="line">    jdbcTemplate.update(sql,id);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询返回某个值</strong></p><p>使用方法：</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210403150712109.png" class title="image-20210403150712109"><p>第一个参数是sql语句，第二个参数是返回值类型的class</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">selectCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String sql=<span class="string">&quot;select count(*) from book&quot;</span>;</span><br><span class="line">    Integer count = jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询返回对象</strong></p><p>使用方法</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210403151949757.png" class title="image-20210403151949757"><p>第一个参数sql语句，第二个参数：RowMapper是接口，返回不同类型数据，使用这个接口里面的实现类完成数据的封装，sql语句的参数值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">queryBook</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String sql=<span class="string">&quot;select * from book where id=?&quot;</span>;</span><br><span class="line">    Book book = jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Book&gt;(Book.class), id);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询返回集合</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String sql=<span class="string">&quot;select * from book&quot;</span>;</span><br><span class="line">    List&lt;Book&gt;  bookList= jdbcTemplate.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Book.class));</span><br><span class="line">    <span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jdbcTemplate操作数据库（批量操作）"><a href="#jdbcTemplate操作数据库（批量操作）" class="headerlink" title="jdbcTemplate操作数据库（批量操作）"></a>jdbcTemplate操作数据库（批量操作）</h3><p><strong>批量添加</strong></p><p>使用方法：</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404135636831.png" class title="image-20210404135636831"><p>第一个参数预编译的sql语句，第二个参数，需要添加的信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchAdd</span><span class="params">(List&lt;Object[]&gt; list)</span> </span>&#123;</span><br><span class="line">    String sql=<span class="string">&quot;insert into book values(?,?,?)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回影响的行数的数组</span></span><br><span class="line">    <span class="keyword">int</span>[] ints = jdbcTemplate.batchUpdate(sql, list);</span><br><span class="line">    System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>批量修改和批量删除同上</strong></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="搭建事务操作的环境"><a href="#搭建事务操作的环境" class="headerlink" title="搭建事务操作的环境"></a>搭建事务操作的环境</h3><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404142623903.png" class title="image-20210404142623903"><h3 id="Spring事务管理的介绍"><a href="#Spring事务管理的介绍" class="headerlink" title="Spring事务管理的介绍"></a>Spring事务管理的介绍</h3><ul><li><p>事务添加到JavaEE三层结构里面的Service层</p></li><li><p>在Spring中有两种方式进行事务管理</p><ol><li>编程式事务管理</li><li>声明式事务管理（常用）</li></ol></li><li><p>声明式事务管理</p><ol><li>基于注解方式（常用）</li><li>基于xml配置文件方式</li></ol></li><li><p>在Spring进行声明式事务管理，底层使用AOP原理</p></li><li><p>Spring事务管理API</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404151742780.png" class title="image-20210404151742780"></li></ul><h3 id="注解声明式事务管理"><a href="#注解声明式事务管理" class="headerlink" title="注解声明式事务管理"></a>注解声明式事务管理</h3><ul><li><p>在Spring配置文件中配置事务管理器</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件，开启事务注解</p><ol><li><p>在Spring配置文件中引入名称空间tx</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404152937626.png" class title="image-20210404152937626"></li><li><p>开启事务注解</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在service类上面（或者service类里面方法上面）添加事务注解</p><ol><li>@Transactional这个注解可以添加到类上面，也可以添加在方法上面</li><li>如果加在类上面，这个类里面所有的方法都添加事务</li><li>如果把这个注解添加在方法上，则为该方法添加事务</li></ol></li></ol></li></ul><h4 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h4><ul><li><p>在service类上面添加注解@Transactional,在这个注解里面可以配置事务相关参数</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404154752482.png" class title="image-20210404154752482"><ol><li><p>propagation：事务传播行为</p><p>多事务方法直接进行调用，这个过程中事务是如何进行管理的称为事务传播行为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED)</span></span><br></pre></td></tr></table></figure><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404155846576.png" class></li><li><p>isolation：事务隔离级别</p><p>事务有特性：隔离性，多事务之间不会产生影响。不考虑隔离性会产生很多问题</p><p>脏读：一个未提交事务读取到另一个未提交事务的数据</p><p>不可重复读：一个未提交事务读取到另一提交事务修改数据</p><p>幻读：一个为提交事务读取到另一个提交事务添加数据</p><p>通过设置事务隔离级别就能够解决读的问题</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210404162129335.png" alt="image-20210404162129335"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(propagation= Propagation.REQUIRED,isolation= Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure></li><li><p>timeout：超时时间</p><p>事务需要在一定时间内进行提交，如果不提交就进行回滚</p><p>默认值-1，设置时间以秒为单位进行计算</p></li><li><p>readOnly：是否只读</p><p>读：查询操作，写：添加修改删除</p><p>readOnly 默认值false，表示可以查询，可以添加修改删除操作</p></li><li><p>rollbackFor：回滚</p><p>设置出现哪些异常进行事务回滚</p></li><li><p>noRollbackFor：不回滚</p><p>设置出现哪些异常不进行事务回滚</p></li></ol></li></ul><h3 id="基于xml声明式事务管理"><a href="#基于xml声明式事务管理" class="headerlink" title="基于xml声明式事务管理"></a>基于xml声明式事务管理</h3><ul><li><p>在Spring配置文件中进行配置</p><ol><li><p>配置事务管理器</p></li><li><p>配置通知</p></li><li><p>配置切入点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启注解扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mjy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入外部文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.driverClassName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;prop.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jdbcTemplate对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以account开头的都添加上事务--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;tx:method name=&quot;account*&quot;&gt;&lt;/tx:method&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置切入点和切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.mjy.service.AccountService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="完全注解开发"><a href="#完全注解开发" class="headerlink" title="完全注解开发"></a>完全注解开发</h3><p>创建配置类，使用配置类代替xml配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages =&#123;&quot;com.mjy&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span> <span class="comment">//开启事务注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建数据库连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">getDruidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&quot;</span>);</span><br><span class="line">        druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        druidDataSource.setPassword(<span class="string">&quot;mjy600811&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jdbcTemplate对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事务管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = <span class="keyword">new</span> DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Spring5框架新功能"><a href="#Spring5框架新功能" class="headerlink" title="Spring5框架新功能"></a>Spring5框架新功能</h2><ul><li><p>整个Spring5框架的代码基于Java8,运行时兼容JDk9,许多不建议使用的类和方法在代码库中删除</p></li><li><p>Spring5.0框架自带了通用的日志封装</p><ol><li><p>Spring5已经移除Log4jConfigListener,官方建议使用Log4j2</p></li><li><p>Spring5框架整合Log4j2</p></li><li><p>使用Log4j2</p><p>引入jar包</p><img src="/2021/08/10/Spring%E5%AD%A6%E4%B9%A0/image-20210404181526001.png" class title="image-20210404181526001"><p>创建Log4j2.xml配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">console</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>手动输出log信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-04-04 18:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log= LoggerFactory.getLogger(LogTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误警告&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Spring5框架核心容器技术支持@Nullable注解</p><p>@Nullable注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空</p><p>注解用在方法上面，方法返回值可以为空</p></li><li><p>Spring5核心容器支持函数式风格GenericApplicationContext</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给spring管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGenericApplicationContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建GenericApplicationContext对象</span></span><br><span class="line">    GenericApplicationContext context=<span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line">    <span class="comment">//调用context的方法对象注册</span></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.registerBean(Book.class,()-&gt;<span class="keyword">new</span> Book());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取在Spring中注册的对象</span></span><br><span class="line">    Book bean = (Book)context.getBean(<span class="string">&quot;com.mjy.pojo.Book&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring5支持整合JUnit5</p><ol><li><p>整合JUnit4</p><ul><li><p>引入Spring相关针对测试依赖</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210404210617989.png" alt="image-20210404210617989"></p></li><li><p>创建测试类（使用完全注解会报错）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> <span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JU4Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(bookService.queryBook(<span class="string">&quot;101&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Spring5整合JUnit5</p><ul><li><p>引入JUnit5的jar包</p></li><li><p>创建测试类，使用注解完成</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210404212702520.png" alt="image-20210404212702520"></p></li></ul></li><li><p>可以使用一个复合注解替代上面两个注解完成整合</p><p><img src="/Sparing%E5%AD%A6%E4%B9%A0/image-20210404213008466.png" alt="image-20210404213008466"></p></li><li></li></ol></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOC,AOP,轻量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2021/08/07/MyBatis/"/>
      <url>/2021/08/07/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis学习笔记"><a href="#Mybatis学习笔记" class="headerlink" title="Mybatis学习笔记"></a>Mybatis学习笔记</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h3><ul><li>MyBatis是一款优秀的<strong>持久层框架</strong></li><li>它支持定制化SQL、存储过程以及高级映射</li><li>MyBatis避免了几乎所有JDBC代码和手动设置参数以及获取结果集</li><li>MyBatis可用使用简单的xml或注解来配置和映射原生类型、接口和java的pojo(plain Old java Objects 普通老式java对象) 为数据库中的记录</li><li>Mybatis 本是apache的一个开源项目iBatis,2010年这个项目由apache software foundation迁移到了google code 并改名为Mybatis</li><li>2013年11月迁移到Github</li></ul><p>如何获得Mybatis?</p><ul><li><p>maven仓库</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>中文文档：<a href="https://mybatis.org/mybatis-3/zh/getting-started.html">https://mybatis.org/mybatis-3/zh/getting-started.html</a></p></li></ul><h3 id="1-2、持久层"><a href="#1-2、持久层" class="headerlink" title="1.2、持久层"></a>1.2、持久层</h3><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：断电即失</li><li>数据库(jdbc),io文件持久化</li></ul><p>需要持久化的原因：</p><ul><li>有一些对象，需要持久化存储，不能丢失</li><li>内存太贵</li></ul><h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p>DAO层，Service层，Controller层…..</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显</li></ul><h3 id="1-4、为什么需要Mybatis（半自动化）"><a href="#1-4、为什么需要Mybatis（半自动化）" class="headerlink" title="1.4、为什么需要Mybatis（半自动化）"></a>1.4、为什么需要Mybatis（半自动化）</h3><ul><li><p>帮助程序员将数据存入到数据库中</p></li><li><p>方便</p></li><li><p>传统的JDBC代码太复杂了，简化操作</p></li><li><p>不用Mybatis也可以。更容易上手</p></li><li><p>优点：</p><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ul></li></ul><h1 id="2、第一个MyBatis程序"><a href="#2、第一个MyBatis程序" class="headerlink" title="2、第一个MyBatis程序"></a>2、第一个MyBatis程序</h1><p>思路：搭建环境—-&gt;导入Mybatis—&gt;编写代码测试</p><h3 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h3><p>搭建数据库（建库建表）</p><p>新建项目</p><ol><li><p>创建普通的maven项目</p></li><li><p>删除src目录</p></li><li><p>导入maven依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--父工程--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--junit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2创建一个模块"><a href="#2-2创建一个模块" class="headerlink" title="2.2创建一个模块"></a>2.2创建一个模块</h3><ol><li><p>编写mybatis的核心配置文件</p><p>Mysql的url中的时区设置为<strong>Asia/Shanghai</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启全局缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写mybatis工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sqlSessionFactory---&gt;sqlSession</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取sqlSessionFactory对象</span></span><br><span class="line">            String resource=<span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream resourceAsStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory= <span class="keyword">new</span> SqlSessionFactoryBuilder().build(resourceAsStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取了SqlSessionFactory,我们就可以从中获取sqlSession的实例了</span></span><br><span class="line">    <span class="comment">//sqlSession完全包含了面向数据库执行sql命令所需的所有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h3><ul><li><p>实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>DAO接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接口实现类由原来的UserDaolmp转变为一个Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace绑定一个对应的DAO或Mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mjy.dao.UserDAO&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--select查询语句--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h3><p><strong>注意点：每一个Mapper.xml都需要在Mybatis核心配置文件中注册</strong></p><p>解决maven找不到配置文件的问题：(重点)</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在build中配置resource,来防止我们资源导出失败的问题(配置文件找不到)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h2><h3 id="1、namespace"><a href="#1、namespace" class="headerlink" title="1、namespace"></a>1、namespace</h3><p>namespace中的包名要和DAO/Mapper接口包名一致</p><h3 id="2、select"><a href="#2、select" class="headerlink" title="2、select"></a>2、select</h3><p>选择，查询语句：</p><ul><li>id:就是对应的namespace中的方法名；</li><li>resultType:sql语句的返回值</li><li>paramerterType:参数类型</li></ul><p>1、编写接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户id查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><p>2、编写Mapper对应的sql语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、测试</p><h3 id="3、insert"><a href="#3、insert" class="headerlink" title="3、insert"></a>3、insert</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    insert into user(id,name,password) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、update"><a href="#4、update" class="headerlink" title="4、update"></a>4、update</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">    update user set name=#&#123;name&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5、delete"><a href="#5、delete" class="headerlink" title="5、delete"></a>5、delete</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ul><li>增删改操作需要提交事务</li></ul><h3 id="6、分析错误"><a href="#6、分析错误" class="headerlink" title="6、分析错误"></a>6、分析错误</h3><ul><li>标签不要匹配错</li><li>resource绑定mapper，需要使用路径”/“</li><li>程序配置文件必须符合规范</li><li>NullPointerException</li><li>输出的xml文件中存在中文乱码问题</li><li>mybatis-config.xml绑定接口时用“ .”</li><li></li></ul><h3 id="7、万能Map"><a href="#7、万能Map" class="headerlink" title="7、万能Map"></a>7、万能Map</h3><p>假设，我们的实体类，或者数据库的 表，字段或者参数过多，我们应该考虑使用Map!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 万能map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateUser1</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser1&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Map&quot;</span>&gt;</span></span><br><span class="line">        update user set name=#&#123;username&#125; where id=#&#123;userId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">       SqlSession sqlSession=MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;userId&quot;</span>,<span class="number">2</span>);</span><br><span class="line">       map.put(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;小蚕&quot;</span>);</span><br><span class="line">       <span class="keyword">int</span> flag = mapper.updateUser1(map);</span><br><span class="line"></span><br><span class="line">       sqlSession.commit();</span><br><span class="line">       sqlSession.close();</span><br><span class="line">       <span class="keyword">if</span>(flag&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;修改失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Map传递参数，直接在sql中取出key即可！【parameterType=”map”】</p><p> 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】</p><p>只有一个基本类型参数的情况下，可以直接在sql中取到</p><p>多个参数用Map或者<strong>注解</strong></p><p>模糊查询写法：</p><ol><li><p>java代码执行的时候，传递通配符%%</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">      SqlSession sqlSession=MybatisUtils.getSqlSession();</span><br><span class="line">   </span><br><span class="line">      UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">   </span><br><span class="line">      List&lt;User&gt; userLike = mapper.getUserLike(<span class="string">&quot;%聂%&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (User user : userLike) &#123;</span><br><span class="line">          System.out.println(user);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      sqlSession.close();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在sql拼接中使用通配符</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where name like &quot;%&quot;#&#123;name&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h2><h3 id="1、核心配置文件"><a href="#1、核心配置文件" class="headerlink" title="1、核心配置文件"></a>1、核心配置文件</h3><ul><li><p>mybatis-config.xml</p></li><li><p>MyBatis的配置文件包含了会深深影响MyBatis行为的设置和属性信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">configuration（配置）</span><br><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、环境配置-environment"><a href="#2、环境配置-environment" class="headerlink" title="2、环境配置(environment)"></a>2、环境配置(environment)</h3><p>mybatis可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><p>学会使用配置多套运行环境！</p><p>mybatis默认的事务管理器就是JDBC ,连接池：POOLED</p><h3 id="3、属性（properties）"><a href="#3、属性（properties）" class="headerlink" title="3、属性（properties）"></a>3、属性（properties）</h3><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性都是可外部配置且可动态转换的，既可以在典型的java属性文件中配置，亦可通过prroperties元素的子元素来传递。【db.properties】</p><p>编写一个配置文件</p><p>db.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">mjy600811</span></span><br></pre></td></tr></table></figure><p>在核心配置文件中引入 注意：在xml文件中，所有的配置文件需要按照一定的顺序进行编写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12947123&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以直接引入外部文件</li><li>可以在其中增加一些属性配置</li><li>如果两个文件有同一个字段，优先使用外部配置文件</li></ul><h3 id="4、类型别名（typeAliases）"><a href="#4、类型别名（typeAliases）" class="headerlink" title="4、类型别名（typeAliases）"></a>4、类型别名（typeAliases）</h3><ul><li><p>类型别名是为java类型设置一个短的名字</p></li><li><p>存在的意义仅在于用来减少类完全限定名的冗余</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以给实体类起别名别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>也可以指定一个包名，MyBatis会在包名下面搜索需要的java Bean,比如：</p><p>扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描实体类的包,它的默认别名就为这个类的类名,首字母小写(推荐),大写也能行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.mjy.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实体类比较少的时候，使用第一种方式。如果实体类十分多，建议使用第二种。第一种可以DIY别名，第二种则不行，如果非要改，需要在实体上增加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>执行的先后顺序：typeAliases定义别名&gt;注解&gt;typeAliases扫描包默认别名</p><h3 id="5、设置"><a href="#5、设置" class="headerlink" title="5、设置"></a>5、设置</h3><p>这是MyBatis中极为重要的调整设置，它们会改变Mybatis的运行时行为</p><img src="/2021/08/07/MyBatis/image-20210323172824888.png" class title="image-20210323172824888"><img src="/2021/08/07/MyBatis/image-20210323172857725.png" class title="image-20210323172857725"><h3 id="6、其他配置"><a href="#6、其他配置" class="headerlink" title="6、其他配置"></a>6、其他配置</h3><ul><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li>plugins（插件<ul><li>mybatis-generator-core</li><li>mybatis-plus</li><li>通用mapper</li></ul></li></ul><h3 id="7、映射器（mappers）"><a href="#7、映射器（mappers）" class="headerlink" title="7、映射器（mappers）"></a>7、映射器（mappers）</h3><p>MapperRegistry:注册绑定我们的Mapper文件</p><p>方式1【推荐使用】：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--每一个Mapper.xml都需要在Mybatis核心配置文件中注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/mjy/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class文件绑定注册</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;com/mjy/dao/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.dao.UserMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>方式二使用要求：</p><ul><li>接口和它的Mapper配置文件必须同名</li><li>接口和它的Mapper配置文件必须在同一个包下</li></ul><p>方式三：使用扫描包进行注入绑定</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper resource=&quot;com/mjy/dao/UserMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;mapper class=&quot;com.mjy.dao.UserMapper&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.mjy.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式三使用要求：</p><ul><li>接口和它的Mapper配置文件必须同名</li><li>接口和它的Mapper配置文件必须在同一个包下</li></ul><h3 id="8、生命周期和作用域"><a href="#8、生命周期和作用域" class="headerlink" title="8、生命周期和作用域"></a>8、生命周期和作用域</h3><p>生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong></p><p><strong>SqlSessionFactoryBuilder</strong>:</p><ul><li>一旦创建了SqlSessionFactory，就不再需要它了</li><li>局部变量</li></ul><p><strong>SqlSessionFactory</strong>:</p><ul><li>可以类比成数据库连接池</li><li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong></li><li>SqlSessionFactory的最佳作用域是应用作用域</li><li>最简单的就是使用单例模式或者静态单例模式</li></ul><p><strong>SqlSession</strong></p><ul><li>连接到连接池的一个请求</li><li>SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li><li>用完之后需要关闭，否则资源会被占用</li></ul><h2 id="5、解决属性名和字段名不一致的问题"><a href="#5、解决属性名和字段名不一致的问题" class="headerlink" title="5、解决属性名和字段名不一致的问题"></a>5、解决属性名和字段名不一致的问题</h2><p>当数据库中的表字段名与定义的类中的字段名不一致时</p><p>测试出现问题：字段不一致的属性为空</p><img src="/2021/08/07/MyBatis/image-20210323222143007.png" class title="image-20210323222143007"><p>解决方法一：起别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">       select id,name,password pwd from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方法二：</p><h3 id="2、resultMap"><a href="#2、resultMap" class="headerlink" title="2、resultMap"></a>2、resultMap</h3><p>结果集映射</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">id name password</span><br><span class="line">id name pwd</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mjy.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--结果集映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--column数据库中的字段，property实体类中的属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;pwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserLike&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mjy.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where name like #&#123;str&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素</li><li>ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li><li><code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们</li></ul><h2 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h2><h3 id="6-1、日志工厂"><a href="#6-1、日志工厂" class="headerlink" title="6.1、日志工厂"></a>6.1、日志工厂</h3><p>如果一个数据库操作，出现了异常，我们需要排错，日志系统就是最好的帮手</p><p>以前：sout 、debug</p><p>现在：日志工厂</p><ul><li>SLF4J</li><li>LOG4J 【掌握】</li><li>LOG4J2</li><li>JDK_LOGGING</li><li>COMMONS_LOGGING </li><li>STDOUT_LOGGING【掌握】 </li><li>NO_LOGGING</li></ul><p>在Mybatis中具体使用哪个日志实现，在设置中设定！</p><p><strong>STDOUT_LOGGING标准日志输出</strong></p><p>在mybatis核心配置文件中，配置我们的日志</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h3><p>什么是Log4j</p><ul><li>Log4j是Apache的一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI组件</li><li>我们可以控制每一条日志的输出格式</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志生成过程</li><li>通过一个配置文件来灵活地进行配置，而不需要修改应用的代码</li><li></li></ul><ol><li><p>先导入log4j的包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--日志信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>log4j.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#控制台输出的相关设置</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.console.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">[%c]-%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#文件输出的相关文件</span></span><br><span class="line"><span class="meta">log4j.appender.file</span>=<span class="string">org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="meta">log4j.appender.file.File</span>=<span class="string">./log/mjy.log</span></span><br><span class="line"><span class="meta">log4j.appender.file.MaxFileSize</span>=<span class="string">10mb</span></span><br><span class="line"><span class="meta">log4j.appender.file.Threshold</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.file.layout.ConversionPattern</span>=<span class="string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#日志输出级别</span></span><br><span class="line"><span class="meta">log4j.logger.org.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.Statement</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.ResultSet</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.java.sql.PreparedStatement</span>=<span class="string">DEBUG</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置log4j为日志的实现</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>简单使用</strong></p><ol><li><p>在要使用Log4j的类中，导入包import org.apache.log4j.Logger</p></li><li><p>日志对象，参数为当前类的class</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(UserMapperTest.class);</span><br></pre></td></tr></table></figure></li><li><p>日志级别</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.info(<span class="string">&quot;info:进入了loggerTest&quot;</span>);</span><br><span class="line">logger.debug(<span class="string">&quot;debug:进入了loggerTest&quot;</span>);</span><br><span class="line">logger.error(<span class="string">&quot;error:进入了loggerTest&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h2><p><strong>思考：为什么要分页?</strong></p><ul><li>减少数据的处理量</li></ul><h3 id="7-1-使用Limit分页"><a href="#7-1-使用Limit分页" class="headerlink" title="7.1 使用Limit分页"></a><strong>7.1 使用Limit分页</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">语法：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit startIndex,pageSize;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">3</span>;#[<span class="number">0</span>,n]</span><br></pre></td></tr></table></figure><p>使用Mybatis实现分页，核心SQL</p><ol><li><p>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByLimit</span><span class="params">(Map&lt;String,Integer&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLimit&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">       SqlSession sqlSession=MybatisUtils.getSqlSession();</span><br><span class="line">   </span><br><span class="line">       UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">       Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;startIndex&quot;</span>,<span class="number">0</span>);</span><br><span class="line">       map.put(<span class="string">&quot;pageSize&quot;</span>,<span class="number">2</span>);</span><br><span class="line">       List&lt;User&gt; userByLimit = mapper.getUserByLimit(map);</span><br><span class="line">       <span class="keyword">for</span> (User user : userByLimit) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-2-RowBounds分页"><a href="#7-2-RowBounds分页" class="headerlink" title="7.2 RowBounds分页"></a>7.2 RowBounds分页</h3><p>不再使用SQL实现分页</p><ol><li><p>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页2</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserByRowBounds</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Mapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByRowBounds&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByRowBounds</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession=MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//RowBounds分页</span></span><br><span class="line">        RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过java代码层面实现分页</span></span><br><span class="line">        List&lt;User&gt; list = sqlSession.selectList(<span class="string">&quot;com.mjy.dao.UserMapper.getUserByRowBounds&quot;</span>,<span class="keyword">null</span>,rowBounds);</span><br><span class="line">        <span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-3分页插件"><a href="#7-3分页插件" class="headerlink" title="7.3分页插件"></a>7.3分页插件</h3><img src="/2021/08/07/MyBatis/image-20210324232643471.png" class title="image-20210324232643471"><p>网址：<a href="https://pagehelper.github.io/">https://pagehelper.github.io/</a></p><h2 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h2><h3 id="8-1使用注解开发"><a href="#8-1使用注解开发" class="headerlink" title="8.1使用注解开发"></a>8.1使用注解开发</h3><ol><li><p>注解在接口上实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>需要再核心配置文件中绑定接口</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p>本质：反射机制实现</p><p>底层：动态代理</p><h3 id="8-2-CRUD"><a href="#8-2-CRUD" class="headerlink" title="8.2 CRUD"></a>8.2 CRUD</h3><p>我们可以在工具类创建的时候实现自动提交事务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置事务的自动提交</span></span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写接口</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from user&quot;)</span><br><span class="line">    List<span class="tag">&lt;<span class="name">User</span>&gt;</span> getUserList();</span><br><span class="line"></span><br><span class="line">    //当有多个参数时需要加上@Param(&quot;&quot;)注解（对象、Map等不需要加）,sql语句中获取属性值的名称以@Param(&quot;&quot;)注解中的为准</span><br><span class="line">    @Select(&quot;select * from user where id=#&#123;id&#125;&quot;)</span><br><span class="line">    User getUserById(@Param(&quot;id&quot;)int id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into user(id,name,password) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span><br><span class="line">    int addUser(User user);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update user set name=#&#123;name&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int updateUser(User user);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from user where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int deleteUserById(@Param(&quot;id&quot;)int id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：我们必须要将接口注册绑定到我们的核心配置文件中</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--绑定接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.mjy.dao.UserMapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当存在多个配置文件需要绑定时--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/mjy/dao/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>关于@Param()注解</strong></p><ul><li>基本类型的参数或String类型，需要加上</li><li>引用类型不需要加</li><li>如果只有一个基本类型的话，可以忽略，但是建议加上</li><li>我们在SQL中引用的就是我们这里的@Param(“id”)中的属性名</li></ul><p><strong>#{} ${}的区别</strong></p><p>#{}—&gt;sql预编译，能够解决sql注入问题</p><p>${}—-&gt;存在sql注入问题，不安全</p><h2 id="9、Lombok"><a href="#9、Lombok" class="headerlink" title="9、Lombok"></a><strong>9、Lombok</strong></h2><p>使用步骤:</p><ol><li><p>在IDEA中安装Lombok插件</p></li><li><p>在IDEA中导入Lombok包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在实体类上加注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Features</span><br><span class="line"><span class="meta">@Getter</span> and <span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@FieldNameConstants</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span>, <span class="meta">@RequiredArgsConstructor</span> and <span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Log</span>, <span class="meta">@Log4j</span>, <span class="meta">@Log4j2</span>, <span class="meta">@Slf4j</span>, <span class="meta">@XSlf4j</span>, <span class="meta">@CommonsLog</span>, <span class="meta">@JBossLog</span>, <span class="meta">@Flogger</span>, <span class="meta">@CustomLog</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@SuperBuilder</span></span><br><span class="line"><span class="meta">@Singular</span></span><br><span class="line"><span class="meta">@Delegate</span></span><br><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="meta">@Accessors</span></span><br><span class="line"><span class="meta">@Wither</span></span><br><span class="line"><span class="meta">@With</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@val</span></span><br><span class="line"><span class="meta">@var</span></span><br><span class="line">experimental <span class="meta">@var</span></span><br><span class="line"><span class="meta">@UtilityClass</span></span><br></pre></td></tr></table></figure><p>@Data:无参构造、get、set、toString、hashcode、equals </p><img src="/2021/08/07/MyBatis/image-20210325160253193.png" class title="image-20210325160253193"></li></ol><p>@AllArgsConstructor:有参构造</p><p>@NoArgsConstructor：无参构造</p><img src="/2021/08/07/MyBatis/image-20210325160625609.png" class title="image-20210325160625609"><h2 id="10、多对一处理"><a href="#10、多对一处理" class="headerlink" title="10、多对一处理"></a>10、多对一处理</h2><p><strong>测试环境搭建</strong></p><ol><li>导入lombok</li><li>新建实体类Teacher,Student</li><li>建立Mapper接口</li><li>建立Mapper.xml文件</li><li>在核心配置文件中绑定注册我们的Mapper接口或者文件</li><li>测试是否能够成功</li></ol><h3 id="按照查询嵌套处理"><a href="#按照查询嵌套处理" class="headerlink" title="按照查询嵌套处理"></a>按照查询嵌套处理</h3><p>注意：应用到的类一定要有空参构造器（第二遍学习中，由于使用Lombok的AllArgsConstructor导致无空参构造器，导致排错1小时。。。）</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mjy.dao.StudentMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        1、查询所有的学生的信息</span></span><br><span class="line"><span class="comment">        2、根据查询出来的学生的tid，寻找对应的老师</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentMapper&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--复杂的属性，我们需要单独处理 对象：association 集合：collection--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentList&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentMapper&quot;</span>&gt;</span></span><br><span class="line">        select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">        select * from teacher where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照结果嵌套查询</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentMapper1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;student&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--按照结果嵌套循环--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentList1&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentMapper1&quot;</span>&gt;</span></span><br><span class="line">       select s.id sid,s.name sname,t.name tname,t.id tid</span><br><span class="line">       from student s</span><br><span class="line">                join teacher t</span><br><span class="line">                     on t.id=s.tid;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一对多</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeachers&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;teacherMapper&quot;</span>&gt;</span></span><br><span class="line">       select * from teacher</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">       select id,name from student where tid=#&#123;tid&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--复杂的属性我们需要单独处理 对象：association 集合：collection</span></span><br><span class="line"><span class="comment">   javaType=&quot;&quot;指定属性的类型</span></span><br><span class="line"><span class="comment">   集合中的泛型信息，我们使用ofType获取</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMapper&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;studentList&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudents&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>关联：association【多对一】</li><li>集合：collection 【一对多】</li><li>javaType&amp;ofType<ul><li>JavaType用来指定实体类中属性的类型</li><li>ofType用来指定映射到List或者集合中的实体类类型，泛型中的约束类型</li></ul></li></ul><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIf&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title!=null&quot;</span>&gt;</span></span><br><span class="line">        and title=#&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">        and author=#&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title!=null&quot;</span>&gt;</span></span><br><span class="line">            title=#&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">            and author=#&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title!=null&quot;</span>&gt;</span></span><br><span class="line">            title=#&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">            author=#&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose-when-otherwise-只能选择一个"><a href="#choose-when-otherwise-只能选择一个" class="headerlink" title="choose(when,otherwise):只能选择一个"></a>choose(when,otherwise):只能选择一个</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title!=null&quot;</span>&gt;</span></span><br><span class="line">                title=#&#123;title&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">                author=#&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                views=#&#123;views&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em><strong>所谓的动态SQL,本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码</strong></em></p><h3 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h3><p>有的时候，我们可能会将一些功能的部分抽取出来，方便复用</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">使用SQL标签抽取公共部分</span><br><span class="line"><span class="comment">&lt;!--SQL片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title!=null&quot;</span>&gt;</span></span><br><span class="line">        title=#&#123;title&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">        author=#&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">在需要使用的地方使用include标签引用</span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>最好基于单表来定义SQL片段</li><li>不要存在where标签</li></ul><h3 id="Foreach"><a href="#Foreach" class="headerlink" title="Foreach"></a>Foreach</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogForeach&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">            id=#&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author!=null&quot;</span>&gt;</span></span><br><span class="line">        and author=#&#123;author&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryBlogForeach</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ids&quot;</span>,list);</span><br><span class="line">    map.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;狂神说&quot;</span>);</span><br><span class="line">    List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map);</span><br><span class="line">    blogs.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了</p><p>建议：</p><ul><li>先在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可</li></ul><h2 id="13、缓存"><a href="#13、缓存" class="headerlink" title="13、缓存"></a>13、缓存</h2><h3 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h3><ol><li>什么是缓存【Cache】<ul><li>存在内存中的临时数据</li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题</li></ul></li><li>为什么使用缓存<ul><li>减少和数据库的交互次数，减少系统开销，提高系统效率</li></ul></li><li>什么样的数据能使用缓存<ul><li>经常查询且不经常改变的数据</li></ul></li></ol><h3 id="13-2、-Mybatis缓存"><a href="#13-2、-Mybatis缓存" class="headerlink" title="13.2、 Mybatis缓存"></a>13.2、 Mybatis缓存</h3><ul><li>Mybatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率</li><li>MyBatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong><ul><li>默认情况下，只有一级缓存开启。(SqlSession级别的缓存，也称为本地缓存)</li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过Cache接口来自定义二级缓存</li></ul></li></ul><h3 id="13-3、一级缓存"><a href="#13-3、一级缓存" class="headerlink" title="13.3、一级缓存"></a>13.3、一级缓存</h3><ul><li>一级缓存也叫本地缓存<ul><li>与数据库同一次会话期间查询到的数据会放在本地缓存中</li><li>以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库</li></ul></li></ul><p>测试步骤：</p><ol><li><p>开启日志 </p></li><li><p>测试在一个Session中查询两次记录</p><img src="/2021/08/07/MyBatis/image-20210327210450379.png" class title="image-20210327210450379"></li><li><p>查看日志输出</p></li></ol><p>缓存失效的情况：</p><ol><li><p>查询不同的东西</p></li><li><p>增删改操作可能会改变原来的数据，所以必定会刷新缓存</p></li><li><p>查询不同的Mapper.xml</p></li><li><p>手动清理缓存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line"></span><br><span class="line">    UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">    User userById = mapper.getUserById(<span class="number">4</span>);</span><br><span class="line">    System.out.println(userById);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        mapper.updateUser(new User(2,&quot;小婵&quot;,&quot;732418&quot;));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//手动清理缓存</span></span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">    User userById1 = mapper.getUserById(<span class="number">4</span>);</span><br><span class="line">    System.out.println(userById1);</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/07/MyBatis/image-20210327212133644.png" class title="image-20210327212133644"></li></ol><p>小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段</p><p>一级缓存就是一个Map</p><h3 id="13-4、二级缓存"><a href="#13-4、二级缓存" class="headerlink" title="13.4、二级缓存"></a>13.4、二级缓存</h3><ul><li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li><li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存</li><li>工作机制<ul><li>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</li><li>如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中</li><li>新的会话查询信息，就可以从二级缓存中获取内容</li><li>不同的mapper查出的数据都会放在自己对应的缓存（map）中</li></ul></li></ul><p>步骤</p><ol><li><p>开启全局缓存</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启全局缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在要使用二级缓存的Mapper中开启</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>也可以自定义参数</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mjy.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用二级缓存--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><ol><li><p>问题：当未自定义参数时，需要将实体类序列化！否则就会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cause: java.io.NotSerializableException: com.mjy.pojo.User</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>小结：</p><ul><li>只要开启了二级缓存，在同一个Mapper下就有效</li><li>所有的数据都会先放在一级缓存中</li><li>只有当会话提交，或者关闭才会提交到二级缓存中</li></ul><h3 id="13-6、自定义缓存-ehcache"><a href="#13-6、自定义缓存-ehcache" class="headerlink" title="13.6、自定义缓存-ehcache"></a>13.6、自定义缓存-ehcache</h3><p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存‘</p><p>要在程序中使用ehcache，先要导包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在mapper中指定使用的我们的 ehcache缓存实现</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>ehcahce.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span></span><br><span class="line"><span class="comment">       user.home – 用户主目录</span></span><br><span class="line"><span class="comment">       user.dir  – 用户当前工作目录</span></span><br><span class="line"><span class="comment">       java.io.tmpdir – 默认临时文件路径</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir/Tmp_EhCache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      name:缓存名称。</span></span><br><span class="line"><span class="comment">      maxElementsInMemory:缓存最大数目</span></span><br><span class="line"><span class="comment">      maxElementsOnDisk：硬盘最大缓存个数。</span></span><br><span class="line"><span class="comment">      eternal:对象是否永久有效，一但设置了，timeout将不起作用。</span></span><br><span class="line"><span class="comment">      overflowToDisk:是否保存到磁盘，当系统当机时</span></span><br><span class="line"><span class="comment">      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。</span></span><br><span class="line"><span class="comment">      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。</span></span><br><span class="line"><span class="comment">      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.</span></span><br><span class="line"><span class="comment">      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。</span></span><br><span class="line"><span class="comment">      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。</span></span><br><span class="line"><span class="comment">      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。</span></span><br><span class="line"><span class="comment">      clearOnFlush：内存数量最大时是否清除。</span></span><br><span class="line"><span class="comment">      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">      FIFO，first in first out，这个是大家最熟的，先进先出。</span></span><br><span class="line"><span class="comment">      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。</span></span><br><span class="line"><span class="comment">      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;259200&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;cloud_user&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;5000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;1800&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h5 id="网络编程的目的："><a href="#网络编程的目的：" class="headerlink" title="网络编程的目的："></a>网络编程的目的：</h5><p>传播交流信息，数据交换，通信</p><p>Javaweb：网页编程 B/S</p><p>网络编程：TCP/IP  C/S</p><h4 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h4><img src="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20210805234534048.png" class title="image-20210805234534048"><p><strong>两个要点：</strong></p><ol><li>网络编程的两个主要问题<ul><li>如何准确的定位到网络上的一台或多台主机</li><li>找到主机之后如何进行通信</li></ul></li><li>网络编程中的要素<ul><li>IP和端口号</li><li>网络通信协议</li></ul></li></ol><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>ip地址：InetAddress</p><ul><li><p>唯一定位一台网络上计算机</p></li><li><p>127.0.0.1：本机：localhost</p></li><li><p>ip地址的分类</p><ul><li>IPV4/IPV6<ul><li>IPV4 ：127.0.0.1，四个字节组成，42亿；30亿都在北美，亚洲4亿。2011年用尽</li><li>IPV6：128位。8个无符号整数</li></ul></li><li>公网、私网<ul><li>ABCD类地址</li><li>192.168.xxx.xxx，专门给组织内部使用的</li></ul></li></ul></li></ul><h4 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//查询本机地址</span></span><br><span class="line">            InetAddress inet=InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inet);</span><br><span class="line">            InetAddress localhost = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(localhost);</span><br><span class="line">            InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(localHost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//查询网站ip地址</span></span><br><span class="line">            InetAddress baidu = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(baidu);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//常用方法</span></span><br><span class="line">            System.out.println(baidu.getCanonicalHostName()); <span class="comment">//规范的名字</span></span><br><span class="line">            System.out.println(baidu.getHostAddress()); <span class="comment">//ip</span></span><br><span class="line">            System.out.println(baidu.getHostName()); <span class="comment">//域名，或者自己电脑的名字</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口表示计算机上的一个程序的进程</p><ul><li><p>不同的进程有不同的端口号</p></li><li><p>端口范围：0~65535</p></li><li><p>TCP,UDP：65535*2  单个协议下，端口号不能冲突</p></li><li><p>端口分类</p><ul><li>共有端口（尽量不要去占用）<ul><li>HTTP：80</li><li>HTTPS：443</li><li>FTP：21</li><li>Telent：23</li></ul></li><li>程序注册端口：1024~49151,分配用户或者程序<ul><li>Tomcat：8080</li><li>MySQL：3306</li><li>Oracle：1521</li></ul></li><li>动态、私有：49152~65535</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -ano <span class="comment">#查看所有的端口</span></span><br><span class="line">netstat -ano | findstr <span class="string">&quot;端口号&quot;</span> <span class="comment">#查找指定端口</span></span><br><span class="line">tasklist | find <span class="string">&quot;端口号&quot;</span> <span class="comment">#查看该端口的进程</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p><strong>TCP/IP协议簇：实际上是一组协议</strong></p><p>重要的协议：</p><ul><li>TCP：用户传输协议</li><li>UDP：用户数据报协议</li><li>IP：网络互连协议</li></ul><p><strong>TCP与UDP的对比</strong></p><p>TCP：</p><ul><li>较安全，稳定</li><li>建立连接，需要三次握手、四次挥手</li><li>有客户端和服务端</li><li>传输完成，释放连接，效率低</li></ul><p>UDP：</p><ul><li>不需要建立连接，不安全，不稳定</li><li>客户端和服务端没有明确的界限</li><li>只需要发送，而不需要考虑是否接收到</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>三次握手、四次挥手</p><p>三次握手：</p><img src="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/61d3cf1ecdec434aa1fa677f7037f703.png" class title="在这里插入图片描述"><p>四次挥手</p><img src="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1cc32b58d2794cfda544776c957390c2.png" class title="在这里插入图片描述"><p><strong>三次握手：</strong></p><p>TCP建立连接的过程我们称之为三次握手</p><ul><li><p>第一次握手</p><p>PC1使用一个随机的端口号向PC2的80端口发送连接请求，此过程的典型标志为SYN控制位为1，其它五位为0</p></li><li><p>第二次握手</p><p>PC2收到PC1的请求，向PC1回复确认信息</p><p>并且，PC2也向PC1发送建立连接请求</p></li><li><p>第三次握手</p><p>PC1收到PC2回复，也要向PC2恢复一个确认信息</p></li></ul><p><strong>四次挥手：</strong></p><p>TCP断开连接的过程分为4步，称为四次挥手</p><p>（1）服务器向客户端发送FIN，ACK为1的TCP报文段</p><p>（2）客户端向服务端返回ACK为1的TCP报文段</p><p>（3）客户端向服务器发送FIN,ACK为1的TCP报文段</p><p>（4）服务器向客户端返回ACK为1的TCP报文段</p><p>在TCP断开连接的过程中，有一个半关闭的概念。TCP一段可以中止发送数据，但是仍可以接收数据，称之为半关闭</p><p>（1）客户端发送FIN，半关闭了这个连接。服务器发送ACK接受半关闭</p><p>（2）服务器继续发送数据，而客户端只发送ACK确认，不发送任何数据</p><p>（3）当服务器所有数据传输完毕，就发送FIN报文段，客户再发送ACK报文段，就关闭了TCP连接</p><h3 id="面试题延伸："><a href="#面试题延伸：" class="headerlink" title="面试题延伸："></a>面试题延伸：</h3><h4 id="1、三次握手和四次挥手的本质是什么？"><a href="#1、三次握手和四次挥手的本质是什么？" class="headerlink" title="1、三次握手和四次挥手的本质是什么？"></a>1、三次握手和四次挥手的本质是什么？</h4><p>三次握手的本质是确认通信双方收发数据的能力 。<br>四次挥手的目的是关闭一个连接 。</p><h4 id="2、为什么TCP连接的时候是3次？2次不可以吗？"><a href="#2、为什么TCP连接的时候是3次？2次不可以吗？" class="headerlink" title="2、为什么TCP连接的时候是3次？2次不可以吗？"></a>2、为什么TCP连接的时候是3次？2次不可以吗？</h4><p>因为需要考虑连接时丢包的问题，如果只握手2次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。<br>如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认ack报文丢失，服务端在一段时间内没有收到确认ack报文的话就会重新进行第二次握手，也就是服务端会重发SYN报文段，客户端收到重发的报文段后会再次给服务端发送确认ack报文。</p><img src="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/a824c1a1d2a34897b11f6dee57b07c81.png" class title="在这里插入图片描述"><img src="/2021/08/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8d333be52c2347c89be5960f8cd69c7e.png" class title="在这里插入图片描述"><h4 id="3、为什么TCP连接的时候是3次，关闭的时候却是4次？"><a href="#3、为什么TCP连接的时候是3次，关闭的时候却是4次？" class="headerlink" title="3、为什么TCP连接的时候是3次，关闭的时候却是4次？"></a>3、为什么TCP连接的时候是3次，关闭的时候却是4次？</h4><p>因为只有在客户端和服务端都没有数据要发送的时候才能断开TCP。而客户端发出FIN报文时只能保证客户端没有数据发了，服务端还有没有数据发客户端是不知道的。而服务端收到客户端的FIN报文后只能先回复客户端一个确认报文来告诉客户端我服务端已经收到你的FIN报文了，但我服务端还有一些数据没发完，等这些数据发完了服务端才能给客户端发FIN报文(所以不能一次性将确认报文和FIN报文发给客户端，就是这里多出来了一次)。</p><h4 id="4、三、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？即为什么客户端在TIME-WAIT阶段要等2MSL？"><a href="#4、三、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？即为什么客户端在TIME-WAIT阶段要等2MSL？" class="headerlink" title="4、三、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？即为什么客户端在TIME-WAIT阶段要等2MSL？"></a>4、三、为什么客户端发出第四次挥手的确认报文后要等2MSL的时间才能释放TCP连接？即为什么客户端在TIME-WAIT阶段要等2MSL？</h4><p>MSL 指的是 Maximum Segment Lifetime：一段 TCP 报文在传输过程中的最大生命周期。<br>2MSL 即是服务器端发出为 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。<br>这里同样是要考虑丢包的问题，如果第四次挥手的报文丢失，服务端没收到确认ack报文就会重发第三次挥手的报文，这样报文一去一回最长时间就是2MSL，所以需要等这么长时间来确认服务端确实已经收到了。</p><h4 id="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#5、如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="5、如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>5、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p>TCP实现聊天：</p><p>client:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.TCPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 15:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//知道服务器的地址，端口号</span></span><br><span class="line">            InetAddress serverIp = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">9999</span>;</span><br><span class="line">            <span class="comment">//创建一个socket连接</span></span><br><span class="line">             socket= <span class="keyword">new</span> Socket(serverIp, port);</span><br><span class="line">            <span class="comment">//发送消息 IO流</span></span><br><span class="line">             os= socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            os.write(<span class="string">&quot;你好，欢迎学习Java网络编程&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(os!= <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.TCPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 15:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket server=<span class="keyword">null</span>;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//有一个地址</span></span><br><span class="line">            server= <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待客户端连接</span></span><br><span class="line">            socket= server.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取客户端的消息</span></span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//管道流</span></span><br><span class="line">            baos= <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取内容</span></span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(server!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    server.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TCP上传文件"><a href="#TCP上传文件" class="headerlink" title="TCP上传文件"></a>TCP上传文件</h4><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.TCPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPUploadFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        FileInputStream fis=<span class="keyword">null</span>;</span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InetAddress serverIp = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">            socket= <span class="keyword">new</span> Socket(serverIp,port);</span><br><span class="line"></span><br><span class="line">            fis= <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/main/resources/thYRKQ7U7R.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            os= socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知服务端，已经传输完毕</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line">            bos= <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len1=is.read(buffer1))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(buffer1,<span class="number">0</span>,len1);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(bos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(os!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.TCPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPDownload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket serverSocket=<span class="keyword">null</span>;</span><br><span class="line">        Socket socket=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket= <span class="keyword">new</span> ServerSocket(<span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">            socket= serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/main/resources/img.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在传输完毕后，向客户端发送消息</span></span><br><span class="line">            os= socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;接受完毕，断开连接&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(os!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>发送消息</p><p>发送端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.UDPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 17:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立一个socket</span></span><br><span class="line">            socket= <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送内容</span></span><br><span class="line">            String msg=<span class="string">&quot;服务器，你好&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送给谁</span></span><br><span class="line">            InetAddress address = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//数据，数据的长度起始，要发送给谁</span></span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(msg.getBytes(), <span class="number">0</span>, msg.getBytes().length, address, port);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送包</span></span><br><span class="line">            socket.send(packet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.UDPDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//开放端口</span></span><br><span class="line">            socket= <span class="keyword">new</span> DatagramSocket(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//接收数据包</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//阻塞接收</span></span><br><span class="line">            socket.receive(packet);</span><br><span class="line"></span><br><span class="line">            System.out.println(packet.getAddress().getHostAddress());</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>, packet.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注：</strong>UDP中不存在客户端和服务端的区别，上面代码只是为了凸显出区别</p><h4 id="实现向某个端口发送消息"><a href="#实现向某个端口发送消息" class="headerlink" title="实现向某个端口发送消息"></a>实现向某个端口发送消息</h4><p>发送端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 23:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpChatRoom1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket= <span class="keyword">new</span> DatagramSocket(<span class="number">9001</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取输入数据</span></span><br><span class="line">            br= <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                String data = br.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] datas = data.getBytes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(datas,<span class="number">0</span>,datas.length,InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>),<span class="number">9002</span>);</span><br><span class="line"></span><br><span class="line">                socket.send(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(data))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(br!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-06 23:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UdpChatRoom2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket= <span class="keyword">new</span> DatagramSocket(<span class="number">9002</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">//接收数据</span></span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length, InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9001</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//阻塞接收</span></span><br><span class="line">                socket.receive(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                String words = <span class="keyword">new</span> String(data, <span class="number">0</span>, data.length);</span><br><span class="line">                String check = <span class="keyword">new</span> String(data, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">                System.out.println(words);</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(check))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在线聊天：两个人既可以是接收方也可以是发送方（多线程）"><a href="#在线聊天：两个人既可以是接收方也可以是发送方（多线程）" class="headerlink" title="在线聊天：两个人既可以是接收方也可以是发送方（多线程）"></a>在线聊天：两个人既可以是接收方也可以是发送方（多线程）</h4><p>TalkeSend.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-07 0:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkSend</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromPort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toPort;</span><br><span class="line">    <span class="keyword">private</span> String sendIp;</span><br><span class="line">    <span class="keyword">private</span> BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkSend</span><span class="params">(<span class="keyword">int</span> fromPort,<span class="keyword">int</span> toPort,String sendIp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket=<span class="keyword">new</span> DatagramSocket(fromPort);</span><br><span class="line">            <span class="keyword">this</span>.fromPort=fromPort;</span><br><span class="line">            <span class="keyword">this</span>.toPort=toPort;</span><br><span class="line">            <span class="keyword">this</span>.sendIp=sendIp;</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String data = br.readLine();</span><br><span class="line">                <span class="keyword">byte</span>[] info = data.getBytes();</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(info, <span class="number">0</span>, info.length,<span class="keyword">new</span> InetSocketAddress(sendIp,toPort));</span><br><span class="line"></span><br><span class="line">                socket.send(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(data))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TalkReceive.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.chat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-07 0:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TalkReceive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket socket=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String receiveIp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> receivePort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TalkReceive</span><span class="params">(String receiveIp, <span class="keyword">int</span> receivePort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.receiveIp = receiveIp;</span><br><span class="line">            <span class="keyword">this</span>.receivePort = receivePort;</span><br><span class="line">            socket=<span class="keyword">new</span> DatagramSocket(<span class="keyword">this</span>.receivePort);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line"></span><br><span class="line">                socket.receive(packet);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] data = packet.getData();</span><br><span class="line"></span><br><span class="line">                String info = <span class="keyword">new</span> String(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">                String check = <span class="keyword">new</span> String(data, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">                String hostName = packet.getAddress().getHostName();</span><br><span class="line"></span><br><span class="line">                System.out.println(hostName+<span class="string">&quot;:&quot;</span>+info);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equals(check))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Talker1.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Talker1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">9999</span>,<span class="number">9001</span>,<span class="string">&quot;localhost&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="string">&quot;localhost&quot;</span>,<span class="number">9003</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Talker2.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Talker2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkSend(<span class="number">9002</span>,<span class="number">9003</span>,<span class="string">&quot;localhost&quot;</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TalkReceive(<span class="string">&quot;localhost&quot;</span>,<span class="number">9001</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="URL：统一资源定位符"><a href="#URL：统一资源定位符" class="headerlink" title="URL：统一资源定位符"></a>URL：统一资源定位符</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/helloworld/index.jsp?username=zhangsan&amp;password=1562&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取协议</span></span><br><span class="line">            System.out.println(url.getProtocol());</span><br><span class="line">            <span class="comment">//主机ip</span></span><br><span class="line">            System.out.println(url.getHost());</span><br><span class="line">            <span class="comment">//主机端口</span></span><br><span class="line">            System.out.println(url.getPort());</span><br><span class="line">            <span class="comment">//文件</span></span><br><span class="line">            System.out.println(url.getPath());</span><br><span class="line">            <span class="comment">//全路径</span></span><br><span class="line">            System.out.println(url.getFile());</span><br><span class="line">            <span class="comment">//参数</span></span><br><span class="line">            System.out.println(url.getQuery());</span><br><span class="line">            System.out.println(url.getUserInfo());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="用URL下载资源"><a href="#用URL下载资源" class="headerlink" title="用URL下载资源"></a>用URL下载资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mjy.url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-07 14:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlDownLoad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HttpURLConnection urlConnection=<span class="keyword">null</span>;</span><br><span class="line">        InputStream is=<span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/netsource/SecurityFile.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection= (HttpURLConnection)url.openConnection();</span><br><span class="line"></span><br><span class="line">            String file = url.getFile();</span><br><span class="line">            String fileName=file.substring(file.lastIndexOf(<span class="string">&quot;/&quot;</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            is= urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">            fos= <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/main/resources/loadsource/&quot;</span> + fileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(is!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(urlConnection!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建cdh</title>
      <link href="/2021/08/03/%E6%90%AD%E5%BB%BAcdh/"/>
      <url>/2021/08/03/%E6%90%AD%E5%BB%BAcdh/</url>
      
        <content type="html"><![CDATA[<h1 id="Centos7部署CDH6-3-2集群"><a href="#Centos7部署CDH6-3-2集群" class="headerlink" title="Centos7部署CDH6.3.2集群"></a>Centos7部署CDH6.3.2集群</h1><h3 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h3><p>官方文档：<a href="https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_requirements_supported_versions.html">https://docs.cloudera.com/documentation/enterprise/6/release-notes/topics/rg_requirements_supported_versions.html</a></p><h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><h3 id="1、硬件"><a href="#1、硬件" class="headerlink" title="1、硬件"></a>1、硬件</h3><p>Linux发行版本：CentOS 7.6</p><p>查看Linux系统版本命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a <span class="comment">#适用于所有的Linux发行版，包括RedHat、SUSE、Debian…等发行版。</span></span><br><span class="line">cat /etc/redhat-release <span class="comment">#只适合Redhat系的Linux</span></span><br><span class="line">cat /etc/issue <span class="comment">#适用于所有的Linux发行版</span></span><br></pre></td></tr></table></figure><p>查看Linux内核版本命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /proc/version</span><br><span class="line">uname -a</span><br></pre></td></tr></table></figure><p>查看内存大小</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m <span class="comment">#按M显示</span></span><br><span class="line">free -g <span class="comment">#按G显示</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>公网IP</th><th>内网IP</th><th>Host</th><th>CPU</th><th>Memory</th><th>DIsk</th></tr></thead><tbody><tr><td>47.97.81.73</td><td>172.16.3.40</td><td>bigdata01</td><td>2核</td><td>16G</td><td>100G</td></tr><tr><td>101.37.78.42</td><td>172.16.3.39</td><td>bigdata02</td><td>2核</td><td>8G</td><td>100G</td></tr><tr><td>47.97.81.53</td><td>172.16.3.41</td><td>bigdata03</td><td>2核</td><td>8G</td><td>100G</td></tr></tbody></table><h3 id="2、安装包下载"><a href="#2、安装包下载" class="headerlink" title="2、安装包下载"></a>2、安装包下载</h3><p><strong>CM6.3.1</strong></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-daemons-6.3.1-1466458.el7.x86_64.rpm</a></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-6.3.1-1466458.el7.x86_64.rpm</a></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-agent-6.3.1-1466458.el7.x86_64.rpm</a></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-db-2-6.3.1-1466458.el7.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/cloudera-manager-server-db-2-6.3.1-1466458.el7.x86_64.rpm</a></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/enterprise-debuginfo-6.3.1-1466458.el7.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/enterprise-debuginfo-6.3.1-1466458.el7.x86_64.rpm</a></p><p><a href="https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/oracle-j2sdk1.8-1.8.0+update181-1.x86_64.rpm">https://archive.cloudera.com/cm6/6.3.1/redhat7/yum/RPMS/x86_64/oracle-j2sdk1.8-1.8.0+update181-1.x86_64.rpm</a></p><p><strong>CDH6.3.2  Parcel</strong></p><p><a href="https://archive.cloudera.com/cdh6/6.3.2/parcels/CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel">https://archive.cloudera.com/cdh6/6.3.2/parcels/CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel</a></p><p><a href="https://archive.cloudera.com/cdh6/6.3.2/parcels/CDH-6.3.2-1.cdh6.3.2.p0.1605554-el6.parcel.sha256">https://archive.cloudera.com/cdh6/6.3.2/parcels/CDH-6.3.2-1.cdh6.3.2.p0.1605554-el6.parcel.sha256</a></p><p><a href="https://archive.cloudera.com/cdh6/6.3.2/parcels/manifest.json">https://archive.cloudera.com/cdh6/6.3.2/parcels/manifest.json</a></p><p> <strong>MySQL  JDBC  jar</strong></p><p><a href="http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar">http://central.maven.org/maven2/mysql/mysql-connector-java/5.1.46/mysql-connector-java-5.1.46.jar</a></p><p><strong>ext-2.2.zip</strong>解决oozie web UI报错问题</p><p><a href="http://archive.cloudera.com/gplextras/misc/ext-2.2.zip">http://archive.cloudera.com/gplextras/misc/ext-2.2.zip</a></p><p>下载后上传cm6.3.1和cdh6.3.2这两个目录到hadoop01主节点的/root（可自己选择）目录</p><h3 id="三、环境准备"><a href="#三、环境准备" class="headerlink" title="三、环境准备"></a>三、环境准备</h3><p>所有节点先安装一些实用的小工具</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.安装vim编辑器</span></span><br><span class="line">yum install -y vim</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.安装lrzsz文件传输工具</span></span><br><span class="line">yum -y install lrzsz</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.安装wget文件下载工具</span></span><br><span class="line">yum -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.安装netstat，查看端口监听状况：   netstat -ntlp | grep 端口号</span></span><br><span class="line">yum -y install net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.下载unzip解压工具，解压命令：  uzip 压缩包.zip -d 解压目录</span></span><br><span class="line">yum install -y unzip zip</span><br></pre></td></tr></table></figure><h3 id="1、关闭防火墙"><a href="#1、关闭防火墙" class="headerlink" title="1、关闭防火墙"></a>1、关闭防火墙</h3><p><strong>所有节点都需要执行</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.查看防火墙状态</span></span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.临时关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.永久关闭防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.临时开启防火墙</span></span><br><span class="line"><span class="comment">#systemctl start firewalld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.开机启用防火墙</span></span><br><span class="line"><span class="comment">#systemctl enable firewalld</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#临时关闭selinux</span></span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#永久关闭selinux</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line"><span class="comment">#将SELINUX=enforcing改为</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看selinux状态</span></span><br><span class="line">getenforce 0</span><br></pre></td></tr></table></figure><h4 id="2、修改主机名"><a href="#2、修改主机名" class="headerlink" title="2、修改主机名"></a>2、修改主机名</h4><p><strong>所有节点都要执行，修改后需要重启节点</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/hostname</span><br><span class="line"><span class="comment">#分别改名为</span></span><br><span class="line">bigdata01.baicdt.com</span><br><span class="line">bigdata02.baicdt.com</span><br><span class="line">bigdata03.baicdt.com</span><br></pre></td></tr></table></figure><h4 id="3、配置hosts文件"><a href="#3、配置hosts文件" class="headerlink" title="3、配置hosts文件"></a>3、配置hosts文件</h4><p><code>vim /etc/hosts</code></p><p><strong>所有节点都要配置</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">172.16.3.40 bigdata01.baicdt.com        bigdata01</span><br><span class="line">172.16.3.41 bigdata03.baicdt.com        bigdata03</span><br><span class="line">172.16.3.39 bigdata02.baicdt.com        bigdata02</span><br></pre></td></tr></table></figure><h4 id="4、配置免密登录"><a href="#4、配置免密登录" class="headerlink" title="4、配置免密登录"></a>4、配置免密登录</h4><p><em><strong>第一步：三台节点生成公钥与私钥</strong></em></p><p>在三台机器执行以下命令，生成公钥与私钥</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#执行下面的命令之后，要连续按三个回车</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p><em><strong>第二步：拷贝公钥到同一台节点</strong></em></p><p>三台机器将拷贝公钥到第一台服务器，三台服务器执行命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-copy-id hadoop01</span><br></pre></td></tr></table></figure><p><em><strong>第三步：复制第一台服务器的认证到其他服务器</strong></em></p><p>将第一台机器的公钥拷贝到其他机器上，在第一台机器上面执行以下命令</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scp /root/.ssh/authorized_keys hadoop02:/root/.ssh</span><br><span class="line">scp /root/.ssh/authorized_keys hadoop03:/root/.ssh</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line">ssh-copy-id root@xxx</span><br></pre></td></tr></table></figure><p>###5、设置时间同步</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看时区</span></span><br><span class="line">date-</span><br><span class="line"><span class="comment">#设置时区为Asia/Shanghai</span></span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否安装了ntpd的服务</span></span><br><span class="line">rpm -qa  | grep  ntpd</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果没有安装,可以进行在线安装</span></span><br><span class="line">yum -y install ntp</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动ntpd的服务</span></span><br><span class="line">service  ntpd  start</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置ntpd的服务开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> ntpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看ntpd的服务是否启动</span></span><br><span class="line">service  ntpd  status</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置定时任务</span></span><br><span class="line"><span class="comment">#与阿里云服务器进行时钟同步</span></span><br><span class="line">crontab  -e</span><br><span class="line"><span class="comment">#设置的内容如下</span></span><br><span class="line">*/1 * * * * /usr/sbin/ntpdate -u ntp4.aliyun.com;</span><br></pre></td></tr></table></figure><p>设置成功后会一直出现<code>You have new mail in /var/spool/mail/root</code>的邮件提示，可使用下面命令关闭邮件提示</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;unset MAILCHECK&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="6、主节点bigdata01部署MySQL5-7"><a href="#6、主节点bigdata01部署MySQL5-7" class="headerlink" title="6、主节点bigdata01部署MySQL5.7"></a>6、主节点bigdata01部署MySQL5.7</h3><h4 id="第一步：彻底卸载系统原装的MySQL"><a href="#第一步：彻底卸载系统原装的MySQL" class="headerlink" title="第一步：彻底卸载系统原装的MySQL"></a>第一步：彻底卸载系统原装的MySQL</h4><p>1.使用以下命令查看当前安装mysql情况，查找以前是否装有mysql</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -qa|grep -i mysql</span><br></pre></td></tr></table></figure><p>2.如果查询到已安装mysql需停止mysql服务并删除之前安装的mysql</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#停止mysql服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除软件命令</span></span><br><span class="line">rpm -e –nodeps 包名</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果上面命令提示依赖包错误，则使用以下命令尝试：</span></span><br><span class="line">rpm -ev 包名 --nodeps</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果还报错：error: %preun(xxxxxx) scriptlet failed, exit status 1，则用以下命令尝试：</span></span><br><span class="line">rpm -e --noscripts 包名</span><br><span class="line"></span><br><span class="line"><span class="comment">#最终再使用rpm -qa|grep -i mysql命令，查询不到结果则证明mysql已卸载</span></span><br></pre></td></tr></table></figure><p>3.查找之前老版本mysql的目录、并且删除老版本mysql的文件和库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找卸载残留的mysql的目录</span></span><br><span class="line">find / -name mysql    <span class="comment">#然后使用 rm -rf 将查询到的目录全部删除</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除老版本mysql的配置文件</span></span><br><span class="line">rm -rf /etc/my.cnf</span><br><span class="line">rm -rf /etc/my.cnf.d</span><br></pre></td></tr></table></figure><h4 id="第二步：yum源设置为阿里源"><a href="#第二步：yum源设置为阿里源" class="headerlink" title="第二步：yum源设置为阿里源"></a>第二步：yum源设置为阿里源</h4><p>使用阿里的镜像源安装MySQL时下载速度比较快</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.备份原镜像文件，便于后期恢复</span></span><br><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.下载阿里云的CentOS-Base.repo 到/etc/yum.repos.d/</span></span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#3. 清除缓存</span></span><br><span class="line">yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment">#4. 生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h4 id="第三步：下载配置MySQL的rpm安装包"><a href="#第三步：下载配置MySQL的rpm安装包" class="headerlink" title="第三步：下载配置MySQL的rpm安装包"></a>第三步：下载配置MySQL的rpm安装包</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /baicdt/softwares/mysql_rpm</span><br><span class="line"><span class="built_in">cd</span> /baicdt/softwares/mysql_rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里下载的是5.7的版本</span></span><br><span class="line"><span class="comment">#下载并安装MySQL官方的 Yum Repository</span></span><br><span class="line">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">##2.安装mysql源</span></span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装MySQL</span></span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><h4 id="第四步：启动mysql服务"><a href="#第四步：启动mysql服务" class="headerlink" title="第四步：启动mysql服务"></a>第四步：启动mysql服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.临时启动mysql服务</span></span><br><span class="line">systemctl start mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.开机启动mysql服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.查看MySQL的启动状态</span></span><br><span class="line">systemctl status mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.查看mysql进程是否正常开启</span></span><br><span class="line">ps -le | grep mysqld</span><br></pre></td></tr></table></figure><h4 id="第五步：修改mysql中root本地登录密码"><a href="#第五步：修改mysql中root本地登录密码" class="headerlink" title="第五步：修改mysql中root本地登录密码"></a>第五步：修改mysql中root本地登录密码</h4><p>mysql安装完成之后，在<code>/var/log/mysqld.log</code>文件中给root生成了一个默认密码。通过以下命令找到密码：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/<span class="built_in">log</span>/mysqld.log</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 登录MySQL，使用刚才找到的密码</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">-- 修改root用户密码（二选一）</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;Wsygzgr_2020&#x27;</span>;</span><br></pre></td></tr></table></figure><p> 这里有个问题，新密码设置的时候如果设置的过于简单会报错：</p><img src="/2021/08/03/%E6%90%AD%E5%BB%BAcdh/image-20210803172929405.png" class title="image-20210803172929405"><p> MySQL完整的初始密码规则可以通过如下命令查看：</p><p><code>show variables like &#39;%validate_password%&#39;;</code></p><img src="/2021/08/03/%E6%90%AD%E5%BB%BAcdh/image-20210803173314576.png" class title="image-20210803173314576"><p>可以修改里面的值来修改密码策略</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_policy=0;</span><br><span class="line">mysql&gt; <span class="built_in">set</span> global validate_password_length=1;</span><br></pre></td></tr></table></figure><p>但此时还有一个问题，就是因为安装了Yum Repository，以后每次yum操作都会自动更新，需要把这个卸载掉：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y remove mysql57-community-release-el7-10.noarch</span><br></pre></td></tr></table></figure><h4 id="第六步：修改mysql配置文件"><a href="#第六步：修改mysql配置文件" class="headerlink" title="第六步：修改mysql配置文件"></a>第六步：修改mysql配置文件</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf   </span><br></pre></td></tr></table></figure><p>在配置文件中添加下面的内容：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#因为服务器是测试环境，为了方便记mysql密码，关闭了密码策略。如果是生产环境，则不建议修改密码策略</span></span><br><span class="line">validate_password=off</span><br><span class="line"></span><br><span class="line">character_set_server=utf8</span><br><span class="line">init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br></pre></td></tr></table></figure><p>重新启动mysql服务使配置生效：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新设置mysql密码为123456</span></span><br><span class="line">mysql -u root -pWsygzgr_2020</span><br></pre></td></tr></table></figure><p>修改root用户密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>MySQL默认配置文件路径：</p><ul><li>配置文件：   /etc/my.cnf</li><li>日志文件：   /var/log//var/log/mysqld.log</li><li>服务启动脚本： /usr/lib/systemd/system/mysqld.service</li><li>socket文件：  /var/run/mysqld/mysqld.pid</li></ul><h4 id="第七步：允许root用户远程登录"><a href="#第七步：允许root用户远程登录" class="headerlink" title="第七步：允许root用户远程登录"></a>第七步：允许root用户远程登录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;123456&#x27;</span> WITH GRANT OPTION;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>以下内容了解</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-- 指定特定的IP，开启root用户远程连接</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;指定的IP&#x27;</span> IDENTIFIED BY <span class="string">&#x27;root用户的密码&#x27;</span> WITH GRANT OPTION;</span><br><span class="line">-- 一般为了安全起见，会创建专用的远程访问用户</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;dadeity&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;daDeity@163.com&#x27;</span> WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h4 id="第八步：创建CDH源数据库、用户、服务的数据库"><a href="#第八步：创建CDH源数据库、用户、服务的数据库" class="headerlink" title="第八步：创建CDH源数据库、用户、服务的数据库"></a>第八步：创建CDH源数据库、用户、服务的数据库</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE scm DEFAULT CHARACTER SET utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;scm&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;scm&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON scm.* TO <span class="string">&#x27;scm&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;scm&#x27;</span>; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;scm&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;scm&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE amon DEFAULT CHARACTER SET utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;amon&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;amon&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON amon.* TO <span class="string">&#x27;amon&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;amon&#x27;</span>; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;amon&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;amon&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE hive DEFAULT CHARACTER SET utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;hive&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;hive&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON hive.* TO <span class="string">&#x27;hive&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;hive&#x27;</span>; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;hive&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;hive&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE hue DEFAULT CHARACTER SET utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;hue&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;hue&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON hue.* TO <span class="string">&#x27;hue&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;hue&#x27;</span>; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;hue&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;hue&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">CREATE DATABASE oozie DEFAULT CHARACTER SET utf8;</span><br><span class="line">CREATE USER <span class="string">&#x27;oozie&#x27;</span>@<span class="string">&#x27;%&#x27;</span>IDENTIFIED BY <span class="string">&#x27;oozie&#x27;</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON oozie.* TO <span class="string">&#x27;oozie&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;oozie&#x27;</span>; </span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO <span class="string">&#x27;oozie&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;oozie&#x27;</span> WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">-- 刷新mysql的权限列表 </span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="7、创建本地YUM仓库"><a href="#7、创建本地YUM仓库" class="headerlink" title="7、创建本地YUM仓库"></a>7、创建本地YUM仓库</h3><p>确保已经把cm6.3.1、cdh6.3.2、mysql-connector-java-5.1.46.jar和ext-2.2.zip已经上传到了bigdata01服务器的/root(写自己的)目录下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y createrepo</span><br><span class="line"><span class="built_in">cd</span> /root/cm6.3.1/</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意：下面的命令最后带一个点，最后会生成一个repodata目录</span></span><br><span class="line">createrepo .</span><br></pre></td></tr></table></figure><p><strong>配置Web服务器</strong></p><p>将cdh6.3.2目录和cm6.3.1目录 移动到/var/www/html目录下, 使得用户可以通过HTTP访问这些rpm包。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在bigdata01服务器下操作</span></span><br><span class="line"><span class="built_in">cd</span> /root/cdh6.3.2</span><br><span class="line">mv CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel.sha256 CDH-6.3.2-1.cdh6.3.2.p0.1605554-el7.parcel.sha</span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">mkdir -p /var/www/html</span><br><span class="line">mv cdh6.3.2 /var/www/html</span><br><span class="line">mv cm6.3.1 /var/www/html</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装httpd服务</span></span><br><span class="line">yum install -y httpd</span><br><span class="line"><span class="comment">#启动httpd服务</span></span><br><span class="line">systemctl start httpd</span><br><span class="line"><span class="comment">#设置httpd服务开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br><span class="line"><span class="comment">#查看httpd服务是否启动</span></span><br><span class="line">ps -ef | grep httpd</span><br><span class="line"></span><br><span class="line">vim /etc/yum.repos.d/os.repo</span><br><span class="line"><span class="comment">#以下为文件内容</span></span><br><span class="line">[osrepo]</span><br><span class="line">name=os_repo</span><br><span class="line">baseurl=http://hadoop01.baicdt.com/cm6.3.1</span><br><span class="line">enabled=<span class="literal">true</span></span><br><span class="line">gpgcheck=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将os.repo文件copy到另外两台服务器上</span></span><br><span class="line"><span class="comment">#因为默认端口为22,所以需要指定端口号</span></span><br><span class="line">scp -P 9122 os.repo bigdata01:/etc/yum.repos.d/os.repo</span><br><span class="line">scp -P 9122 os.repo bigdata02:/etc/yum.repos.d/os.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#所有服务器都执行</span></span><br><span class="line">yum repolist</span><br><span class="line"></span><br><span class="line"><span class="comment">#hadoop01主节点执行</span></span><br><span class="line">    vim /etc/httpd/conf/httpd.conf</span><br><span class="line"><span class="comment">#在&lt;IfModule mime_module&gt;中修改以下内容</span></span><br><span class="line"><span class="comment">#把第284行的 AddType application/x-gzip .gz .tgz 修改为: </span></span><br><span class="line">AddType application/x-gzip .gz .tgz .parcel</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启httpd服务 </span></span><br><span class="line">systemctl restart httpd</span><br></pre></td></tr></table></figure><p>经过以上配置，下面网址可正常访问</p><p><a href="http://bigdata01.baicdt.com/cdh6.3.2/">http://bigdata01.baicdt.com/cdh6.3.2/</a><br><a href="http://bigdata01.baicdt.com/cm6.3.1/">http://bigdata01.baicdt.com/cm6.3.1/</a></p><h3 id="8、所有服务器安装JDK"><a href="#8、所有服务器安装JDK" class="headerlink" title="8、所有服务器安装JDK"></a>8、所有服务器安装JDK</h3><p><strong>第一步：</strong>安装官方提供的JDK</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y oracle-j2sdk1.8-1.8.0+update181-1.x86_64</span><br></pre></td></tr></table></figure><p><strong>第二步：</strong>配置jdk的环境变量</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/java/jdk1.8.0_181-cloudera</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/jre/lib/rt.jar:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p><strong>第三步：</strong>添加mysql驱动包</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/share/java</span><br><span class="line">mv /root/mysql-connector-java-5.1.46.jar /usr/share/java/</span><br><span class="line"><span class="built_in">cd</span> /usr/share/java/</span><br><span class="line">mv mysql-connector-java-5.1.46.jar mysql-connector-java.jar</span><br></pre></td></tr></table></figure><p>注意：以上三步在所有服务器都要配置</p><h3 id="四、Cloudera-Manager-部署"><a href="#四、Cloudera-Manager-部署" class="headerlink" title="四、Cloudera Manager 部署"></a>四、Cloudera Manager 部署</h3><h4 id="第一步：安装CM-server-及agent"><a href="#第一步：安装CM-server-及agent" class="headerlink" title="第一步：安装CM server 及agent"></a>第一步：安装CM server 及agent</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装python27，解决安装过程中Hue无法访问数据库问题</span></span><br><span class="line">yum install -y centos-release-scl</span><br><span class="line">yum install -y python27 python27-devel</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install cloudera-manager-daemons</span><br><span class="line">yum -y install cloudera-manager-agent</span><br><span class="line"></span><br><span class="line"><span class="comment">#仅hadoop01服务器安装cloudera-manager-server</span></span><br><span class="line">yum -y install cloudera-manager-server</span><br></pre></td></tr></table></figure><h4 id="第二步：所有节点修改agent配置"><a href="#第二步：所有节点修改agent配置" class="headerlink" title="第二步：所有节点修改agent配置"></a>第二步：所有节点修改agent配置</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/cloudera-scm-agent/config.ini</span><br><span class="line"><span class="comment">#修改文件中server_host的属性值</span></span><br><span class="line">server_host=bigdata01.baicat.com</span><br></pre></td></tr></table></figure><h4 id="第三步：初始化scm数据库"><a href="#第三步：初始化scm数据库" class="headerlink" title="第三步：初始化scm数据库"></a>第三步：初始化scm数据库</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#hadoop01主节点执行</span></span><br><span class="line">/opt/cloudera/cm/schema/scm_prepare_database.sh mysql scm scm scm</span><br></pre></td></tr></table></figure><p>结果为：<code>All done, your SCM database is configured correctly!</code>，表示初始化成功。</p><h4 id="第四步：启动CM-server及agent"><a href="#第四步：启动CM-server及agent" class="headerlink" title="第四步：启动CM server及agent"></a>第四步：启动CM server及agent</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bigdata01主节点启动CM server</span></span><br><span class="line">systemctl start cloudera-scm-server</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动日志目录为/var/log/cloudera-scm-server/ </span></span><br><span class="line"><span class="built_in">cd</span> /var/<span class="built_in">log</span>/cloudera-scm-server/ </span><br><span class="line">tail cloudera-scm-server.log</span><br><span class="line"></span><br><span class="line"><span class="comment">#所有节点启动CM agent</span></span><br><span class="line">systemctl start cloudera-scm-agent </span><br></pre></td></tr></table></figure><p>这里会报错，提示Jdk找不到，解决办法</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/java</span><br><span class="line">ln -s /opt/jdk1.8  /usr/java/default</span><br></pre></td></tr></table></figure><p><strong>web页面：</strong>     <a href="http://bigdata01:7180/">http://bigdata01:7180/</a></p><p><strong>默认登录账号：</strong>admin</p><p><strong>默认登录密码：</strong>admin</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 大数据 </category>
          
          <category> cdh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cdh,大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索数数量</title>
      <link href="/2021/08/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E6%95%B0%E9%87%8F/"/>
      <url>/2021/08/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数</p><p><strong>示例1：</strong></p><img src="/2021/08/03/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E6%95%B0%E9%87%8F/uniquebstn3.jpg" class title="img"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>思路一：</p><p>看到这道题目的第一个念头是用数学公式直接进行计算（后面确实也是通过公式计算通过），因为在数据结构这门课上，曾讲过这个计算二叉树种类的公式，所以自然而然的想到了用公式解决问题。（但感觉自己还是缺乏思考，没能想到用动态规划😀）</p><p><strong>卡塔兰数公式：</strong><br>$$<br>C0=1,Cn+1=2(2n+1)Cn/n+2<br>$$<br>使用这个方法时需要注意类型要使用long，<strong>不然会溢出，从而导致错误答案</strong></p><p>代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">public int <span class="function"><span class="title">numTrees</span>(<span class="params">int n</span>)</span> &#123;</span><br><span class="line">    long num2=<span class="number">1</span>;</span><br><span class="line">    int temp=<span class="number">2</span>*n;</span><br><span class="line">    int temp1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>,j=<span class="number">1</span>; i &lt;n &amp;&amp;j&lt;=n; i++,j++) &#123;</span><br><span class="line">        num2*=temp;</span><br><span class="line">        <span class="keyword">if</span>(num2%j==<span class="number">0</span>)&#123;</span><br><span class="line">            num2=num2/j;</span><br><span class="line">            temp1=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp1*=j;</span><br><span class="line">        &#125;</span><br><span class="line">        temp--;</span><br><span class="line">    &#125;</span><br><span class="line">    long sum=num2/(temp1*(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        long C = 1;</span></span><br><span class="line">    <span class="comment">//        for (int i = 0; i &lt; n; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//            C = C * 2 * (2 * i + 1) / (i + 2);</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//        return (int) C;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (int)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思路二：</strong></p><p>动态规划解决：将一颗二叉搜索树，分为三部分，根节点，左子树和右子树，而每个不同的根节点，所能构成的二叉搜索树种数为左子树构成二叉搜索数的种类 * 右子树构成二叉搜索树的种类</p><p><strong>状态转移方程：</strong><br>$$<br>dp[i]=sum(dp[i-j]*dp[j-1])<br>i=1 … n<br>$$<br>i为当前的节点个数</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n==0时，dp[n]=1;n==1时,dp[n]=1</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;=i; j++) &#123;</span><br><span class="line">                dp[i]+=dp[i-j]*dp[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划,二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库连接模板</title>
      <link href="/2021/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%A8%A1%E6%9D%BF/"/>
      <url>/2021/07/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="从properties文件中读取mysql配置信息，编写JDBCUtils"><a href="#从properties文件中读取mysql配置信息，编写JDBCUtils" class="headerlink" title="从properties文件中读取mysql配置信息，编写JDBCUtils"></a>从properties文件中读取mysql配置信息，编写JDBCUtils</h3><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4><p>jdbc.properties</p><p>时区设置：<code>Asia/Shanghai</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">mjy600811</span></span><br><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/girls?useSSL=false&amp;serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8</span></span><br></pre></td></tr></table></figure><h4 id="JDBCUtils-java"><a href="#JDBCUtils-java" class="headerlink" title="JDBCUtils.java"></a>JDBCUtils.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(is);</span><br><span class="line">        String username = prop.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = prop.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String url = prop.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        String driver = prop.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSource</span><span class="params">(Connection conn, PreparedStatement pre, ResultSet rs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pre.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> mysql连接 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql,模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp网站登录（简易）</title>
      <link href="/2021/07/31/jsp%E7%BD%91%E7%AB%99%E7%99%BB%E5%BD%95%EF%BC%88%E7%AE%80%E6%98%93%EF%BC%89/"/>
      <url>/2021/07/31/jsp%E7%BD%91%E7%AB%99%E7%99%BB%E5%BD%95%EF%BC%88%E7%AE%80%E6%98%93%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>实现功能</strong>：</p><p>实现一个简易的网站登录访问页面：页面只有在登录的时候才能访问，若未登录无法访问。</p><p><strong>主要知识点：</strong></p><ul><li>jsp跳转、servlet</li><li>filter过滤器</li></ul><h4 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Jstl表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>LoginServlet.Java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        String us=(String)session.getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line">        System.out.println(us);</span><br><span class="line">        <span class="comment">//判断是否登录：若登录则直接跳转到页面</span></span><br><span class="line">        <span class="keyword">if</span>(us==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(req.getParameter(<span class="string">&quot;username&quot;</span>)))&#123;</span><br><span class="line">                session.setAttribute(<span class="string">&quot;USER_SESSION&quot;</span>, session.getId());</span><br><span class="line">                resp.sendRedirect(<span class="string">&quot;/filter/turnto/success.jsp&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resp.sendRedirect(<span class="string">&quot;/filter/error/mistake.jsp&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/filter/turnto/success.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LogoutServlet.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogoutServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;USER_SESSION&quot;</span>);</span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/filter/login/login.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RequestFilter.java</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        HttpServletResponse resp=(HttpServletResponse) response;</span><br><span class="line">        HttpSession session = req.getSession();</span><br><span class="line">        <span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;USER_SESSION&quot;</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">            resp.sendRedirect(<span class="string">&quot;/filter/login/login.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>login.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;登录界面&lt;/h1&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;/filter/servlet/login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>success.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;strong&gt;欢迎您，使用本产品&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;../index.jsp&quot;</span>&gt;首页&lt;/a&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;../servlet/logout&quot;</span> methods=<span class="string">&quot;get&quot;</span>&gt;注销&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;主页&lt;/h1&gt;</span><br><span class="line">&lt;div id=<span class="string">&quot;login&quot;</span>&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;/filter/login/login.jsp&quot;</span>&gt;登录&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>web.xml中配置过滤器：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>RequestFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.mjy.filter.RequestFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>RequestFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/turnto/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> Javaweb </category>
          
          <category> jsp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 登录过程,filter,jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子序列和</title>
      <link href="/2021/07/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
      <url>/2021/07/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例5：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-100000]</span><br><span class="line">输出：-100000</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><p><strong>思路：</strong></p><p>动态规划：根据题目中的条件推出状态转移方程</p><p><code>dp[i]=max(dp[i-1]+nums[i],nums[i])</code></p><p>及对当前元素判断之前的子序列和是否对其有增益，若有增益则dp[i-1]+nums[i];如无增益，则等于自身的值</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转义方程max(dp[i-1]+nums[i],nums[i])：判断dp[i]对nums[i]是否是负增益，若为负增益则重置dp[i]的值</span></span><br><span class="line">        <span class="comment">//自己的错误思路：考虑的是nums[i]对dp[i]是否有增益导致状态转移方程出错</span></span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            max=max&gt;dp[i]? max:dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组,动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaweb验证码</title>
      <link href="/2021/07/27/Javaweb%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
      <url>/2021/07/27/Javaweb%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h4 id="后端实现验证码生成代码："><a href="#后端实现验证码生成代码：" class="headerlink" title="后端实现验证码生成代码："></a>后端实现验证码生成代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VerificationServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//让浏览器自动刷新</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在内存中创建一个图片</span></span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(<span class="number">80</span>, <span class="number">30</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到图片</span></span><br><span class="line">        Graphics2D graphics = (Graphics2D) image.getGraphics();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置图片的背景颜色</span></span><br><span class="line">        graphics.setColor(Color.cyan);</span><br><span class="line">        graphics.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">80</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给图片写数据</span></span><br><span class="line">        graphics.setColor(Color.green);</span><br><span class="line">        graphics.setFont(<span class="keyword">new</span> Font(<span class="keyword">null</span>,Font.CENTER_BASELINE,<span class="number">20</span>));</span><br><span class="line">        graphics.drawString(createRandomNum(),<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//告诉浏览器，这个请求用图片的方式打开</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">//网站存在缓存，不让浏览器缓存</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把图片写给浏览器</span></span><br><span class="line">        ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>,resp.getOutputStream());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随机数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createRandomNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String s = random.nextInt(<span class="number">9999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuilder sbl = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> - s.length(); i++) &#123;</span><br><span class="line">            sbl.append(<span class="string">&quot;&quot;</span>+random.nextInt(<span class="number">9</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sbl.toString()+s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> Javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet,数字验证码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javaweb文件下载</title>
      <link href="/2021/07/27/Javaweb%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
      <url>/2021/07/27/Javaweb%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="下载文件步骤"><a href="#下载文件步骤" class="headerlink" title="下载文件步骤"></a>下载文件步骤</h4><ul><li>获取下载文件的路径</li><li>下载的文件名</li><li>获取下载文件的输入流</li><li>创建缓冲区</li><li>获取OutputStream对象</li><li>将FileOutputStream流写入到buffer缓冲区中</li><li>使用OutputStream将缓冲区的数据输出到客户端</li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取ServletContext</span></span><br><span class="line">        ServletContext context = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">        <span class="comment">//获取文件的路径</span></span><br><span class="line">        String realPath =<span class="string">&quot;D:\\JavaLearn\\project\\Javaweb\\Javawebcode1\\httpServletResponse\\target\\classes\\img\\黑色.jpg&quot;</span>;</span><br><span class="line">        System.out.println(realPath);</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        String filename = realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//让浏览器能够支持（Content-Disposition）下载我们需要的东西,中文文件名需要使用URLEncoder编码，否则有可能乱码</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+ URLEncoder.encode(filename,<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">        <span class="comment">//获取文件输入流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);</span><br><span class="line">        <span class="comment">//获取输出流</span></span><br><span class="line">        ServletOutputStream os = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] arr=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((len=fis.read(arr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(arr,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭输入输出流</span></span><br><span class="line">        os.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java后端 </category>
          
          <category> Javaweb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传,servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题</title>
      <link href="/2021/07/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/07/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong>请你谈谈网站是如何进行访问的：</strong></p><ol><li>在浏览器输入域名：回车</li><li>浏览器会查找本机的<strong>C:\Windows\System32\drivers\etc</strong>目录下的<strong>hosts文件</strong>中有没有这个域名的映射<ul><li>有：获取对应的ip地址，通过这个ip，我们可以访问到想要访问的web程序</li><li>没有：去DNS域名解析服务器中找是否存在输入域名，若找到，则返回ip并对该ip进行访问；若没找到，就返回未找到</li></ul></li></ol><p><strong>当浏览器中地址栏输入地址并回车的一瞬间到页面能够显示出来，经历了什么？</strong></p><p>作为客户端，浏览器接收到地址之后，首先会到windows系统文件hosts中查找是否有需要劫持的ip地址，若没有则需要询问DNS域名解析服务器该域名对应的ip地址。（DNS缓存）<br>浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</p><p>获取到正确的ip地址后，客户端会与服务器建立TCP连接（三次握手），（网络层、数据链路层、物理层）</p><p>客户端向服务端发送请求，包含请求行、请求头、请求正文。多种请求方式（GET，POST、PUT等）</p><p>服务端处理请求，并返回响应，包含状态码、响应头、响应体</p><p>浏览器收到响应，解析渲染页面，展示出来</p><p>断开连接（http1.0短连接，http1.1长连接）</p><p><strong>请你聊聊重定向与转发的区别：</strong></p><img src="/2021/07/26/Java%E9%9D%A2%E8%AF%95%E9%A2%98/image-20210727000815878.png" class title="image-20210727000815878"><p>相同点：</p><ul><li>都能实现页面跳转</li></ul><p>不同点：</p><ul><li>请求转发的时候，url不会发生变化</li><li>重定向的时候，url地址栏会发生变化</li><li>重定向需要两次请求，请求转发需要一次请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Java </category>
          
          <category> Java面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试,Javaweb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列</title>
      <link href="/2021/07/25/%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>/2021/07/25/%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>这个题目意思很简单易懂，就是获取所给数组的所有的排列方式，注意这里<strong>的所有</strong>，基本上涉及到求”所有”的题目都能通过回溯法解决</p><p>话不多说，贴代码</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯法（一般求所有情况下，回溯法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullPermutation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FullPermutation test=<span class="keyword">new</span> FullPermutation();</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(test.permute(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个标记数组，标记该元素是否已经使用过</span></span><br><span class="line">        <span class="keyword">int</span>[] flag=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtrack(nums,list,<span class="number">0</span>,deque,flag);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; list,<span class="keyword">int</span> index,Deque&lt;Integer&gt; deque,<span class="keyword">int</span>[] flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==nums.length)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(deque));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                deque.addLast(nums[i]);</span><br><span class="line">                flag[i]=<span class="number">1</span>;</span><br><span class="line">                backtrack(nums,list,index+<span class="number">1</span>,deque,flag);</span><br><span class="line">                deque.removeLast();</span><br><span class="line">                flag[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法,leetcode,回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase简单学习</title>
      <link href="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Hbase简单记录"><a href="#Hbase简单记录" class="headerlink" title="Hbase简单记录"></a>Hbase简单记录</h1><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>Hbase是一个开源的、分布式的、版本化的非关系型数据库，它利用Hadoop分布式文件系统（HDFS）提供分布式数据存储。</p><p>HBase是一个可以进行随机访问的存取和检索数据的存储平台，存储结构化和半结构化的数据，因此一般的网站可以将网页内容和日志信息都存在HBase里。</p><p>如果数据量不是非常庞大，HBase甚至可以存储非结构化的数据。它不要求数据有预定义的模式，允许动态和灵活的数据模型，也不限制存储数据的类型。</p><p>HBase是非关系型数据库，它不具备关系型数据库的一些特点，例如，它不支持SQL的跨行事务，也不要求数据之间有严格的关系，同时它允许在同一列的不同行中存储不同类型的数据。</p><p>HBase是非惯性型数据库，它不具备关系型数据库的一些特点，是被设计成在一个服务器集群上运行的。</p><h4 id="HBase的特点："><a href="#HBase的特点：" class="headerlink" title="HBase的特点："></a>HBase的特点：</h4><ul><li><p>容量巨大</p><p>HBase的单表可以有百亿行，百万列，可以在横向和纵向两个维度插入数据，具有很大的弹性</p><p>当关系型数据库的单个表的记录在亿级时，查询和写入的性能都会呈现指数级下降，这种庞大的数据量对传统数据库来说是一种灾难，而HBase在限定某个列的情况下对于单表存储百亿甚至更多的数据都没有性能问题</p><p>HBase采用LSM树作为内部数据存储结构，这种结构会周期性地将较小文件合成大文件，以减少对磁盘的访问</p></li><li><p>列存储</p><p>行存储的一张表的数据都放在一起，但在列存储里是按照列分开保存的。在这种情况下，进行数据的插入和更新，行存储会相对容易。而进行行存储时，查询操作需要读取所有的数据，列存储则只需要读取相关列，可以大幅降低系统I/O吞吐量</p></li><li><p>稀疏性</p><p>HBase中的数据都是以字符串形式存储的，为空的列并不占用存储空间，因此HBase的列存储解决了数据稀疏性的问题，在很大程度上节省了存储开销。所以HBase通常可以设计成稀疏矩阵，同时这种方式比较接近实际的应用场景</p></li><li><p>扩展性强</p><p>HBase 工作在 HDFS 之上，理所当然地支持分布式表，也继承了 HDFS 的可扩展性。HBase 的扩展是<strong>横向</strong>的，横向扩展是指在扩展时不需要提升服务器本身的性能，只需<strong>添加服务器到现有集群</strong>即可。</p><p>HBase 表根据 <strong>Region 大小进行分区</strong>，<strong>分别存在集群中不同的节点上</strong>，当添加新的节点时，集群就重新调整，在新的节点启动 HBase 服务器，动态地实现扩展。这里需要指出，HBase 的扩展是<strong>热扩展</strong>，即在不停止现有服务的前提下，可以随时添加或者减少节点。</p></li><li><p>高可靠性</p></li></ul><h3 id="HDFS的原理"><a href="#HDFS的原理" class="headerlink" title="HDFS的原理"></a>HDFS的原理</h3><p>HDFS 是参考 Google 公司的 GFS 实现的，不管是 Google 公司的计算平台还是 Hadoop 计算平台，都是运行在大量普通商用计算机上的，这些计算机节点很容易出现硬件故障，而这两种计算平台都将硬件故障作为常态，通过软件设计来保证系统的可靠性。</p><h4 id="HDFS的基本架构"><a href="#HDFS的基本架构" class="headerlink" title="HDFS的基本架构"></a>HDFS的基本架构</h4><p><code>HDFS</code> 主要由 3 个组件构成，分别是 <code>NameNode、SecondaryNameNode 和 DataNode。</code></p><p><code>HDFS</code> 是以 Master/Slave 模式运行的，其中，<code>NameNode </code>和<code> SecondaryNameNode</code> 运行在 Master 节点 上，而 <code>DataNode </code>运行在 Slave 节点上，所以 <code>HDFS </code>集群一般由一个 <code>NameNode</code>、一个<code>SecondaryNameNode</code>和许多 <code>DataNode </code>组成，其架构如下图所示。</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210720151549111.png" class title="image-20210720151549111"><p><a href="http://c.biancheng.net/view/6502.html">HDFS简明入门教程 (biancheng.net)</a></p><h4 id="HBase逻辑结构"><a href="#HBase逻辑结构" class="headerlink" title="HBase逻辑结构"></a>HBase逻辑结构</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210720185905040.png" class title="image-20210720185905040"><h4 id="HBase物理结构："><a href="#HBase物理结构：" class="headerlink" title="HBase物理结构："></a>HBase物理结构：</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210720212833190.png" class title="image-20210720212833190"><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p><code>Name Space</code>:</p><p>命名空间，类似于关系型数据库的database概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是hbase和default，HBase中存放的是HBase内置的表，default表是用户默认使用的命名空间</p><p><code>Region</code>:类似于关系型数据库的表的概念。不同的是，HBase定义表时只需要声明列族即可，不需要声明具体的类。这意味着，往HBase写入数据时，字段可以<strong>动态</strong>、<strong>按需</strong>指定</p><p><code>Row</code>:HBase表中的每行数据都由一个RowKey和多个Column（列组成），数据是按照RowKey的字典顺序存储的，并且查询数据时只能根据RowKey进行检索。</p><p><code>Column</code>:HBase中的每个列都由Column Family(列族)和Column  Qualifier（列限定符）进行限定，例如info：name，info:age。建表时，只需指明列族，而列限定符无需预先定义。</p><p><code>Time Stamp</code></p><p>用于标识数据的不同版本(version)，每条数据写入时，如果不指定时间戳，系统会自动为其加上该字段，其值为写入HBase的时间</p><p><code>Cell</code>：</p><p>由{rowKey，column Family：column Qualifier，time Stamp} 唯一确定的单元。cell中的数据是没有类型的，全部是字节码形式存储</p><h4 id="HBase架构："><a href="#HBase架构：" class="headerlink" title="HBase架构："></a>HBase架构：</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721132312788.png" class title="image-20210721132312788"><h4 id="HBase的shell操作"><a href="#HBase的shell操作" class="headerlink" title="HBase的shell操作"></a>HBase的shell操作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bin/hbase shell <span class="comment">#命令行界面</span></span><br></pre></td></tr></table></figure><p>删除写错的内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+delete</span><br></pre></td></tr></table></figure><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/bigdata/data/Hbase/Hbase的学习/image-20210721151254543.png" alt="image-20210721151254543" style="zoom:200%;"><p>使用shell报错</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721151938883.png" class title="image-20210721151938883"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先用命令查看安全模式状态</span><br><span class="line">bin/hdfs dfsadmin -safemode get</span><br><span class="line">#发现安全模式开启，关闭即可</span><br><span class="line">bin/hdfs dfsadmin -safemode leave</span><br></pre></td></tr></table></figure><p>安全模式：</p><p>当分布式文件系统（HDFS）开始启动时，会有安全模式，HDFS处在安全模式下，文件系统中不允许修改和删除的操作。</p><p>安全模式主要是为了系统启动的时候检查各个DataNode上数据块的有效性，同时根据策略必要的复制或者删除部分数据块。</p><p>创建表的语句</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cretae <span class="string">&#x27;表名&#x27;</span>,<span class="string">&#x27;列族名&#x27;</span>,<span class="string">&#x27;列族名&#x27;</span></span><br></pre></td></tr></table></figure><p>修改表信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改versions</span><br><span class="line">alter &#x27;表名&#x27;,&#123;NAME=&gt;&#x27;列族名&#x27;,VERSIONS=&gt;3&#125;</span><br></pre></td></tr></table></figure><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看表</span><br><span class="line">list</span><br><span class="line">#先将表变为不可用</span><br><span class="line">disbale &#x27;表名&#x27;</span><br><span class="line">#再删除表</span><br><span class="line">drop &#x27;表名&#x27;</span><br></pre></td></tr></table></figure><p>命名空间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看命名空间</span><br><span class="line">list_namespace</span><br><span class="line">#创建命名空间</span><br><span class="line">create_namespace &#x27;命名空间名&#x27;</span><br><span class="line">#删除命名空间（首先得将里面的表删除）</span><br><span class="line">disable &#x27;命名空间:表名&#x27;</span><br><span class="line">drop &#x27;命名空间:表名&#x27;</span><br><span class="line">drop_namespace &#x27;命名空间&#x27;</span><br></pre></td></tr></table></figure><p>向表中插入数据</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721155900344.png" class title="image-20210721155900344"><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">put <span class="string">&#x27;命名空间（默认为default）:表名&#x27;</span>,<span class="string">&#x27;row_key&#x27;</span>,<span class="string">&#x27;列族:列名&#x27;</span>,<span class="string">&#x27;值&#x27;</span></span><br></pre></td></tr></table></figure><p>scan</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721160444790.png" class title="image-20210721160444790"><p>get</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721160512874.png" class title="image-20210721160512874"><p>查看10个版本以内的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scan &#x27;表名&#x27;,&#123;RAW=&gt;true,VERSIONS=&gt;10&#125;</span><br></pre></td></tr></table></figure><p>delete</p><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721182714486.png" class title="image-20210721182714486"><h4 id="Hbase详细架构"><a href="#Hbase详细架构" class="headerlink" title="Hbase详细架构"></a>Hbase详细架构</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721220238386.png" class title="image-20210721220238386"><h4 id="Hbase写流程"><a href="#Hbase写流程" class="headerlink" title="Hbase写流程"></a>Hbase写流程</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210721205533542.png" class title="image-20210721205533542"><p>写流程：</p><ul><li>Client先访问zookeeper,获取hbase:meta表位于哪个Region Server</li><li>访问对应的Region Server,获取hbase:meta表，根据读请求的namespace:table/rowkey,查询楚目标数据位于哪个Region Server中的哪个Region中。并将该table的region信息以及meta表的位置信息缓存在meta cache，方便下次访问</li><li>与目标Region Server进行通信</li><li>将数据顺序写（追加）到WAL</li><li>将数据写入对应的MemStore，数据会在MemStore进行排序</li><li>向客户端发送ack</li><li>等达到MemStore的刷写时机后，将数据刷写到HFile</li></ul><h4 id="HBase读流程"><a href="#HBase读流程" class="headerlink" title="HBase读流程"></a>HBase读流程</h4><img src="/2021/07/23/HBase%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/image-20210722165440443.png" class title="image-20210722165440443"><h4 id="与Hive的集成"><a href="#与Hive的集成" class="headerlink" title="与Hive的集成"></a>与Hive的集成</h4><h4 id="HBase与Hive的对比"><a href="#HBase与Hive的对比" class="headerlink" title="HBase与Hive的对比"></a>HBase与Hive的对比</h4><p>Hive:</p><ul><li><p>数据仓库</p><p>Hive的本质其实就相当于将HDFS中已经存储的文件在MySQL中做了一个双射关系，以方便使用HQL去管理查询</p></li><li><p>用于数据分析、清洗</p><p>Hive适用于离线的数据分析和清洗，延迟较高</p></li><li><p>基于HDFS、MapReduce</p><p>Hive存储的数据依旧在DataNode上，编写的HQL语句终将是转换为MapReduce代码执行</p></li></ul><p><strong>HBase:</strong></p><ul><li><p>数据库</p><p>是一种面向列族存储的非关系型数据库</p></li><li><p>用于存储结构化和非结构化的数据</p><p>适用于单表非关系型数据的存储，不适合做关联查询，类似Join等操作</p></li><li><p>基于HDFS</p><p>数据持久化存储的体现形式是HFile，存放于DataNode中，被ResionServer以region的形式进行管理</p></li><li><p>延迟较低，接入在线业务使用</p><p>面对大量的企业数据，HBase可以直线单表大量数据的存储，同时提高了高效的数据访问速度</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 大数据 </category>
          
          <category> HBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据,列式存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下一个排列</title>
      <link href="/2021/07/22/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2021/07/22/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须 原地 修改，只允许使用额外常数空间</p><p>**字典序:**字典序的下一个排列总是要比当前排列要大，除非该排列已经是最大的排列。要找到一个大于当前序列的新序列，且变大的幅度尽可能的小</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,5]</span><br><span class="line">输出：[1,5,1]</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><p>学习体会：开始把这个题读完了之后，整个人都是懵的，在反复独了几遍题目，发现还是读不懂后，选择看题解。。。</p><p>题解思路：</p><p>找到从右往左查找第一个不是递减的数，然后再从右到第一个不为递减的元素中找一个大于不为递减元素的值，并将这两个值交换，再从第一个不为递减的元素的位置到最后位置的元素反转一下，最终得到下一个排列</p><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//思想：字典序的下一个排列总是要比当前排列要大，除非该排列已经是最大的排列。要找到一个大于当前序列的新序列，且变大的幅度尽可能的小</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextPermutationDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NextPermutationDemo test=<span class="keyword">new</span> NextPermutationDemo();</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        test.nextPermutation(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从后往前查找第一个不是降序排列的数</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后往前查找比上面查找的值大的元素，交换</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;i&amp;&amp;i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[i])&#123;</span><br><span class="line">                swap(nums,i,j);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reverseArr(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[i];</span><br><span class="line">        arr[i]=arr[j];</span><br><span class="line">        arr[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseArr</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left=start,right=arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            swap(arr,left,right);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法,leetcode,中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC基础学习</title>
      <link href="/2021/07/20/JUC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2021/07/20/JUC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="JUC简介"><a href="#JUC简介" class="headerlink" title="JUC简介"></a>JUC简介</h3><p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util.concurrent工具包的简称。这是一个处理线程的工具包，JDK1.5开始出现。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 后端 </category>
          
          <category> Java线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盛最多水的容器</title>
      <link href="/2021/07/15/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2021/07/15/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>题目描述：</strong></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p><strong>示例1：</strong></p><img src="/2021/07/15/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/image-20210715115032300.png" class title="image-20210715115032300"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure><p><strong>示例4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,2,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n = height.length</code></li><li><code>2 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li></ul><p><strong>题目解读：</strong></p><p>题目所给的数组，相当于每个元素就是一个坐标（i,ai）,这个坐标代表了所画的柱状图的最高点。而我们需要求的就是两个柱状图之间的最大面积（此面积的高为两个柱状图之间较小的那个高）。求长方形的面积就少不了长和宽，而最大面积的话就需要长和宽都尽量的大。这也是本题的难点，如何求得较大的长和宽。</p><p>这里选择使用双指针来进行枚举，一个指针指向开头，一个指针指向结尾。然后接下来需要考虑的问题就是如何移动指针来获得最大值，我们发现，无论怎么移动指针，所围成的面积的长度都会减少，在这种情况下，我们选择较小高的那个指针移动就能取得最大值。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea1</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=height.length;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=len-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=height[i]&lt;height[j]? height[i++]:height[j--];</span><br><span class="line">            max=max&gt;min*(j-i+<span class="number">1</span>)? max:min*(j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法,leetcode,中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java安装</title>
      <link href="/2021/07/13/Java%E5%AE%89%E8%A3%85/"/>
      <url>/2021/07/13/Java%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h4 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h4><p>下载地址：</p><p>oracle官网：<a href>https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>进入页面后下载64位的包，jdk-8u291-linux-x64.tar.gz与jdk-8u291-linux-x64.rpm都可以</p><p>这里我下载的是<strong>jdk-8u291-linux-x64.tar.gz</strong></p><p>在linux下<code>/usr/local</code>目录下，使用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir jdk<span class="comment">#文件名可以随便取</span></span><br></pre></td></tr></table></figure><p>将下载好的jdk-8u291-linux-x64.tar.gz通过xshell传输到linux下的<code>/usr/local/jdk</code>中</p><img src="/2021/07/13/Java%E5%AE%89%E8%A3%85/image-20210713230043661.png" class title="image-20210713230043661"><p>传输到文件目录下</p><img src="/2021/07/13/Java%E5%AE%89%E8%A3%85/image-20210713225957847.png" class title="image-20210713225957847"><p>使用命令进行解压到当前目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf jdk-8u291-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><img src="/2021/07/13/Java%E5%AE%89%E8%A3%85/image-20210713230055548.png" class title="image-20210713230055548"><h4 id="编写配置文件，配置环境变量"><a href="#编写配置文件，配置环境变量" class="headerlink" title="编写配置文件，配置环境变量"></a>编写配置文件，配置环境变量</h4><p>使用命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>按”i”进入编辑模式，添加上下面的内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk/jdk1.8.0_291</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br></pre></td></tr></table></figure><img src="/2021/07/13/Java%E5%AE%89%E8%A3%85/image-20210713230119200.png" class title="image-20210713230119200"><p>添加后，按“ESC”退出编辑模式，并<code>:wq</code>进行保存修改内容。（若没有使用修改内容不会保存）</p><p>最后还要使用命令,使配置的环境变量生效</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><p>安装完毕后，使用命令<code>java -version</code>查看是否安装成功</p><img src="/2021/07/13/Java%E5%AE%89%E8%A3%85/image-20210713230142680.png" class title="image-20210713230142680"><p>出现上面图片中的内容，说明安装成功</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,Java安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos配置中心</title>
      <link href="/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一、配置文件介绍"><a href="#一、配置文件介绍" class="headerlink" title="一、配置文件介绍"></a>一、配置文件介绍</h2><h4 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h4><p>Spring Cloud Config为分布式系统的外部配置提供了服务端和客户端的支持方案。在配置的服务段你可以在所有环境中为应用程序管理外部属性的中心位置。客户端和服务端概念上的Spring Environment 和 PropertySource 抽象保持同步, 它们非常适合Spring应用程序，但是可以与任何语言中运行的应用程序一起使用。当应用程序在部署管道中从一个开发到测试直至进入生产时，您可以管理这些环境之间的配置，并确保应用程序在迁移时具有它们需要运行的所有内容。服务器存储后端的默认实现使用git，因此它很容易支持标记版本的配置环境，并且能够被管理内容的各种工具访问。很容易添加替代的实现，并用Spring配置将它们插入。</p><p>Spring Cloud Config 包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。Spring cloud使用git或svn存放配置文件，默认情况下使用git。</p><h4 id="Nacos替换Config"><a href="#Nacos替换Config" class="headerlink" title="Nacos替换Config"></a>Nacos替换Config</h4><p>Nacos 可以与 Spring, Spring Boot, Spring Cloud 集成，并能代替 Spring Cloud Eureka, Spring Cloud Config。通过 Nacos Server 和 spring-cloud-starter-alibaba-nacos-config 实现配置的动态变更。</p><p><strong>应用场景</strong></p><p>在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。</p><p>如果微服务架构中没有使用统一配置中心时，所存在的问题：</p><p>- 配置文件分散在各个项目里，不方便维护</p><p>- 配置内容安全与权限</p><p>- 更新配置后，项目需要重启</p><p>nacos配置中心：系统配置的集中管理（编辑、存储、分发）、动态更新不重启、回滚配置（变更管理、历史版本管理、变更审计）等所有与配置相关的活动。</p><h4 id="读取Nacos配置中心的配置文件"><a href="#读取Nacos配置中心的配置文件" class="headerlink" title="读取Nacos配置中心的配置文件"></a>读取Nacos配置中心的配置文件</h4><ul><li><p>在Nacos创建同一配置文件</p><img src="/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image-20210713173521686.png" class title="image-20210713173521686"></li><li><p>输入配置信息及配置内容</p><img src="/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image-20210713173649714.png" class title="image-20210713173649714"></li><li><p>Data ID的完整规则格式</p><p><strong>${prefix}-${spring.profile.active}.${file-extension}</strong></p><p><strong>- prefix</strong> 默认为所属工程配置spring.application.name 的值（即：nacos-provider），也可以通过配置项 spring.cloud.nacos.config.prefix来配置。</p><p><strong>- spring.profiles.active=dev</strong> 即为当前环境对应的 profile。 注意：当 spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}</p><p><strong>- file-exetension</strong> 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</p><p><strong>注</strong>：使用Nacos的配置中心需要引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="对单个配置文件的读取"><a href="#对单个配置文件的读取" class="headerlink" title="对单个配置文件的读取"></a>对单个配置文件的读取</h4><p><strong>创建项目的bootstrap.properties/yml文件，用于定义一些一般不会变动的参数</strong></p><p>bootstrap.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置中心地址</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#若存在profile，则dataId的要加上该profile,proflie:dev(生产) 、test(测试)、prod(生产)</span></span><br><span class="line"><span class="comment">#spring.profiles.active=dev</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-statistics</span></span><br></pre></td></tr></table></figure><p>bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="comment">#nacos服务地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-sta</span></span><br></pre></td></tr></table></figure><p><strong>补充：springboot配置文件加载顺序</strong></p><p>其实yml和properties文件是一样的原理，且一个项目上要么yml或者properties，二选一的存在。推荐使用yml，更简洁。</p><p>bootstrap与application<br><strong>（1）加载顺序</strong><br>这里主要是说明application和bootstrap的加载顺序。</p><p>bootstrap.yml（bootstrap.properties）先加载<br>application.yml（application.properties）后加载<br>bootstrap.yml 用于应用程序上下文的引导阶段。</p><p>bootstrap.yml 由父Spring ApplicationContext加载。</p><p>父ApplicationContext 被加载到使用 application.yml 的之前。</p><p><strong>（2）配置区别</strong><br>bootstrap.yml 和application.yml 都可以用来配置参数。</p><p>bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。<br>application.yml 可以用来定义应用级别的。</p><h4 id="名称空间切换环境"><a href="#名称空间切换环境" class="headerlink" title="名称空间切换环境"></a>名称空间切换环境</h4><p>在实际开发中，通常有多套不同的环境（默认只有public），那么这个时候可以根据指定的环境来创建不同的 namespce，例如，开发、测试和生产三个不同的环境，那么使用一套 nacos 集群可以分别建以下三个不同的 namespace。以此来实现多环境的隔离。</p><p><strong>创建命名空间</strong>：</p><img src="/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image-20210713175003006.png" class title="image-20210713175003006"><p>在不同命名空间中，可以直接创建配置文件，也可以从其它命名空间中克隆配置（推荐）。</p><h4 id="多配置文件加载"><a href="#多配置文件加载" class="headerlink" title="多配置文件加载"></a>多配置文件加载</h4><p>在一些情况下需要加载多个配置文件。假如现在dev名称空间下有三个配置文件：service-statistics.properties、redis.properties、jdbc.properties</p><img src="/2021/07/13/nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/image-20210713175320743.png" class title="image-20210713175320743"><p><strong>添加配置，加载多个配置文件</strong></p><p>properties格式：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 该配置影响统一配置中心中的dataId，之前已经配置过</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">service-statistics</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.namespace</span>=<span class="string">13b5c197-de5b-47e7-9903-ec0538c9db01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="comment"># 开启动态刷新配置，否则配置文件修改，工程无法感知</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].data-id</span>=<span class="string">jdbc.properties</span></span><br><span class="line"><span class="meta">spring.cloud.nacos.config.ext-config[1].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>yml格式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">#使用命名空间时需要填写</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">13b5c197-de5b-47e7-9903-ec0538c9db01</span></span><br><span class="line">        <span class="comment">#读取多个配置文件</span></span><br><span class="line">        <span class="attr">ext-config:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">redis.properties</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">jdbc.properties</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="comment">#动态刷新配置，否则配置文件修改，无法感知</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">service-sta</span></span><br></pre></td></tr></table></figure><p>补充yml的一些书写规则</p><p>数组：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数组</span></span><br><span class="line"><span class="attr">person:</span> </span><br><span class="line">  <span class="attr">name:</span> [<span class="string">zhangsan</span>,<span class="string">lisi</span>,<span class="string">wangwu</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">王五</span></span><br></pre></td></tr></table></figure><p>对象/Map</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对象</span></span><br><span class="line"><span class="attr">person:</span> &#123; <span class="attr">name:</span> <span class="string">zhansan</span>,<span class="attr">age:</span> <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 后端学习 </category>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 配置中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三数之和</title>
      <link href="/2021/07/12/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/07/12/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>题目</strong>：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p><strong>注意</strong>：答案中不可以包含重复的三元组。</p><p><strong>示例1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li></ul><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>根据题目的描述，脑子中闪过的第一个念头就是三重循环枚举每一种类型，但O($n^3$)的时间复杂度，肯定是过不了的。实在想不出来。。就去看了题解，思想依旧是枚举的思想但题解通过双指针的方式降低了时间复杂度，时间复杂度为O($n^2$)。</p><p><strong>题解的双向指针的思想：</strong></p><p>首先把数组进行一次排序，方便后面进行枚举。排序过后，接下来就进行枚举，先进行第一层枚举，从数组的第一个元素进行枚举，将第一层遍历的下标定义为a；第二层枚举（定义下标为b）需要从比a大的元素开始且相连的两个元素不能相同（a也如此），其目的是避免重复的集合。例如[1,2,3,3,3,9]，若两个相邻的元素相同，a=0，b=2时，得到的集合为<code>[1,3]</code>,但当b=3时，得到的集合也为<code>[1,3]</code>这样就会导致所得的集合重复。解决重复的问题后，定义一个target：指第三层的枚举，也是双指针的其中之一。若a不变，b向右边移动，那么随着b的增大，第三层枚举的值是需要减小的，因此双指针正好能满足枚举要求。一个从小到大，一个从大到小，当双指针相等时结束时，跳出循环。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i-<span class="number">1</span>]==nums[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个指向最右端的指针</span></span><br><span class="line">            <span class="keyword">int</span> right=n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> target=-nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//枚举j</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找到a+b+c&lt;=0的情况</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;right&amp;&amp;nums[j]+nums[right]&gt;target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若j==right那么后面不可能再有a+b+c&lt;=0且b&lt;c的情况</span></span><br><span class="line">                <span class="keyword">if</span>(j==right)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]+nums[right]==target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    list1.add(nums[i]);</span><br><span class="line">                    list1.add(nums[j]);</span><br><span class="line">                    list1.add(nums[right]);</span><br><span class="line"></span><br><span class="line">                    list.add(list1);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度分析：</strong></p><p>枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但我们知道它一共会移动的位置数为 N次，所以第二层枚举和第三层枚举的时间复杂度为O(n),枚举的复杂度为O($n^2$),预排序时间复杂度为O(nlogn)所以总的时间复杂度为O($n^2$)</p><p><strong>空间复杂度：</strong></p><p>只定义了一个List，空间复杂度O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法,leetcode,中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/10/hello-world/"/>
      <url>/2021/07/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">listen       9001;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">location ~ /eduService/ &#123;</span><br><span class="line">proxy_pass http://localhost:8001;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /eduoss/ &#123;</span><br><span class="line">proxy_pass http://localhost:8002;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /eduvod/ &#123;</span><br><span class="line">proxy_pass http://localhost:8003;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /educms/ &#123;</span><br><span class="line">proxy_pass http://localhost:8004;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /edumsm/ &#123;</span><br><span class="line">proxy_pass http://localhost:8005;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /educenter/ &#123;</span><br><span class="line">proxy_pass http://localhost:8160;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /api/ &#123;</span><br><span class="line">proxy_pass http://localhost:8160;</span><br><span class="line">&#125;</span><br><span class="line">location ~ /eduorder/ &#123;</span><br><span class="line">proxy_pass http://localhost:8006;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /staservice/ &#123;</span><br><span class="line">proxy_pass http://localhost:8007;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /admin/acl/ &#123;</span><br><span class="line">proxy_pass http://localhost:8010;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
